!function(t){var e={};function n(a){if(e[a])return e[a].exports;var i=e[a]={i:a,l:!1,exports:{}};return t[a].call(i.exports,i,i.exports,n),i.l=!0,i.exports}n.m=t,n.c=e,n.d=function(t,e,a){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:a})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var a=Object.create(null);if(n.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)n.d(a,i,function(e){return t[e]}.bind(null,i));return a},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="/",n(n.s=1)}([function(t,e){t.exports=function(t){function e(t){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",t)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(t):"undefined"!=typeof eval?eval.call(null,t):e("EvalError: No eval function available")}catch(t){e(t)}}},function(t,e,n){n(2),n(4),t.exports=n(6)},function(t,e,n){n(0)(n(3))},function(t,e){t.exports="// Get dom objects for calculator buttons and screen\nvar buttons = document.body.querySelectorAll('.buttons > button');\nvar output = document.querySelector('.window');\n// Assigned variables\nvar operator = ['×', '÷', '-', '+', '%'];\nvar input = '';\nvar dotFlag = false;\nvar result = false;\nvar equation = '';\nvar result = '';\n\n//Initiate event listener for all buttons objects\nfor (var i = 0; i < buttons.length; i++) {\n buttons[i].onclick = function(e) {\n  var btnText = this.innerHTML;\n   // Takes care of the extra zero from AC and CE\n  if ((input == '0' && btnText != '.' && operator.indexOf(btnText) == -1 ) || input == 'NaN' || (result && operator.indexOf(btnText) == -1)) {\n     result = false;\n     input ='';\n  }\n\n  if (btnText === 'AC') {\n   clearAC();\n\n  } else if (btnText === 'CE') {\n\n   input = clearCE(input.length);\n\n  } else if (btnText === '.') {\n   if (input.indexOf('.') === -1 || dotFlag) {\n    input += '.';\n    dotFlag = false;\n   }\n  } else if (btnText === '=') {\n    result = true;\n   input = calc.calculate(input);\n  } else {\n     result = false;\n    input += btnText;\n  }\n  output.innerHTML = input;\n }\n}\n\n\nfunction clearAC() {\n input = 0;\n operatorFlag = false;\n equation = '';\n}\n\nfunction clearCE(length) {\n if (length > 1) {\n  return input.slice(0, input.length - 1);\n }\n return 0;\n}\n\nlet calc = {};\n\ncalc.calculate = function(sequence) {\n equation = sequence.replace(/×/g, '*');\n equation = equation.replace(/÷/g, '/');\n\n try {\n  return Math.round(eval(equation) * 1000000) / 1000000;\n } catch (error) {\n  return 'NaN';\n }\n}\nmodule.exports=calc;\n"},function(t,e,n){n(0)(n(5))},function(t,e){t.exports='/*!\n * Web Experience Toolkit (WET) / Boîte à outils de l\'expérience Web (BOEW)\n * wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * v4.0.30 - 2019-02-11\n *\n *//*! Modernizr (Custom Build) | MIT & BSD */\n/* Modernizr (Custom Build) | MIT & BSD\n * Build: http://modernizr.com/download/#-elem_details-elem_progress_meter-mathml-cors-load-mq-css3-input-inputtypes-svg-cssclasses-csstransitions-fontface-backgroundsize-borderimage-teststyles-testprops-testallprops-hasevents-prefixes-domprefixes\n */\n;window.Modernizr=function(e,t,n){function L(e){f.cssText=e}function A(e,t){return L(p.join(e+";")+(t||""))}function O(e,t){return typeof e===t}function M(e,t){return!!~(""+e).indexOf(t)}function _(e,t){for(var r in e){var i=e[r];if(!M(i,"-")&&f[i]!==n)return t=="pfx"?i:!0}return!1}function D(e,t,r){for(var i in e){var s=t[e[i]];if(s!==n)return r===!1?e[i]:O(s,"function")?s.bind(r||t):s}return!1}function P(e,t,n){var r=e.charAt(0).toUpperCase()+e.slice(1),i=(e+" "+v.join(r+" ")+r).split(" ");return O(t,"string")||O(t,"undefined")?_(i,t):(i=(e+" "+m.join(r+" ")+r).split(" "),D(i,t,n))}function H(){i.input=function(n){for(var r=0,i=n.length;r<i;r++)w[n[r]]=n[r]in l;return w.list&&(w.list=!!t.createElement("datalist")&&!!e.HTMLDataListElement),w}("autocomplete autofocus list placeholder max min multiple pattern required step".split(" ")),i.inputtypes=function(e){for(var r=0,i,s,u,a=e.length;r<a;r++)l.setAttribute("type",s=e[r]),i=l.type!=="text",i&&(l.value=c,l.style.cssText="position:absolute;visibility:hidden;",/^range$/.test(s)&&l.style.WebkitAppearance!==n?(o.appendChild(l),u=t.defaultView,i=u.getComputedStyle&&u.getComputedStyle(l,null).WebkitAppearance!=="textfield"&&l.offsetHeight!==0,o.removeChild(l)):/^(search|tel)$/.test(s)||(/^(url|email)$/.test(s)?i=l.checkValidity&&l.checkValidity()===!1:i=l.value!=c)),b[e[r]]=!!i;return b}("search tel url email datetime date month week time datetime-local number range color".split(" "))}var r="2.8.3",i={},s=!0,o=t.documentElement,u="modernizr",a=t.createElement(u),f=a.style,l=t.createElement("input"),c=":)",h={}.toString,p=" -webkit- -moz- -o- -ms- ".split(" "),d="Webkit Moz O ms",v=d.split(" "),m=d.toLowerCase().split(" "),g={svg:"http://www.w3.org/2000/svg"},y={},b={},w={},E=[],S=E.slice,x,T=function(e,n,r,i){var s,a,f,l,c=t.createElement("div"),h=t.body,p=h||t.createElement("body");if(parseInt(r,10))while(r--)f=t.createElement("div"),f.id=i?i[r]:u+(r+1),c.appendChild(f);return s=["&#173;",\'<style id="s\',u,\'">\',e,"</style>"].join(""),c.id=u,(h?c:p).innerHTML+=s,p.appendChild(c),h||(p.style.background="",p.style.overflow="hidden",l=o.style.overflow,o.style.overflow="hidden",o.appendChild(p)),a=n(c,e),h?c.parentNode.removeChild(c):(p.parentNode.removeChild(p),o.style.overflow=l),!!a},N=function(t){var n=e.matchMedia||e.msMatchMedia;if(n)return n(t)&&n(t).matches||!1;var r;return T("@media "+t+" { #"+u+" { position: absolute; } }",function(t){r=(e.getComputedStyle?getComputedStyle(t,null):t.currentStyle)["position"]=="absolute"}),r},C={}.hasOwnProperty,k;!O(C,"undefined")&&!O(C.call,"undefined")?k=function(e,t){return C.call(e,t)}:k=function(e,t){return t in e&&O(e.constructor.prototype[t],"undefined")},Function.prototype.bind||(Function.prototype.bind=function(t){var n=this;if(typeof n!="function")throw new TypeError;var r=S.call(arguments,1),i=function(){if(this instanceof i){var e=function(){};e.prototype=n.prototype;var s=new e,o=n.apply(s,r.concat(S.call(arguments)));return Object(o)===o?o:s}return n.apply(t,r.concat(S.call(arguments)))};return i}),y.backgroundsize=function(){return P("backgroundSize")},y.borderimage=function(){return P("borderImage")},y.csstransitions=function(){return P("transition")},y.fontface=function(){var e;return T(\'@font-face {font-family:"font";src:url("https://")}\',function(n,r){var i=t.getElementById("smodernizr"),s=i.sheet||i.styleSheet,o=s?s.cssRules&&s.cssRules[0]?s.cssRules[0].cssText:s.cssText||"":"";e=/src/i.test(o)&&o.indexOf(r.split(" ")[0])===0}),e},y.svg=function(){return!!t.createElementNS&&!!t.createElementNS(g.svg,"svg").createSVGRect};for(var B in y)k(y,B)&&(x=B.toLowerCase(),i[x]=y[B](),E.push((i[x]?"":"no-")+x));return i.input||H(),i.addTest=function(e,t){if(typeof e=="object")for(var r in e)k(e,r)&&i.addTest(r,e[r]);else{e=e.toLowerCase();if(i[e]!==n)return i;t=typeof t=="function"?t():t,typeof s!="undefined"&&s&&(o.className+=" "+(t?"":"no-")+e),i[e]=t}return i},L(""),a=l=null,i._version=r,i._prefixes=p,i._domPrefixes=m,i._cssomPrefixes=v,i.mq=N,i.testProp=function(e){return _([e])},i.testAllProps=P,i.testStyles=T,o.className=o.className.replace(/(^|\\s)no-js(\\s|$)/,"$1$2")+(s?" js "+E.join(" "):""),i}(this,this.document),function(e,t,n){function r(e){return"[object Function]"==d.call(e)}function i(e){return"string"==typeof e}function s(){}function o(e){return!e||"loaded"==e||"complete"==e||"uninitialized"==e}function u(){var e=v.shift();m=1,e?e.t?h(function(){("c"==e.t?k.injectCss:k.injectJs)(e.s,0,e.a,e.x,e.e,1)},0):(e(),u()):m=0}function a(e,n,r,i,s,a,f){function l(t){if(!d&&o(c.readyState)&&(w.r=d=1,!m&&u(),c.onload=c.onreadystatechange=null,t)){"img"!=e&&h(function(){b.removeChild(c)},50);for(var r in T[n])T[n].hasOwnProperty(r)&&T[n][r].onload()}}var f=f||k.errorTimeout,c=t.createElement(e),d=0,g=0,w={t:r,s:n,e:s,a:a,x:f};1===T[n]&&(g=1,T[n]=[]),"object"==e?c.data=n:(c.src=n,c.type=e),c.width=c.height="0",c.onerror=c.onload=c.onreadystatechange=function(){l.call(this,g)},v.splice(i,0,w),"img"!=e&&(g||2===T[n]?(b.insertBefore(c,y?null:p),h(l,f)):T[n].push(c))}function f(e,t,n,r,s){return m=0,t=t||"j",i(e)?a("c"==t?E:w,e,t,this.i++,n,r,s):(v.splice(this.i++,0,e),1==v.length&&u()),this}function l(){var e=k;return e.loader={load:f,i:0},e}var c=t.documentElement,h=e.setTimeout,p=t.getElementsByTagName("script")[0],d={}.toString,v=[],m=0,g="MozAppearance"in c.style,y=g&&!!t.createRange().compareNode,b=y?c:p.parentNode,c=e.opera&&"[object Opera]"==d.call(e.opera),c=!!t.attachEvent&&!c,w=g?"object":c?"script":"img",E=c?"script":w,S=Array.isArray||function(e){return"[object Array]"==d.call(e)},x=[],T={},N={timeout:function(e,t){return t.length&&(e.timeout=t[0]),e}},C,k;k=function(e){function t(e){var e=e.split("!"),t=x.length,n=e.pop(),r=e.length,n={url:n,origUrl:n,prefixes:e},i,s,o;for(s=0;s<r;s++)o=e[s].split("="),(i=N[o.shift()])&&(n=i(n,o));for(s=0;s<t;s++)n=x[s](n);return n}function o(e,i,s,o,u){var a=t(e),f=a.autoCallback;a.url.split(".").pop().split("?").shift(),a.bypass||(i&&(i=r(i)?i:i[e]||i[o]||i[e.split("/").pop().split("?")[0]]),a.instead?a.instead(e,i,s,o,u):(T[a.url]?a.noexec=!0:T[a.url]=1,s.load(a.url,a.forceCSS||!a.forceJS&&"css"==a.url.split(".").pop().split("?").shift()?"c":n,a.noexec,a.attrs,a.timeout),(r(i)||r(f))&&s.load(function(){l(),i&&i(a.origUrl,u,o),f&&f(a.origUrl,u,o),T[a.url]=2})))}function u(e,t){function n(e,n){if(e){if(i(e))n||(f=function(){var e=[].slice.call(arguments);l.apply(this,e),c()}),o(e,f,t,0,u);else if(Object(e)===e)for(p in h=function(){var t=0,n;for(n in e)e.hasOwnProperty(n)&&t++;return t}(),e)e.hasOwnProperty(p)&&(!n&&!--h&&(r(f)?f=function(){var e=[].slice.call(arguments);l.apply(this,e),c()}:f[p]=function(e){return function(){var t=[].slice.call(arguments);e&&e.apply(this,t),c()}}(l[p])),o(e[p],f,t,p,u))}else!n&&c()}var u=!!e.test,a=e.load||e.both,f=e.callback||s,l=f,c=e.complete||s,h,p;n(u?e.yep:e.nope,!!a),a&&n(a)}var a,f,c=this.yepnope.loader;if(i(e))o(e,0,c,0);else if(S(e))for(a=0;a<e.length;a++)f=e[a],i(f)?o(f,0,c,0):S(f)?k(f):Object(f)===f&&u(f,c);else Object(e)===e&&u(e,c)},k.addPrefix=function(e,t){N[e]=t},k.addFilter=function(e){x.push(e)},k.errorTimeout=1e4,null==t.readyState&&t.addEventListener&&(t.readyState="loading",t.addEventListener("DOMContentLoaded",C=function(){t.removeEventListener("DOMContentLoaded",C,0),t.readyState="complete"},0)),e.yepnope=l(),e.yepnope.executeStack=u,e.yepnope.injectJs=function(e,n,r,i,a,f){var l=t.createElement("script"),c,d,i=i||k.errorTimeout;l.src=e;for(d in r)l.setAttribute(d,r[d]);n=f?u:n||s,l.onreadystatechange=l.onload=function(){!c&&o(l.readyState)&&(c=1,n(),l.onload=l.onreadystatechange=null)},h(function(){c||(c=1,n(1))},i),a?l.onload():p.parentNode.insertBefore(l,p)},e.yepnope.injectCss=function(e,n,r,i,o,a){var i=t.createElement("link"),f,n=a?u:n||s;i.href=e,i.rel="stylesheet",i.type="text/css";for(f in r)i.setAttribute(f,r[f]);o||(p.parentNode.insertBefore(i,p),h(n,0))}}(this,document),Modernizr.load=function(){yepnope.apply(window,[].slice.call(arguments,0))},Modernizr.addTest("details",function(){var e=document,t=e.createElement("details"),n,r,i;return"open"in t?(r=e.body||function(){var t=e.documentElement;return n=!0,t.insertBefore(e.createElement("body"),t.firstElementChild||t.firstChild)}(),t.innerHTML="<summary>a</summary>b",t.style.display="block",r.appendChild(t),i=t.offsetHeight,t.open=!0,i=i!=t.offsetHeight,r.removeChild(t),n&&r.parentNode.removeChild(r),i):!1}),Modernizr.addTest("progressbar",function(){return document.createElement("progress").max!==undefined}),Modernizr.addTest("meter",function(){return document.createElement("meter").max!==undefined}),Modernizr.addTest("mathml",function(){var e=!1;if(document.createElementNS){var t="http://www.w3.org/1998/Math/MathML",n=document.createElement("div");n.style.position="absolute";var r=n.appendChild(document.createElementNS(t,"math")).appendChild(document.createElementNS(t,"mfrac"));r.appendChild(document.createElementNS(t,"mi")).appendChild(document.createTextNode("xx")),r.appendChild(document.createElementNS(t,"mi")).appendChild(document.createTextNode("yy")),document.body.appendChild(n),e=n.offsetHeight>n.offsetWidth}return e}),Modernizr.addTest("cors",!!(window.XMLHttpRequest&&"withCredentials"in new XMLHttpRequest));\n/**\n * @title WET-BOEW Vapour loader\n * @overview Helper methods for WET\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author WET Community\n */\n/*\n * Vapour Object that will store tombstone data for plugins to leverage\n */\n( function( $, window, document, undef ) {\n"use strict";\n\n/**\n * @method getUrlParts\n * @param {String} url of URL to examine\n * @return {Object} of the parts of passed URL\n */\nvar getUrlParts = function( url ) {\n\t\tvar a = document.createElement( "a" );\n\t\ta.href = url;\n\t\treturn {\n\t\t\thref: a.href,\n\t\t\tabsolute: a.href,\n\t\t\thost: a.host,\n\t\t\thostname: a.hostname,\n\t\t\tport: a.port,\n\t\t\tpathname: a.pathname.replace( /^([^\\/])/, "/$1" ), // Prefix pathname with a slash in browsers that don\'t natively do it (i.e. all versions of IE and possibly early versions of Edge). See pull request #8110.\n\t\t\tprotocol: a.protocol,\n\t\t\thash: a.hash,\n\t\t\tsearch: a.search,\n\n\t\t\t// A collection of the parameters of the query string part of the URL.\n\t\t\tparams: ( function() {\n\t\t\t\tvar results = {},\n\t\t\t\t\tqueryString = encodeURI( decodeURI( a.search.replace( /^\\?/, "" ) ) ).replace( /\'/g, "%27" ).split( "&" ),\n\t\t\t\t\tlen = queryString.length,\n\t\t\t\t\tkey, strings, i;\n\n\t\t\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\t\t\tif ( ( key = queryString[ i ] ) !== null ) {\n\t\t\t\t\t\tstrings = key.split( "=" );\n\t\t\t\t\t\tresults[ strings[ 0 ] ] = strings[ 1 ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn results;\n\t\t\t}() )\n\t\t};\n\t},\n\n\t/**\n\t * @variable seed\n\t * @return a unique number for auto-generating ids\n\t */\n\tseed = 0,\n\n\t/**\n\t * @variable $src\n\t * @return {jQuery Element} of wb script element\n\t */\n\t$src = $( "script[src*=\'wet-boew.js\'],script[src*=\'wet-boew.min.js\'],script[data-wb-core]" )\n\t\t.last(),\n\n\t/**\n\t * @variable i18n\n\t * @return {string} of HTML document language\n\t */\n\tlang = document.documentElement.lang,\n\n\tpaths = ( function( ele ) {\n\t\tvar paths = {};\n\n\t\tpaths.home = ele.prop( "src" )\n\t\t\t\t.split( "?" )[ 0 ].split( "/" )\n\t\t\t\t.slice( 0, -1 )\n\t\t\t\t.join( "/" );\n\t\tpaths.asset = paths.home + "/../assets";\n\t\tpaths.template = paths.home + "/assets/templates";\n\t\tpaths.dep = paths.home + "/deps";\n\t\tpaths.js = paths.home;\n\t\tpaths.css = paths.home.substring( 0, paths.home.length - 2 ) + "css";\n\t\tpaths.mode = ele.prop( "src" ).indexOf( ".min" ) < 0 ? "" : ".min";\n\n\t\tif ( ele[ 0 ].hasAttribute( "data-wb-core" ) ) {\n\t\t\t$.extend( paths, {\n\t\t\t\thome: ele.attr( "data-home" ),\n\t\t\t\tasset: ele.attr( "data-asset" ),\n\t\t\t\ttemplate: ele.attr( "data-template" ),\n\t\t\t\tdep: ele.attr( "data-dep" ),\n\t\t\t\tjs: ele.attr( "data-js" ),\n\t\t\t\tcss: ele.attr( "data-css" ),\n\t\t\t\tmode: ele.attr( "data-mode" )\n\t\t\t} );\n\t\t}\n\n\t\treturn paths;\n\t}( $src ) ),\n\n\t/**\n\t * @variable oldie\n\t * @return {integer} of IE version\n\t */\n\toldie = ( function() {\n\t\tvar undef,\n\t\t\tv = 3,\n\t\t\tdiv = document.createElement( "div" ),\n\t\t\tall = div.getElementsByTagName( "i" );\n\n\t\twhile ( (\n\t\t\tdiv.innerHTML = "\x3c!--[if gt IE " + ( v += 1 ) + "]><i></i><![endif]--\x3e",\n\t\t\tall[ 0 ]\n\t\t) ) {};\n\n\t\treturn v > 4 ? v : undef;\n\t}() ),\n\n\t/**\n\t * @variable currentpage\n\t * @return {Object} of parts of the current page URL\n\t */\n\tcurrentpage = getUrlParts( window.location.href ),\n\n\t/**\n\t * @variable disabled\n\t * @return {boolean} of state of disabled flag\n\t */\n\tdisabled = ( function() {\n\t\tvar disabledSaved = "false",\n\t\t\tdisabled;\n\n\t\ttry {\n\t\t\tdisabledSaved = localStorage.getItem( "wbdisable" ) || disabledSaved;\n\t\t} catch ( e ) {}\n\n\t\tdisabled = currentpage.params.wbdisable || disabledSaved;\n\t\treturn ( typeof disabled === "string" ) ? ( disabled.toLowerCase() === "true" ) : Boolean( disabled );\n\t}() ),\n\n\t/*-----------------------------\n\t * Core Library Object\n\t *-----------------------------\n\t */\n\twb = {\n\t\t"/": paths.home,\n\t\t"/assets": paths.asset,\n\t\t"/templates": paths.template,\n\t\t"/deps": paths.dep,\n\t\tlang: lang,\n\t\tmode: paths.mode,\n\t\tdoc: $( document ),\n\t\twin: $( window ),\n\t\thtml: $( "html" ),\n\t\tpageUrlParts: currentpage,\n\t\tgetUrlParts: getUrlParts,\n\t\tisDisabled: disabled,\n\t\tisStarted: false,\n\t\tisReady: false,\n\t\tignoreHashChange: false,\n\t\tinitQueue: 0,\n\n\t\tgetPath: function( property ) {\n\t\t\treturn this.hasOwnProperty( property ) ? this[ property ] : undef;\n\t\t},\n\n\t\tgetMode: function() {\n\t\t\treturn this.mode;\n\t\t},\n\n\t\tgetId: function() {\n\t\t\treturn "wb-auto-" + ( seed += 1 );\n\t\t},\n\n\t\tinit: function( event, componentName, selector, noAutoId ) {\n\t\t\tvar\teventTarget = event.target,\n\t\t\t\tisEvent = !!eventTarget,\n\t\t\t\tnode = isEvent ? eventTarget : event,\n\t\t\t\tinitedClass = componentName + "-inited",\n\t\t\t\tisDocumentNode = node === document;\n\n\t\t\t// Filter out any events triggered by descendants and only initializes\n\t\t\t// the element once (if is an event and document node is not the target)\n\t\t\tif ( !isEvent || isDocumentNode || ( event.currentTarget === node &&\n\t\t\t\tnode.className.indexOf( initedClass ) === -1 ) ) {\n\n\t\t\t\tthis.initQueue += 1;\n\t\t\t\tthis.remove( selector );\n\t\t\t\tif ( !isDocumentNode ) {\n\t\t\t\t\tnode.className += " " + initedClass;\n\n\t\t\t\t\tif ( !noAutoId && !node.id ) {\n\t\t\t\t\t\tnode.id = wb.getId();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn node;\n\t\t\t}\n\n\t\t\treturn undef;\n\t\t},\n\n\t\tready: function( $elm, componentName, context ) {\n\t\t\tif ( $elm ) {\n\n\t\t\t\t// Trigger any nested elements (excluding nested within nested)\n\t\t\t\t$elm\n\t\t\t\t\t.find( wb.allSelectors )\n\t\t\t\t\t\t.addClass( "wb-init" )\n\t\t\t\t\t\t.filter( ":not(#" + $elm.attr( "id" ) + " .wb-init .wb-init)" )\n\t\t\t\t\t\t\t.trigger( "timerpoke.wb" );\n\n\t\t\t\t// Identify that the component is ready\n\t\t\t\t$elm.trigger( "wb-ready." + componentName, context );\n\t\t\t\tthis.initQueue -= 1;\n\t\t\t} else {\n\t\t\t\tthis.doc.trigger( "wb-ready." + componentName, context );\n\t\t\t}\n\n\t\t\t// Identify that global initialization is complete\n\t\t\tif ( !this.isReady && this.isStarted && this.initQueue < 1 ) {\n\t\t\t\tthis.isReady = true;\n\t\t\t\tthis.doc.trigger( "wb-ready.wb" );\n\t\t\t}\n\t\t},\n\n\t\t// Lets load some variables into wb for IE detection\n\t\tother: !oldie,\n\t\tdesktop: ( window.orientation === undefined ),\n\t\tie: !!oldie,\n\t\tie6: ( oldie === 6 ),\n\t\tie7: ( oldie === 7 ),\n\t\tie8: ( oldie === 8 ),\n\t\tie9: ( oldie === 9 ),\n\t\tielt7: ( oldie < 7 ),\n\t\tielt8: ( oldie < 8 ),\n\t\tielt9: ( oldie < 9 ),\n\t\tielt10: ( oldie < 10 ),\n\t\tie11: ( !!navigator.userAgent.match( /Trident\\/7\\./ ) ),\n\n\t\tselectors: [],\n\n\t\tresizeEvents: "xxsmallview.wb xsmallview.wb smallview.wb mediumview.wb largeview.wb xlargeview.wb",\n\n\t\t// For Charts and Geomap\n\t\tdrawColours: [\n\t\t\t"#8d201c",\n\t\t\t"#EE8310",\n\t\t\t"#2a7da6",\n\t\t\t"#5a306b",\n\t\t\t"#285228",\n\t\t\t"#154055",\n\t\t\t"#555555",\n\t\t\t"#f6d200",\n\t\t\t"#d73d38",\n\t\t\t"#418541",\n\t\t\t"#87aec9",\n\t\t\t"#23447e",\n\t\t\t"#999999"\n\t\t],\n\n\t\t// Get and generate a unique session id\n\t\tsessionGUID: function() {\n\t\t\tvar sessionId = sessionStorage.getItem( "wb-session-GUID" );\n\t\t\tif ( !sessionId ) {\n\t\t\t\tsessionId = wb.guid();\n\t\t\t\tsessionStorage.setItem( "wb-session-GUID", sessionId );\n\t\t\t}\n\t\t\treturn sessionId;\n\t\t},\n\n\t\t// Add a selector to be targeted by timerpoke\n\t\tadd: function( selector ) {\n\t\t\tvar exists = false,\n\t\t\t\tlen = wb.selectors.length,\n\t\t\t\ti;\n\n\t\t\t// Lets ensure we are not running if things are disabled\n\t\t\tif ( wb.isDisabled && selector !== "#wb-tphp" ) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t// Check to see if the selector is already targeted\n\t\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\t\tif ( wb.selectors[ i ] === selector ) {\n\t\t\t\t\texists = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add the selector if it isn\'t already targeted\n\t\t\tif ( !exists ) {\n\t\t\t\twb.selectors.push( selector );\n\t\t\t}\n\t\t},\n\n\t\t// Remove a selector targeted by timerpoke\n\t\tremove: function( selector ) {\n\t\t\tvar len = this.selectors.length,\n\t\t\t\ti;\n\n\t\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\t\tif ( this.selectors[ i ] === selector ) {\n\t\t\t\t\tthis.selectors.splice( i, 1 );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Handles triggering of timerpoke events\n\t\ttimerpoke: function( initial ) {\n\t\t\tvar selectorsLocal = wb.selectors.slice( 0 ),\n\t\t\t\tlen = selectorsLocal.length,\n\t\t\t\tselector, $elms, $foundElms, i;\n\n\t\t\tif ( initial ) {\n\t\t\t\t$foundElms = $();\n\t\t\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\t\t\tselector = selectorsLocal[ i ];\n\t\t\t\t\t$elms = $( selector );\n\t\t\t\t\tif ( $elms.length !== 0 ) {\n\t\t\t\t\t\t$foundElms = $foundElms.add( $elms );\n\n\t\t\t\t\t// If the selector returns no elements, remove the selector\n\t\t\t\t\t} else {\n\t\t\t\t\t\twb.remove( selector );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Keep only the non-nested plugin/polyfill elements\n\t\t\t\t$elms = $foundElms.filter( ":not(.wb-init .wb-init)" ).addClass( "wb-init" );\n\t\t\t} else {\n\t\t\t\t$elms = $( selectorsLocal.join( ", " ) );\n\t\t\t}\n\t\t\t$elms.trigger( "timerpoke.wb" );\n\t\t},\n\n\t\tstart: function() {\n\n\t\t\t// Save a copy of all the possible selectors\n\t\t\twb.allSelectors = wb.selectors.join( ", " );\n\n\t\t\t// Initiate timerpoke events right way\n\t\t\twb.timerpoke( true );\n\t\t\tthis.isStarted = true;\n\t\t\tthis.ready();\n\n\t\t\t// Initiate timerpoke events again every half second\n\t\t\tsetInterval( wb.timerpoke, 500 );\n\t\t},\n\n\t\ti18nDict: {},\n\t\ti18n: function( key, state, mixin ) {\n\t\t\tvar dictionary = wb.i18nDict,\n\n\t\t\t\t// eg. 000 or 001 ie. 0 or 1\n\t\t\t\ttruthiness = ( typeof key === "string" && key !== "" ) |\n\n\t\t\t\t\t// eg. 000 or 010 ie. 0 or 2\n\t\t\t\t\t( typeof state === "string" && state !== "" ) << 1 |\n\n\t\t\t\t\t// eg. 000 or 100 ie. 0 or 4\n\t\t\t\t\t( typeof mixin === "string" && mixin !== "" ) << 2;\n\n\t\t\tswitch ( truthiness ) {\n\t\t\tcase 1:\n\n\t\t\t\t// only key was provided\n\t\t\t\treturn dictionary[ key ];\n\n\t\t\tcase 3:\n\n\t\t\t\t// key and state were provided\n\t\t\t\treturn dictionary[ key ][ state ];\n\n\t\t\tcase 7:\n\n\t\t\t\t// key, state, and mixin were provided\n\t\t\t\treturn dictionary[ key ][ state ].replace( "[MIXIN]", mixin );\n\t\t\tdefault:\n\t\t\t\treturn "";\n\t\t\t}\n\t\t},\n\n\t\thashString: function( str ) {\n\n\t\t\t// Sources:\n\t\t\t//\thttp://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/\n\t\t\t//\thttp://jsperf.com/hashing-strings\n\t\t\tvar hash = 0,\n\t\t\t\tchr, i;\n\n\t\t\tif ( str.length === 0 ) {\n\t\t\t\treturn hash;\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < str.length; i++ ) {\n\t\t\t\tchr = str.charCodeAt( i );\n\t\t\t\thash = ( ( hash << 5 ) - hash ) + chr;\n\n\t\t\t\t// Convert to 32bit integer\n\t\t\t\thash = hash & hash;\n\t\t\t}\n\n\t\t\treturn hash;\n\t\t},\n\n\t\tstripWhitespace: function( str ) {\n\t\t\treturn str.replace( /\\s+/g, "" );\n\t\t},\n\n\t\t// Core function to deal with the dependency racing issue\n\t\twhenLibReady: function( testCallback, readyCallback ) {\n\t\t\tif ( testCallback() ) {\n\t\t\t\treadyCallback();\n\t\t\t} else {\n\t\t\t\tsetTimeout( function() {\n\t\t\t\t\twb.whenLibReady( testCallback, readyCallback );\n\t\t\t\t}, 50 );\n\t\t\t}\n\n\t\t}\n\t};\n\nwindow.wb = wb;\n\n/*-----------------------------\n * Yepnope Prefixes\n *-----------------------------*/\n/*\n * Establish the base path to be more flexible in terms of WCMS where JS can\n * reside in theme folders and not in the root of sites\n * @TODO: For modularity the prefixes where written independently as we are\n * flushing out some use cases on better grouping and optimization of polyfills.\n * Once this more hashed out, we could optimize the prefixes down to one or two\n * prefixes "site" and "disabled" to thin out the codeblock a bit more\n * increase performance due to redundant chaining of the prefixes.\n */\n\n/**\n * @prefix: site! - adds the root js directory of yepnope resources\n */\nyepnope.addPrefix( "site", function( resourceObj ) {\n\tresourceObj.url = paths.js + "/" + resourceObj.url;\n\treturn resourceObj;\n} );\n\n/**\n * @prefix: plyfll! - builds the path for the polyfill resource\n */\nyepnope.addPrefix( "plyfll", function( resourceObj ) {\n\tvar path,\n\t\turl = resourceObj.url;\n\n\tif ( disabled && url.indexOf( "svg" ) === -1 ) {\n\t\tresourceObj.bypass = true;\n\t} else if ( !paths.mode ) {\n\t\turl = url.replace( ".min", "" );\n\t}\n\n\tif ( url.indexOf( ".css" ) !== -1 ) {\n\t\tresourceObj.forceCSS = true;\n\t\tpath = paths.css;\n\t} else {\n\t\tpath = paths.js;\n\t}\n\tresourceObj.url = path + "/polyfills/" + url;\n\n\treturn resourceObj;\n} );\n\n/**\n * @prefix: i18n! - adds the correct document language for our i18n library\n */\nyepnope.addPrefix( "i18n", function( resourceObj ) {\n\tresourceObj.url = paths.js + "/" + resourceObj.url + lang + paths.mode + ".js";\n\treturn resourceObj;\n} );\n\n/**\n * @prefix: mthjx! - adds the root directory of MathJax resources\n */\nyepnope.addPrefix( "mthjx", function( resourceObj ) {\n\tresourceObj.url = paths.js + "/MathJax/" + resourceObj.url;\n\treturn resourceObj;\n} );\n\n/*-----------------------------\n * Deps loading, call "complete" callback when the deps is ready if a testReady is defined\n *-----------------------------*/\nwb.modernizrLoad = Modernizr.load;\nModernizr.load = function( options ) {\n\tvar i, i_len, i_cache,\n\t\ttestReady, complete;\n\tif ( !$.isArray( options ) ) {\n\t\toptions = [ options ];\n\t}\n\ti_len = options.length;\n\tfor ( i = 0; i !== i_len; i += 1 ) {\n\t\ti_cache = options[ i ];\n\t\ttestReady = i_cache.testReady;\n\t\tcomplete = i_cache.complete;\n\t\tif ( testReady && complete ) {\n\t\t\ti_cache.complete = wb.whenLibReady( testReady, complete );\n\t\t}\n\t}\n\twb.modernizrLoad( options );\n};\n\n/*-----------------------------\n * Modernizr Polyfill Loading\n *-----------------------------*/\nModernizr.load( [\n\t{\n\t\ttest: Modernizr.details,\n\t\tnope: [\n\t\t\t"plyfll!details.min.js",\n\t\t\t"plyfll!details.min.css"\n\t\t]\n\t}, {\n\t\ttest: Modernizr.input.list,\n\t\tnope: [\n\t\t\t"plyfll!datalist.min.js",\n\t\t\t"plyfll!datalist.min.css"\n\t\t]\n\t}, {\n\t\ttest: Modernizr.inputtypes.date,\n\t\tnope: [\n\t\t\t"plyfll!datepicker.min.js",\n\t\t\t"plyfll!datepicker.min.css"\n\t\t]\n\t}, {\n\t\ttest: Modernizr.inputtypes.range,\n\t\tnope: [\n\t\t\t"plyfll!slider.min.js",\n\t\t\t"plyfll!slider_wrapper.min.js",\n\t\t\t"plyfll!slider.min.css"\n\t\t],\n\t\tcallback: function( url ) {\n\t\t\tif ( url === "slider.min.js" ) {\n\t\t\t\twindow.fdSlider.onDomReady();\n\t\t\t}\n\t\t}\n\t}, {\n\t\ttest: Modernizr.progressbar,\n\t\tnope: [\n\t\t\t"plyfll!progress.min.js",\n\t\t\t"plyfll!progress.min.css"\n\t\t]\n\t}, {\n\t\ttest: Modernizr.mathml,\n\n\t\t// Cleanup Modernizr test and add selector to global timer\n\t\tcomplete: function() {\n\t\t\tvar\tcomponentName = "wb-math",\n\t\t\t\tselector = "math",\n\t\t\t\tmath = document.getElementsByTagName( selector ),\n\t\t\t\t$document = wb.doc;\n\n\t\t\t// Cleanup elements that Modernizr.mathml test leaves behind.\n\t\t\tif ( math.length ) {\n\t\t\t\tdocument.body.removeChild( math[ math.length - 1 ].parentNode );\n\t\t\t}\n\n\t\t\t// Defer loading the polyfill till an element is detected due to the size\n\t\t\tif ( !Modernizr.mathml ) {\n\n\t\t\t\t// Bind the init event of the plugin\n\t\t\t\t$document.one( "timerpoke.wb wb-init." + componentName, selector, function() {\n\n\t\t\t\t\t// Start initialization\n\t\t\t\t\twb.init( document, componentName, selector );\n\n\t\t\t\t\t// Load the MathML dependency. Since the polyfill is only loaded\n\t\t\t\t\t// when !Modernizr.mathml, we can skip the test here.\n\t\t\t\t\tModernizr.load( [ {\n\t\t\t\t\t\tload: "timeout=500!https://cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=Accessible",\n\t\t\t\t\t\tcomplete: function() {\n\t\t\t\t\t\t\tModernizr.load( [ {\n\t\t\t\t\t\t\t\ttest: window.MathJax === undefined,\n\t\t\t\t\t\t\t\tyep: "mthjx!MathJax.js?config=Accessible"\n\t\t\t\t\t\t\t} ] );\n\n\t\t\t\t\t\t\t// Identify that initialization has completed\n\t\t\t\t\t\t\twb.ready( $document, componentName );\n\t\t\t\t\t\t}\n\t\t\t\t\t} ] );\n\t\t\t\t} );\n\n\t\t\t\twb.add( selector );\n\t\t\t}\n\t\t}\n\t}, {\n\t\ttest: Modernizr.meter,\n\t\tnope: [\n\t\t\t"plyfll!meter.min.js",\n\t\t\t"plyfll!meter.min.css"\n\t\t]\n\t}, {\n\t\ttest: Modernizr.touch,\n\t\tyep: "plyfll!mobile.min.js"\n\t}, {\n\t\ttest: Modernizr.svg,\n\t\tnope: "plyfll!svg.min.js"\n\t}, {\n\t\tload: "i18n!i18n/",\n\t\ttestReady: function() {\n\t\t\treturn wb.i18nDict.tphp;\n\t\t},\n\t\tcomplete: function() {\n\t\t\twb.start();\n\t\t}\n\t}\n] );\n\n} )( jQuery, window, document );\n\n/**\n * @title WET-BOEW JQuery Helper Methods\n * @overview Helper methods for WET\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author WET Community\n * Credits: http://kaibun.net/blog/2013/04/19/a-fully-fledged-coffeescript-boilerplate-for-jquery-plugins/\n */\n( function( $, wb ) {\n\nwb.getData = function( element, dataName ) {\n\tvar elm = !element.jquery ? element : element[ 0 ],\n\t\tdataAttr = elm.getAttribute( "data-" + dataName ),\n\t\tdataObj;\n\n\tif ( dataAttr ) {\n\t\ttry {\n\t\t\tdataObj = JSON.parse( dataAttr );\n\t\t\t$.data( elm, dataName, dataObj );\n\t\t} catch ( error ) {\n\t\t\t$.error( "Bad JSON array in data-" + dataName + " attribute" );\n\t\t}\n\t}\n\n\treturn dataObj;\n};\n\n} )( jQuery, wb );\n\n( function( wb ) {\n\n"use strict";\n\n// Escapes the characters in a string for use in a jQuery selector\n// Based on http://totaldev.com/content/escaping-characters-get-valid-jquery-id\nwb.jqEscape = function( selector ) {\n\treturn selector.replace( /([;&,\\.\\+\\*\\~\':"\\\\\\!\\^\\/#$%@\\[\\]\\(\\)=>\\|])/g, "\\\\$1" );\n};\n\n// RegEx used by formattedNumCompare\nwb.formattedNumCompareRegEx = /(<[^>]*>|[^\\d\\.])/g;\n\n// Compares two formatted numbers (e.g., 1.2.12 or 1,000,345)\nwb.formattedNumCompare = function( a, b ) {\n\tvar regEx = wb.formattedNumCompareRegEx,\n\t\taMultiple = a.indexOf( "-" ) === -1 ? 1 : -1,\n\t\taNumbers = ( ( a === "-" || a === "" ) ? "0" : a.replace( regEx, "" ) ).split( "." ),\n\t\tbMultiple = b.indexOf( "-" ) === -1 ? 1 : -1,\n\t\tbNumbers = ( ( b === "-" || b === "" ) ? "0" : b.replace( regEx, "" ) ).split( "." ),\n\t\tlen = aNumbers.length,\n\t\ti, result;\n\n\tfor ( i = 0; i !== len; i += 1 ) {\n\t\tresult = parseInt( aNumbers[ i ], 10 ) * aMultiple - parseInt( bNumbers[ i ], 10 ) * bMultiple;\n\t\tif ( result !== 0 ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n};\n\n// Compare two strings with special characters (e.g., Cyrillic or Chinese characters)\nwb.i18nTextCompare = function( a, b ) {\n\treturn wb.normalizeDiacritics( a ).localeCompare( wb.normalizeDiacritics( b ) );\n};\n\n// Based upon https://gist.github.com/instanceofme/1731620\n// Licensed under WTFPL v2 http://sam.zoy.org/wtfpl/COPYING\nwb.normalizeDiacritics = function( str ) {\n\tvar diacritics = {\n\t\t\t"\\u24B6": "A",\n\t\t\t"\\uFF21": "A",\n\t\t\t"\\u00C0": "A",\n\t\t\t"\\u00C1": "A",\n\t\t\t"\\u00C2": "A",\n\t\t\t"\\u1EA6": "A",\n\t\t\t"\\u1EA4": "A",\n\t\t\t"\\u1EAA": "A",\n\t\t\t"\\u1EA8": "A",\n\t\t\t"\\u00C3": "A",\n\t\t\t"\\u0100": "A",\n\t\t\t"\\u0102": "A",\n\t\t\t"\\u1EB0": "A",\n\t\t\t"\\u1EAE": "A",\n\t\t\t"\\u1EB4": "A",\n\t\t\t"\\u1EB2": "A",\n\t\t\t"\\u0226": "A",\n\t\t\t"\\u01E0": "A",\n\t\t\t"\\u00C4": "A",\n\t\t\t"\\u01DE": "A",\n\t\t\t"\\u1EA2": "A",\n\t\t\t"\\u00C5": "A",\n\t\t\t"\\u01FA": "A",\n\t\t\t"\\u01CD": "A",\n\t\t\t"\\u0200": "A",\n\t\t\t"\\u0202": "A",\n\t\t\t"\\u1EA0": "A",\n\t\t\t"\\u1EAC": "A",\n\t\t\t"\\u1EB6": "A",\n\t\t\t"\\u1E00": "A",\n\t\t\t"\\u0104": "A",\n\t\t\t"\\u023A": "A",\n\t\t\t"\\u2C6F": "A",\n\t\t\t"\\uA732": "AA",\n\t\t\t"\\u00C6": "AE",\n\t\t\t"\\u01FC": "AE",\n\t\t\t"\\u01E2": "AE",\n\t\t\t"\\uA734": "AO",\n\t\t\t"\\uA736": "AU",\n\t\t\t"\\uA738": "AV",\n\t\t\t"\\uA73A": "AV",\n\t\t\t"\\uA73C": "AY",\n\t\t\t"\\u24B7": "B",\n\t\t\t"\\uFF22": "B",\n\t\t\t"\\u1E02": "B",\n\t\t\t"\\u1E04": "B",\n\t\t\t"\\u1E06": "B",\n\t\t\t"\\u0243": "B",\n\t\t\t"\\u0182": "B",\n\t\t\t"\\u0181": "B",\n\t\t\t"\\u24B8": "C",\n\t\t\t"\\uFF23": "C",\n\t\t\t"\\u0106": "C",\n\t\t\t"\\u0108": "C",\n\t\t\t"\\u010A": "C",\n\t\t\t"\\u010C": "C",\n\t\t\t"\\u00C7": "C",\n\t\t\t"\\u1E08": "C",\n\t\t\t"\\u0187": "C",\n\t\t\t"\\u023B": "C",\n\t\t\t"\\uA73E": "C",\n\t\t\t"\\u24B9": "D",\n\t\t\t"\\uFF24": "D",\n\t\t\t"\\u1E0A": "D",\n\t\t\t"\\u010E": "D",\n\t\t\t"\\u1E0C": "D",\n\t\t\t"\\u1E10": "D",\n\t\t\t"\\u1E12": "D",\n\t\t\t"\\u1E0E": "D",\n\t\t\t"\\u0110": "D",\n\t\t\t"\\u018B": "D",\n\t\t\t"\\u018A": "D",\n\t\t\t"\\u0189": "D",\n\t\t\t"\\uA779": "D",\n\t\t\t"\\u01F1": "DZ",\n\t\t\t"\\u01C4": "DZ",\n\t\t\t"\\u01F2": "Dz",\n\t\t\t"\\u01C5": "Dz",\n\t\t\t"\\u24BA": "E",\n\t\t\t"\\uFF25": "E",\n\t\t\t"\\u00C8": "E",\n\t\t\t"\\u00C9": "E",\n\t\t\t"\\u00CA": "E",\n\t\t\t"\\u1EC0": "E",\n\t\t\t"\\u1EBE": "E",\n\t\t\t"\\u1EC4": "E",\n\t\t\t"\\u1EC2": "E",\n\t\t\t"\\u1EBC": "E",\n\t\t\t"\\u0112": "E",\n\t\t\t"\\u1E14": "E",\n\t\t\t"\\u1E16": "E",\n\t\t\t"\\u0114": "E",\n\t\t\t"\\u0116": "E",\n\t\t\t"\\u00CB": "E",\n\t\t\t"\\u1EBA": "E",\n\t\t\t"\\u011A": "E",\n\t\t\t"\\u0204": "E",\n\t\t\t"\\u0206": "E",\n\t\t\t"\\u1EB8": "E",\n\t\t\t"\\u1EC6": "E",\n\t\t\t"\\u0228": "E",\n\t\t\t"\\u1E1C": "E",\n\t\t\t"\\u0118": "E",\n\t\t\t"\\u1E18": "E",\n\t\t\t"\\u1E1A": "E",\n\t\t\t"\\u0190": "E",\n\t\t\t"\\u018E": "E",\n\t\t\t"\\u24BB": "F",\n\t\t\t"\\uFF26": "F",\n\t\t\t"\\u1E1E": "F",\n\t\t\t"\\u0191": "F",\n\t\t\t"\\uA77B": "F",\n\t\t\t"\\u24BC": "G",\n\t\t\t"\\uFF27": "G",\n\t\t\t"\\u01F4": "G",\n\t\t\t"\\u011C": "G",\n\t\t\t"\\u1E20": "G",\n\t\t\t"\\u011E": "G",\n\t\t\t"\\u0120": "G",\n\t\t\t"\\u01E6": "G",\n\t\t\t"\\u0122": "G",\n\t\t\t"\\u01E4": "G",\n\t\t\t"\\u0193": "G",\n\t\t\t"\\uA7A0": "G",\n\t\t\t"\\uA77D": "G",\n\t\t\t"\\uA77E": "G",\n\t\t\t"\\u24BD": "H",\n\t\t\t"\\uFF28": "H",\n\t\t\t"\\u0124": "H",\n\t\t\t"\\u1E22": "H",\n\t\t\t"\\u1E26": "H",\n\t\t\t"\\u021E": "H",\n\t\t\t"\\u1E24": "H",\n\t\t\t"\\u1E28": "H",\n\t\t\t"\\u1E2A": "H",\n\t\t\t"\\u0126": "H",\n\t\t\t"\\u2C67": "H",\n\t\t\t"\\u2C75": "H",\n\t\t\t"\\uA78D": "H",\n\t\t\t"\\u24BE": "I",\n\t\t\t"\\uFF29": "I",\n\t\t\t"\\u00CC": "I",\n\t\t\t"\\u00CD": "I",\n\t\t\t"\\u00CE": "I",\n\t\t\t"\\u0128": "I",\n\t\t\t"\\u012A": "I",\n\t\t\t"\\u012C": "I",\n\t\t\t"\\u0130": "I",\n\t\t\t"\\u00CF": "I",\n\t\t\t"\\u1E2E": "I",\n\t\t\t"\\u1EC8": "I",\n\t\t\t"\\u01CF": "I",\n\t\t\t"\\u0208": "I",\n\t\t\t"\\u020A": "I",\n\t\t\t"\\u1ECA": "I",\n\t\t\t"\\u012E": "I",\n\t\t\t"\\u1E2C": "I",\n\t\t\t"\\u0197": "I",\n\t\t\t"\\u24BF": "J",\n\t\t\t"\\uFF2A": "J",\n\t\t\t"\\u0134": "J",\n\t\t\t"\\u0248": "J",\n\t\t\t"\\u24C0": "K",\n\t\t\t"\\uFF2B": "K",\n\t\t\t"\\u1E30": "K",\n\t\t\t"\\u01E8": "K",\n\t\t\t"\\u1E32": "K",\n\t\t\t"\\u0136": "K",\n\t\t\t"\\u1E34": "K",\n\t\t\t"\\u0198": "K",\n\t\t\t"\\u2C69": "K",\n\t\t\t"\\uA740": "K",\n\t\t\t"\\uA742": "K",\n\t\t\t"\\uA744": "K",\n\t\t\t"\\uA7A2": "K",\n\t\t\t"\\u24C1": "L",\n\t\t\t"\\uFF2C": "L",\n\t\t\t"\\u013F": "L",\n\t\t\t"\\u0139": "L",\n\t\t\t"\\u013D": "L",\n\t\t\t"\\u1E36": "L",\n\t\t\t"\\u1E38": "L",\n\t\t\t"\\u013B": "L",\n\t\t\t"\\u1E3C": "L",\n\t\t\t"\\u1E3A": "L",\n\t\t\t"\\u0141": "L",\n\t\t\t"\\u023D": "L",\n\t\t\t"\\u2C62": "L",\n\t\t\t"\\u2C60": "L",\n\t\t\t"\\uA748": "L",\n\t\t\t"\\uA746": "L",\n\t\t\t"\\uA780": "L",\n\t\t\t"\\u01C7": "LJ",\n\t\t\t"\\u01C8": "Lj",\n\t\t\t"\\u24C2": "M",\n\t\t\t"\\uFF2D": "M",\n\t\t\t"\\u1E3E": "M",\n\t\t\t"\\u1E40": "M",\n\t\t\t"\\u1E42": "M",\n\t\t\t"\\u2C6E": "M",\n\t\t\t"\\u019C": "M",\n\t\t\t"\\u24C3": "N",\n\t\t\t"\\uFF2E": "N",\n\t\t\t"\\u01F8": "N",\n\t\t\t"\\u0143": "N",\n\t\t\t"\\u00D1": "N",\n\t\t\t"\\u1E44": "N",\n\t\t\t"\\u0147": "N",\n\t\t\t"\\u1E46": "N",\n\t\t\t"\\u0145": "N",\n\t\t\t"\\u1E4A": "N",\n\t\t\t"\\u1E48": "N",\n\t\t\t"\\u0220": "N",\n\t\t\t"\\u019D": "N",\n\t\t\t"\\uA790": "N",\n\t\t\t"\\uA7A4": "N",\n\t\t\t"\\u01CA": "NJ",\n\t\t\t"\\u01CB": "Nj",\n\t\t\t"\\u24C4": "O",\n\t\t\t"\\uFF2F": "O",\n\t\t\t"\\u00D2": "O",\n\t\t\t"\\u00D3": "O",\n\t\t\t"\\u00D4": "O",\n\t\t\t"\\u1ED2": "O",\n\t\t\t"\\u1ED0": "O",\n\t\t\t"\\u1ED6": "O",\n\t\t\t"\\u1ED4": "O",\n\t\t\t"\\u00D5": "O",\n\t\t\t"\\u1E4C": "O",\n\t\t\t"\\u022C": "O",\n\t\t\t"\\u1E4E": "O",\n\t\t\t"\\u014C": "O",\n\t\t\t"\\u1E50": "O",\n\t\t\t"\\u1E52": "O",\n\t\t\t"\\u014E": "O",\n\t\t\t"\\u022E": "O",\n\t\t\t"\\u0230": "O",\n\t\t\t"\\u00D6": "O",\n\t\t\t"\\u022A": "O",\n\t\t\t"\\u1ECE": "O",\n\t\t\t"\\u0150": "O",\n\t\t\t"\\u01D1": "O",\n\t\t\t"\\u020C": "O",\n\t\t\t"\\u020E": "O",\n\t\t\t"\\u01A0": "O",\n\t\t\t"\\u1EDC": "O",\n\t\t\t"\\u1EDA": "O",\n\t\t\t"\\u1EE0": "O",\n\t\t\t"\\u1EDE": "O",\n\t\t\t"\\u1EE2": "O",\n\t\t\t"\\u1ECC": "O",\n\t\t\t"\\u1ED8": "O",\n\t\t\t"\\u01EA": "O",\n\t\t\t"\\u01EC": "O",\n\t\t\t"\\u00D8": "O",\n\t\t\t"\\u01FE": "O",\n\t\t\t"\\u0186": "O",\n\t\t\t"\\u019F": "O",\n\t\t\t"\\uA74A": "O",\n\t\t\t"\\uA74C": "O",\n\t\t\t"\\u0152": "OE",\n\t\t\t"\\u01A2": "OI",\n\t\t\t"\\uA74E": "OO",\n\t\t\t"\\u0222": "OU",\n\t\t\t"\\u24C5": "P",\n\t\t\t"\\uFF30": "P",\n\t\t\t"\\u1E54": "P",\n\t\t\t"\\u1E56": "P",\n\t\t\t"\\u01A4": "P",\n\t\t\t"\\u2C63": "P",\n\t\t\t"\\uA750": "P",\n\t\t\t"\\uA752": "P",\n\t\t\t"\\uA754": "P",\n\t\t\t"\\u24C6": "Q",\n\t\t\t"\\uFF31": "Q",\n\t\t\t"\\uA756": "Q",\n\t\t\t"\\uA758": "Q",\n\t\t\t"\\u024A": "Q",\n\t\t\t"\\u24C7": "R",\n\t\t\t"\\uFF32": "R",\n\t\t\t"\\u0154": "R",\n\t\t\t"\\u1E58": "R",\n\t\t\t"\\u0158": "R",\n\t\t\t"\\u0210": "R",\n\t\t\t"\\u0212": "R",\n\t\t\t"\\u1E5A": "R",\n\t\t\t"\\u1E5C": "R",\n\t\t\t"\\u0156": "R",\n\t\t\t"\\u1E5E": "R",\n\t\t\t"\\u024C": "R",\n\t\t\t"\\u2C64": "R",\n\t\t\t"\\uA75A": "R",\n\t\t\t"\\uA7A6": "R",\n\t\t\t"\\uA782": "R",\n\t\t\t"\\u24C8": "S",\n\t\t\t"\\uFF33": "S",\n\t\t\t"\\u015A": "S",\n\t\t\t"\\u1E64": "S",\n\t\t\t"\\u015C": "S",\n\t\t\t"\\u1E60": "S",\n\t\t\t"\\u0160": "S",\n\t\t\t"\\u1E66": "S",\n\t\t\t"\\u1E62": "S",\n\t\t\t"\\u1E68": "S",\n\t\t\t"\\u0218": "S",\n\t\t\t"\\u015E": "S",\n\t\t\t"\\u2C7E": "S",\n\t\t\t"\\uA7A8": "S",\n\t\t\t"\\uA784": "S",\n\t\t\t"\\u1E9E": "SS",\n\t\t\t"\\u24C9": "T",\n\t\t\t"\\uFF34": "T",\n\t\t\t"\\u1E6A": "T",\n\t\t\t"\\u0164": "T",\n\t\t\t"\\u1E6C": "T",\n\t\t\t"\\u021A": "T",\n\t\t\t"\\u0162": "T",\n\t\t\t"\\u1E70": "T",\n\t\t\t"\\u1E6E": "T",\n\t\t\t"\\u0166": "T",\n\t\t\t"\\u01AC": "T",\n\t\t\t"\\u01AE": "T",\n\t\t\t"\\u023E": "T",\n\t\t\t"\\uA786": "T",\n\t\t\t"\\uA728": "TZ",\n\t\t\t"\\u24CA": "U",\n\t\t\t"\\uFF35": "U",\n\t\t\t"\\u00D9": "U",\n\t\t\t"\\u00DA": "U",\n\t\t\t"\\u00DB": "U",\n\t\t\t"\\u0168": "U",\n\t\t\t"\\u1E78": "U",\n\t\t\t"\\u016A": "U",\n\t\t\t"\\u1E7A": "U",\n\t\t\t"\\u016C": "U",\n\t\t\t"\\u00DC": "U",\n\t\t\t"\\u01DB": "U",\n\t\t\t"\\u01D7": "U",\n\t\t\t"\\u01D5": "U",\n\t\t\t"\\u01D9": "U",\n\t\t\t"\\u1EE6": "U",\n\t\t\t"\\u016E": "U",\n\t\t\t"\\u0170": "U",\n\t\t\t"\\u01D3": "U",\n\t\t\t"\\u0214": "U",\n\t\t\t"\\u0216": "U",\n\t\t\t"\\u01AF": "U",\n\t\t\t"\\u1EEA": "U",\n\t\t\t"\\u1EE8": "U",\n\t\t\t"\\u1EEE": "U",\n\t\t\t"\\u1EEC": "U",\n\t\t\t"\\u1EF0": "U",\n\t\t\t"\\u1EE4": "U",\n\t\t\t"\\u1E72": "U",\n\t\t\t"\\u0172": "U",\n\t\t\t"\\u1E76": "U",\n\t\t\t"\\u1E74": "U",\n\t\t\t"\\u0244": "U",\n\t\t\t"\\u24CB": "V",\n\t\t\t"\\uFF36": "V",\n\t\t\t"\\u1E7C": "V",\n\t\t\t"\\u1E7E": "V",\n\t\t\t"\\u01B2": "V",\n\t\t\t"\\uA75E": "V",\n\t\t\t"\\u0245": "V",\n\t\t\t"\\uA760": "VY",\n\t\t\t"\\u24CC": "W",\n\t\t\t"\\uFF37": "W",\n\t\t\t"\\u1E80": "W",\n\t\t\t"\\u1E82": "W",\n\t\t\t"\\u0174": "W",\n\t\t\t"\\u1E86": "W",\n\t\t\t"\\u1E84": "W",\n\t\t\t"\\u1E88": "W",\n\t\t\t"\\u2C72": "W",\n\t\t\t"\\u24CD": "X",\n\t\t\t"\\uFF38": "X",\n\t\t\t"\\u1E8A": "X",\n\t\t\t"\\u1E8C": "X",\n\t\t\t"\\u24CE": "Y",\n\t\t\t"\\uFF39": "Y",\n\t\t\t"\\u1EF2": "Y",\n\t\t\t"\\u00DD": "Y",\n\t\t\t"\\u0176": "Y",\n\t\t\t"\\u1EF8": "Y",\n\t\t\t"\\u0232": "Y",\n\t\t\t"\\u1E8E": "Y",\n\t\t\t"\\u0178": "Y",\n\t\t\t"\\u1EF6": "Y",\n\t\t\t"\\u1EF4": "Y",\n\t\t\t"\\u01B3": "Y",\n\t\t\t"\\u024E": "Y",\n\t\t\t"\\u1EFE": "Y",\n\t\t\t"\\u24CF": "Z",\n\t\t\t"\\uFF3A": "Z",\n\t\t\t"\\u0179": "Z",\n\t\t\t"\\u1E90": "Z",\n\t\t\t"\\u017B": "Z",\n\t\t\t"\\u017D": "Z",\n\t\t\t"\\u1E92": "Z",\n\t\t\t"\\u1E94": "Z",\n\t\t\t"\\u01B5": "Z",\n\t\t\t"\\u0224": "Z",\n\t\t\t"\\u2C7F": "Z",\n\t\t\t"\\u2C6B": "Z",\n\t\t\t"\\uA762": "Z",\n\t\t\t"\\u24D0": "a",\n\t\t\t"\\uFF41": "a",\n\t\t\t"\\u1E9A": "a",\n\t\t\t"\\u00E0": "a",\n\t\t\t"\\u00E1": "a",\n\t\t\t"\\u00E2": "a",\n\t\t\t"\\u1EA7": "a",\n\t\t\t"\\u1EA5": "a",\n\t\t\t"\\u1EAB": "a",\n\t\t\t"\\u1EA9": "a",\n\t\t\t"\\u00E3": "a",\n\t\t\t"\\u0101": "a",\n\t\t\t"\\u0103": "a",\n\t\t\t"\\u1EB1": "a",\n\t\t\t"\\u1EAF": "a",\n\t\t\t"\\u1EB5": "a",\n\t\t\t"\\u1EB3": "a",\n\t\t\t"\\u0227": "a",\n\t\t\t"\\u01E1": "a",\n\t\t\t"\\u00E4": "a",\n\t\t\t"\\u01DF": "a",\n\t\t\t"\\u1EA3": "a",\n\t\t\t"\\u00E5": "a",\n\t\t\t"\\u01FB": "a",\n\t\t\t"\\u01CE": "a",\n\t\t\t"\\u0201": "a",\n\t\t\t"\\u0203": "a",\n\t\t\t"\\u1EA1": "a",\n\t\t\t"\\u1EAD": "a",\n\t\t\t"\\u1EB7": "a",\n\t\t\t"\\u1E01": "a",\n\t\t\t"\\u0105": "a",\n\t\t\t"\\u2C65": "a",\n\t\t\t"\\u0250": "a",\n\t\t\t"\\uA733": "aa",\n\t\t\t"\\u00E6": "ae",\n\t\t\t"\\u01FD": "ae",\n\t\t\t"\\u01E3": "ae",\n\t\t\t"\\uA735": "ao",\n\t\t\t"\\uA737": "au",\n\t\t\t"\\uA739": "av",\n\t\t\t"\\uA73B": "av",\n\t\t\t"\\uA73D": "ay",\n\t\t\t"\\u24D1": "b",\n\t\t\t"\\uFF42": "b",\n\t\t\t"\\u1E03": "b",\n\t\t\t"\\u1E05": "b",\n\t\t\t"\\u1E07": "b",\n\t\t\t"\\u0180": "b",\n\t\t\t"\\u0183": "b",\n\t\t\t"\\u0253": "b",\n\t\t\t"\\u24D2": "c",\n\t\t\t"\\uFF43": "c",\n\t\t\t"\\u0107": "c",\n\t\t\t"\\u0109": "c",\n\t\t\t"\\u010B": "c",\n\t\t\t"\\u010D": "c",\n\t\t\t"\\u00E7": "c",\n\t\t\t"\\u1E09": "c",\n\t\t\t"\\u0188": "c",\n\t\t\t"\\u023C": "c",\n\t\t\t"\\uA73F": "c",\n\t\t\t"\\u2184": "c",\n\t\t\t"\\u24D3": "d",\n\t\t\t"\\uFF44": "d",\n\t\t\t"\\u1E0B": "d",\n\t\t\t"\\u010F": "d",\n\t\t\t"\\u1E0D": "d",\n\t\t\t"\\u1E11": "d",\n\t\t\t"\\u1E13": "d",\n\t\t\t"\\u1E0F": "d",\n\t\t\t"\\u0111": "d",\n\t\t\t"\\u018C": "d",\n\t\t\t"\\u0256": "d",\n\t\t\t"\\u0257": "d",\n\t\t\t"\\uA77A": "d",\n\t\t\t"\\u01F3": "dz",\n\t\t\t"\\u01C6": "dz",\n\t\t\t"\\u24D4": "e",\n\t\t\t"\\uFF45": "e",\n\t\t\t"\\u00E8": "e",\n\t\t\t"\\u00E9": "e",\n\t\t\t"\\u00EA": "e",\n\t\t\t"\\u1EC1": "e",\n\t\t\t"\\u1EBF": "e",\n\t\t\t"\\u1EC5": "e",\n\t\t\t"\\u1EC3": "e",\n\t\t\t"\\u1EBD": "e",\n\t\t\t"\\u0113": "e",\n\t\t\t"\\u1E15": "e",\n\t\t\t"\\u1E17": "e",\n\t\t\t"\\u0115": "e",\n\t\t\t"\\u0117": "e",\n\t\t\t"\\u00EB": "e",\n\t\t\t"\\u1EBB": "e",\n\t\t\t"\\u011B": "e",\n\t\t\t"\\u0205": "e",\n\t\t\t"\\u0207": "e",\n\t\t\t"\\u1EB9": "e",\n\t\t\t"\\u1EC7": "e",\n\t\t\t"\\u0229": "e",\n\t\t\t"\\u1E1D": "e",\n\t\t\t"\\u0119": "e",\n\t\t\t"\\u1E19": "e",\n\t\t\t"\\u1E1B": "e",\n\t\t\t"\\u0247": "e",\n\t\t\t"\\u025B": "e",\n\t\t\t"\\u01DD": "e",\n\t\t\t"\\u24D5": "f",\n\t\t\t"\\uFF46": "f",\n\t\t\t"\\u1E1F": "f",\n\t\t\t"\\u0192": "f",\n\t\t\t"\\uA77C": "f",\n\t\t\t"\\u24D6": "g",\n\t\t\t"\\uFF47": "g",\n\t\t\t"\\u01F5": "g",\n\t\t\t"\\u011D": "g",\n\t\t\t"\\u1E21": "g",\n\t\t\t"\\u011F": "g",\n\t\t\t"\\u0121": "g",\n\t\t\t"\\u01E7": "g",\n\t\t\t"\\u0123": "g",\n\t\t\t"\\u01E5": "g",\n\t\t\t"\\u0260": "g",\n\t\t\t"\\uA7A1": "g",\n\t\t\t"\\u1D79": "g",\n\t\t\t"\\uA77F": "g",\n\t\t\t"\\u24D7": "h",\n\t\t\t"\\uFF48": "h",\n\t\t\t"\\u0125": "h",\n\t\t\t"\\u1E23": "h",\n\t\t\t"\\u1E27": "h",\n\t\t\t"\\u021F": "h",\n\t\t\t"\\u1E25": "h",\n\t\t\t"\\u1E29": "h",\n\t\t\t"\\u1E2B": "h",\n\t\t\t"\\u1E96": "h",\n\t\t\t"\\u0127": "h",\n\t\t\t"\\u2C68": "h",\n\t\t\t"\\u2C76": "h",\n\t\t\t"\\u0265": "h",\n\t\t\t"\\u0195": "hv",\n\t\t\t"\\u24D8": "i",\n\t\t\t"\\uFF49": "i",\n\t\t\t"\\u00EC": "i",\n\t\t\t"\\u00ED": "i",\n\t\t\t"\\u00EE": "i",\n\t\t\t"\\u0129": "i",\n\t\t\t"\\u012B": "i",\n\t\t\t"\\u012D": "i",\n\t\t\t"\\u00EF": "i",\n\t\t\t"\\u1E2F": "i",\n\t\t\t"\\u1EC9": "i",\n\t\t\t"\\u01D0": "i",\n\t\t\t"\\u0209": "i",\n\t\t\t"\\u020B": "i",\n\t\t\t"\\u1ECB": "i",\n\t\t\t"\\u012F": "i",\n\t\t\t"\\u1E2D": "i",\n\t\t\t"\\u0268": "i",\n\t\t\t"\\u0131": "i",\n\t\t\t"\\u24D9": "j",\n\t\t\t"\\uFF4A": "j",\n\t\t\t"\\u0135": "j",\n\t\t\t"\\u01F0": "j",\n\t\t\t"\\u0249": "j",\n\t\t\t"\\u24DA": "k",\n\t\t\t"\\uFF4B": "k",\n\t\t\t"\\u1E31": "k",\n\t\t\t"\\u01E9": "k",\n\t\t\t"\\u1E33": "k",\n\t\t\t"\\u0137": "k",\n\t\t\t"\\u1E35": "k",\n\t\t\t"\\u0199": "k",\n\t\t\t"\\u2C6A": "k",\n\t\t\t"\\uA741": "k",\n\t\t\t"\\uA743": "k",\n\t\t\t"\\uA745": "k",\n\t\t\t"\\uA7A3": "k",\n\t\t\t"\\u24DB": "l",\n\t\t\t"\\uFF4C": "l",\n\t\t\t"\\u0140": "l",\n\t\t\t"\\u013A": "l",\n\t\t\t"\\u013E": "l",\n\t\t\t"\\u1E37": "l",\n\t\t\t"\\u1E39": "l",\n\t\t\t"\\u013C": "l",\n\t\t\t"\\u1E3D": "l",\n\t\t\t"\\u1E3B": "l",\n\t\t\t"\\u0142": "l",\n\t\t\t"\\u019A": "l",\n\t\t\t"\\u026B": "l",\n\t\t\t"\\u2C61": "l",\n\t\t\t"\\uA749": "l",\n\t\t\t"\\uA781": "l",\n\t\t\t"\\uA747": "l",\n\t\t\t"\\u01C9": "lj",\n\t\t\t"\\u24DC": "m",\n\t\t\t"\\uFF4D": "m",\n\t\t\t"\\u1E3F": "m",\n\t\t\t"\\u1E41": "m",\n\t\t\t"\\u1E43": "m",\n\t\t\t"\\u0271": "m",\n\t\t\t"\\u026F": "m",\n\t\t\t"\\u24DD": "n",\n\t\t\t"\\uFF4E": "n",\n\t\t\t"\\u01F9": "n",\n\t\t\t"\\u0144": "n",\n\t\t\t"\\u00F1": "n",\n\t\t\t"\\u1E45": "n",\n\t\t\t"\\u0148": "n",\n\t\t\t"\\u1E47": "n",\n\t\t\t"\\u0146": "n",\n\t\t\t"\\u1E4B": "n",\n\t\t\t"\\u1E49": "n",\n\t\t\t"\\u019E": "n",\n\t\t\t"\\u0272": "n",\n\t\t\t"\\u0149": "n",\n\t\t\t"\\uA791": "n",\n\t\t\t"\\uA7A5": "n",\n\t\t\t"\\u01CC": "nj",\n\t\t\t"\\u24DE": "o",\n\t\t\t"\\uFF4F": "o",\n\t\t\t"\\u00F2": "o",\n\t\t\t"\\u00F3": "o",\n\t\t\t"\\u00F4": "o",\n\t\t\t"\\u1ED3": "o",\n\t\t\t"\\u1ED1": "o",\n\t\t\t"\\u1ED7": "o",\n\t\t\t"\\u1ED5": "o",\n\t\t\t"\\u00F5": "o",\n\t\t\t"\\u1E4D": "o",\n\t\t\t"\\u022D": "o",\n\t\t\t"\\u1E4F": "o",\n\t\t\t"\\u014D": "o",\n\t\t\t"\\u1E51": "o",\n\t\t\t"\\u1E53": "o",\n\t\t\t"\\u014F": "o",\n\t\t\t"\\u022F": "o",\n\t\t\t"\\u0231": "o",\n\t\t\t"\\u00F6": "o",\n\t\t\t"\\u022B": "o",\n\t\t\t"\\u1ECF": "o",\n\t\t\t"\\u0151": "o",\n\t\t\t"\\u01D2": "o",\n\t\t\t"\\u020D": "o",\n\t\t\t"\\u020F": "o",\n\t\t\t"\\u01A1": "o",\n\t\t\t"\\u1EDD": "o",\n\t\t\t"\\u1EDB": "o",\n\t\t\t"\\u1EE1": "o",\n\t\t\t"\\u1EDF": "o",\n\t\t\t"\\u1EE3": "o",\n\t\t\t"\\u1ECD": "o",\n\t\t\t"\\u1ED9": "o",\n\t\t\t"\\u01EB": "o",\n\t\t\t"\\u01ED": "o",\n\t\t\t"\\u00F8": "o",\n\t\t\t"\\u01FF": "o",\n\t\t\t"\\u0254": "o",\n\t\t\t"\\uA74B": "o",\n\t\t\t"\\uA74D": "o",\n\t\t\t"\\u0275": "o",\n\t\t\t"\\u0153": "oe",\n\t\t\t"\\u0276": "oe",\n\t\t\t"\\u01A3": "oi",\n\t\t\t"\\u0223": "ou",\n\t\t\t"\\uA74F": "oo",\n\t\t\t"\\u24DF": "p",\n\t\t\t"\\uFF50": "p",\n\t\t\t"\\u1E55": "p",\n\t\t\t"\\u1E57": "p",\n\t\t\t"\\u01A5": "p",\n\t\t\t"\\u1D7D": "p",\n\t\t\t"\\uA751": "p",\n\t\t\t"\\uA753": "p",\n\t\t\t"\\uA755": "p",\n\t\t\t"\\u24E0": "q",\n\t\t\t"\\uFF51": "q",\n\t\t\t"\\u024B": "q",\n\t\t\t"\\uA757": "q",\n\t\t\t"\\uA759": "q",\n\t\t\t"\\u24E1": "r",\n\t\t\t"\\uFF52": "r",\n\t\t\t"\\u0155": "r",\n\t\t\t"\\u1E59": "r",\n\t\t\t"\\u0159": "r",\n\t\t\t"\\u0211": "r",\n\t\t\t"\\u0213": "r",\n\t\t\t"\\u1E5B": "r",\n\t\t\t"\\u1E5D": "r",\n\t\t\t"\\u0157": "r",\n\t\t\t"\\u1E5F": "r",\n\t\t\t"\\u024D": "r",\n\t\t\t"\\u027D": "r",\n\t\t\t"\\uA75B": "r",\n\t\t\t"\\uA7A7": "r",\n\t\t\t"\\uA783": "r",\n\t\t\t"\\u24E2": "s",\n\t\t\t"\\uFF53": "s",\n\t\t\t"\\u015B": "s",\n\t\t\t"\\u1E65": "s",\n\t\t\t"\\u015D": "s",\n\t\t\t"\\u1E61": "s",\n\t\t\t"\\u0161": "s",\n\t\t\t"\\u1E67": "s",\n\t\t\t"\\u1E63": "s",\n\t\t\t"\\u1E69": "s",\n\t\t\t"\\u0219": "s",\n\t\t\t"\\u015F": "s",\n\t\t\t"\\u023F": "s",\n\t\t\t"\\uA7A9": "s",\n\t\t\t"\\uA785": "s",\n\t\t\t"\\u017F": "s",\n\t\t\t"\\u1E9B": "s",\n\t\t\t"\\u00DF": "ss",\n\t\t\t"\\u24E3": "t",\n\t\t\t"\\uFF54": "t",\n\t\t\t"\\u1E6B": "t",\n\t\t\t"\\u1E97": "t",\n\t\t\t"\\u0165": "t",\n\t\t\t"\\u1E6D": "t",\n\t\t\t"\\u021B": "t",\n\t\t\t"\\u0163": "t",\n\t\t\t"\\u1E71": "t",\n\t\t\t"\\u1E6F": "t",\n\t\t\t"\\u0167": "t",\n\t\t\t"\\u01AD": "t",\n\t\t\t"\\u0288": "t",\n\t\t\t"\\u2C66": "t",\n\t\t\t"\\uA787": "t",\n\t\t\t"\\uA729": "tz",\n\t\t\t"\\u24E4": "u",\n\t\t\t"\\uFF55": "u",\n\t\t\t"\\u00F9": "u",\n\t\t\t"\\u00FA": "u",\n\t\t\t"\\u00FB": "u",\n\t\t\t"\\u0169": "u",\n\t\t\t"\\u1E79": "u",\n\t\t\t"\\u016B": "u",\n\t\t\t"\\u1E7B": "u",\n\t\t\t"\\u016D": "u",\n\t\t\t"\\u00FC": "u",\n\t\t\t"\\u01DC": "u",\n\t\t\t"\\u01D8": "u",\n\t\t\t"\\u01D6": "u",\n\t\t\t"\\u01DA": "u",\n\t\t\t"\\u1EE7": "u",\n\t\t\t"\\u016F": "u",\n\t\t\t"\\u0171": "u",\n\t\t\t"\\u01D4": "u",\n\t\t\t"\\u0215": "u",\n\t\t\t"\\u0217": "u",\n\t\t\t"\\u01B0": "u",\n\t\t\t"\\u1EEB": "u",\n\t\t\t"\\u1EE9": "u",\n\t\t\t"\\u1EEF": "u",\n\t\t\t"\\u1EED": "u",\n\t\t\t"\\u1EF1": "u",\n\t\t\t"\\u1EE5": "u",\n\t\t\t"\\u1E73": "u",\n\t\t\t"\\u0173": "u",\n\t\t\t"\\u1E77": "u",\n\t\t\t"\\u1E75": "u",\n\t\t\t"\\u0289": "u",\n\t\t\t"\\u24E5": "v",\n\t\t\t"\\uFF56": "v",\n\t\t\t"\\u1E7D": "v",\n\t\t\t"\\u1E7F": "v",\n\t\t\t"\\u028B": "v",\n\t\t\t"\\uA75F": "v",\n\t\t\t"\\u028C": "v",\n\t\t\t"\\uA761": "vy",\n\t\t\t"\\u24E6": "w",\n\t\t\t"\\uFF57": "w",\n\t\t\t"\\u1E81": "w",\n\t\t\t"\\u1E83": "w",\n\t\t\t"\\u0175": "w",\n\t\t\t"\\u1E87": "w",\n\t\t\t"\\u1E85": "w",\n\t\t\t"\\u1E98": "w",\n\t\t\t"\\u1E89": "w",\n\t\t\t"\\u2C73": "w",\n\t\t\t"\\u24E7": "x",\n\t\t\t"\\uFF58": "x",\n\t\t\t"\\u1E8B": "x",\n\t\t\t"\\u1E8D": "x",\n\t\t\t"\\u24E8": "y",\n\t\t\t"\\uFF59": "y",\n\t\t\t"\\u1EF3": "y",\n\t\t\t"\\u00FD": "y",\n\t\t\t"\\u0177": "y",\n\t\t\t"\\u1EF9": "y",\n\t\t\t"\\u0233": "y",\n\t\t\t"\\u1E8F": "y",\n\t\t\t"\\u00FF": "y",\n\t\t\t"\\u1EF7": "y",\n\t\t\t"\\u1E99": "y",\n\t\t\t"\\u1EF5": "y",\n\t\t\t"\\u01B4": "y",\n\t\t\t"\\u024F": "y",\n\t\t\t"\\u1EFF": "y",\n\t\t\t"\\u24E9": "z",\n\t\t\t"\\uFF5A": "z",\n\t\t\t"\\u017A": "z",\n\t\t\t"\\u1E91": "z",\n\t\t\t"\\u017C": "z",\n\t\t\t"\\u017E": "z",\n\t\t\t"\\u1E93": "z",\n\t\t\t"\\u1E95": "z",\n\t\t\t"\\u01B6": "z",\n\t\t\t"\\u0225": "z",\n\t\t\t"\\u0240": "z",\n\t\t\t"\\u2C6C": "z",\n\t\t\t"\\uA763": "z",\n\t\t\t"\\uFF10": "0",\n\t\t\t"\\u2080": "0",\n\t\t\t"\\u24EA": "0",\n\t\t\t"\\u2070": "0",\n\t\t\t"\\u00B9": "1",\n\t\t\t"\\u2474": "1",\n\t\t\t"\\u2081": "1",\n\t\t\t"\\u2776": "1",\n\t\t\t"\\u24F5": "1",\n\t\t\t"\\u2488": "1",\n\t\t\t"\\u2460": "1",\n\t\t\t"\\uFF11": "1",\n\t\t\t"\\u00B2": "2",\n\t\t\t"\\u2777": "2",\n\t\t\t"\\u2475": "2",\n\t\t\t"\\uFF12": "2",\n\t\t\t"\\u2082": "2",\n\t\t\t"\\u24F6": "2",\n\t\t\t"\\u2461": "2",\n\t\t\t"\\u2489": "2",\n\t\t\t"\\u00B3": "3",\n\t\t\t"\\uFF13": "3",\n\t\t\t"\\u248A": "3",\n\t\t\t"\\u2476": "3",\n\t\t\t"\\u2083": "3",\n\t\t\t"\\u2778": "3",\n\t\t\t"\\u24F7": "3",\n\t\t\t"\\u2462": "3",\n\t\t\t"\\u24F8": "4",\n\t\t\t"\\u2463": "4",\n\t\t\t"\\u248B": "4",\n\t\t\t"\\uFF14": "4",\n\t\t\t"\\u2074": "4",\n\t\t\t"\\u2084": "4",\n\t\t\t"\\u2779": "4",\n\t\t\t"\\u2477": "4",\n\t\t\t"\\u248C": "5",\n\t\t\t"\\u2085": "5",\n\t\t\t"\\u24F9": "5",\n\t\t\t"\\u2478": "5",\n\t\t\t"\\u277A": "5",\n\t\t\t"\\u2464": "5",\n\t\t\t"\\uFF15": "5",\n\t\t\t"\\u2075": "5",\n\t\t\t"\\u2479": "6",\n\t\t\t"\\u2076": "6",\n\t\t\t"\\uFF16": "6",\n\t\t\t"\\u277B": "6",\n\t\t\t"\\u2086": "6",\n\t\t\t"\\u2465": "6",\n\t\t\t"\\u24FA": "6",\n\t\t\t"\\u248D": "6",\n\t\t\t"\\uFF17": "7",\n\t\t\t"\\u2077": "7",\n\t\t\t"\\u277C": "7",\n\t\t\t"\\u24FB": "7",\n\t\t\t"\\u248E": "7",\n\t\t\t"\\u2087": "7",\n\t\t\t"\\u247A": "7",\n\t\t\t"\\u2466": "7",\n\t\t\t"\\u2467": "8",\n\t\t\t"\\u248F": "8",\n\t\t\t"\\u24FC": "8",\n\t\t\t"\\u247B": "8",\n\t\t\t"\\u2078": "8",\n\t\t\t"\\uFF18": "8",\n\t\t\t"\\u277D": "8",\n\t\t\t"\\u2088": "8",\n\t\t\t"\\u24FD": "9",\n\t\t\t"\\uFF19": "9",\n\t\t\t"\\u2490": "9",\n\t\t\t"\\u277E": "9",\n\t\t\t"\\u247C": "9",\n\t\t\t"\\u2089": "9",\n\t\t\t"\\u2468": "9",\n\t\t\t"\\u2079": "9"\n\t\t},\n\t\tchars = str.split( "" ),\n\t\tlen = chars.length,\n\t\tnormalized = false,\n\t\ti, character;\n\tfor ( i = 0; i !== len; i += 1 ) {\n\t\tcharacter = chars[ i ];\n\t\tif ( diacritics.hasOwnProperty( character ) ) {\n\t\t\tchars[ i ] = diacritics[ character ];\n\t\t\tnormalized = true;\n\t\t}\n\t}\n\treturn ( normalized ? chars.join( "" ) : str );\n};\n\n/**\n * @namespace wb.string\n */\nwb.string = {\n\n\t/*\n\t * Left-pads a number with zeros.\n\t * @memberof wb.string\n\t * @param {number} number The original number to pad.\n\t * @param {number} length The width of the resulting padded number, not the number of zeros to add to the front of the string.\n\t * @return {string} The padded string\n\t */\n\tpad: function( number, length ) {\n\t\tvar str = number + "",\n\t\t\tdiff = length - str.length,\n\t\t\ti;\n\t\tfor ( i = 0; i !== diff; i += 1 ) {\n\t\t\tstr = "0" + str;\n\t\t}\n\t\treturn str;\n\t}\n};\n\n/*\n * A suite of date related functions for easier parsing of dates\n * @namespace wb.date\n */\nwb.date = {\n\n\t/*\n\t * Converts the date to a date-object. The input can be:\n\t * <ul>\n\t * <li>a Date object: returned without modification.</li>\n\t * <li>an array: Interpreted as [year,month,day]. NOTE: month is 0-11.</li>\n\t * <li>a number: Interpreted as number of milliseconds since 1 Jan 1970 (a timestamp).</li>\n\t * <li>a string: Any format supported by the javascript engine, like \'YYYY/MM/DD\', \'MM/DD/YYYY\', \'Jan 31 2009\' etc.</li>\n\t * <li>an object: Interpreted as an object with year, month and date attributes. **NOTE** month is 0-11.</li>\n\t * </ul>\n\t * @memberof wb.date\n\t * @param {Date | number[] | number | string | object} dateValue\n\t * @return {Date | NaN}\n\t */\n\tconvert: function( dateValue ) {\n\t\tvar dateConstructor = dateValue.constructor;\n\n\t\tswitch ( dateConstructor ) {\n\t\tcase Date:\n\t\t\treturn dateConstructor;\n\t\tcase Array:\n\t\t\treturn new Date( dateValue[ 0 ], dateValue[ 1 ], dateValue[ 2 ] );\n\t\tcase Number:\n\t\tcase String:\n\t\t\treturn new Date( dateValue );\n\t\tdefault:\n\t\t\treturn typeof dateValue === "object" ? new Date( dateValue.year, dateValue.month, dateValue.date ) : NaN;\n\t\t}\n\t},\n\n\t/*\n\t * Compares two dates (input can be any type supported by the convert function).\n\t * @memberof wb.date\n\t * @param {Date | number[] | number | string | object} dateValue1\n\t * @param {Date | number[] | number | string | object} dateValue2\n\t * @return {number | NaN}\n\t * @example returns\n\t * -1 if dateValue1 < dateValue2\n\t * 0 if dateValue1 = dateValue2\n\t * 1 if dateValue1 > dateValue2\n\t * NaN if dateValue1 or dateValue2 is an illegal date\n\t */\n\tcompare: function( dateValue1, dateValue2 ) {\n\t\tvar convert = wb.date.convert;\n\n\t\tif ( isFinite( dateValue1 = convert( dateValue1 ).valueOf() ) && isFinite( dateValue2 = convert( dateValue2 ).valueOf() ) ) {\n\t\t\treturn ( dateValue1 > dateValue2 ) - ( dateValue1 < dateValue2 );\n\t\t}\n\t\treturn NaN;\n\t},\n\n\t/*\n\t * Cross-browser safe way of translating a date to ISO format\n\t * @memberof wb.date\n\t * @param {Date | number[] | number | string | object} dateValue\n\t * @param {boolean} withTime Optional. Whether to include the time in the result, or just the date. False if blank.\n\t * @return {string}\n\t * @example\n\t * toDateISO( new Date() )\n\t * returns "2012-04-27"\n\t * toDateISO( new Date(), true )\n\t * returns "2012-04-27 13:46"\n\t */\n\ttoDateISO: function( dateValue, withTime ) {\n\t\tvar date = wb.date.convert( dateValue ),\n\t\t\tpad = wb.string.pad;\n\n\t\treturn date.getFullYear() + "-" + pad( date.getMonth() + 1, 2, "0" ) + "-" + pad( date.getDate(), 2, "0" ) +\n\t\t\t( withTime ? " " + pad( date.getHours(), 2, "0" ) + ":" + pad( date.getMinutes(), 2, "0" ) : "" );\n\t},\n\n\t/*\n\t * Cross-browser safe way of creating a date object from a date string in ISO format\n\t * @memberof wb.date\n\t * @param {string} dateISO Date string in ISO format\n\t * @return {Date}\n\t */\n\tfromDateISO: function( dateISO ) {\n\t\tvar date = null;\n\n\t\tif ( dateISO && dateISO.match( /\\d{4}-\\d{2}-\\d{2}/ ) ) {\n\t\t\tdate = new Date( dateISO.substr( 0, 4 ), dateISO.substr( 5, 2 ) - 1, dateISO.substr( 8, 2 ), 0, 0, 0, 0 );\n\t\t}\n\t\treturn date;\n\t}\n};\n\n/*\n * Returns a RFC4122 compliant Global Unique ID (GUID).\n * Originally from http://stackoverflow.com/a/2117523/455535\n */\nwb.guid = function() {\n\treturn "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace( /[xy]/g, function( replacementChar ) {\n\t\tvar rand = Math.random() * 16 | 0,\n\t\t\tnewChar = replacementChar === "x" ? rand : ( rand & 0x3 | 0x8 );\n\t\treturn newChar.toString( 16 );\n\t} );\n};\n\nwb.escapeAttribute = function( str ) {\n\treturn str.replace( /\'/g, "&#39;" ).replace( /"/g, "&#34;" );\n};\n\n} )( wb );\n\n( function( $, undef ) {\n"use strict";\n\nvar methods,\n\tsettings = {\n\t\t"default": "wet-boew"\n\t};\n\nmethods = {\n\n\tinit: function( options ) {\n\t\treturn $.extend( settings, options || {} );\n\t},\n\n\tshow: function( onlyAria ) {\n\t\t$( this ).each( function() {\n\t\t\tvar $elm = $( this );\n\t\t\t$elm.attr( "aria-hidden", "false" );\n\t\t\tif ( onlyAria === undef ) {\n\t\t\t\t$elm.removeClass( "wb-inv" );\n\t\t\t}\n\t\t} );\n\t},\n\n\thide: function( onlyAria ) {\n\t\t$( this )\n\t\t\t.each( function() {\n\t\t\t\tvar $elm = $( this );\n\t\t\t\t$elm.attr( "aria-hidden", "true" );\n\t\t\t\tif ( onlyAria === undef ) {\n\t\t\t\t\treturn $elm.addClass( "wb-inv" );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\n\ttoggle: function( to, from ) {\n\t\t$( this )\n\t\t\t.addClass( to )\n\t\t\t.removeClass( from );\n\t}\n};\n\n$.fn.wb = function( method ) {\n\n\tif ( methods[ method ] ) {\n\t\tmethods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ) );\n\t} else if ( typeof method === "object" || !method ) {\n\t\tmethods.init.apply( this, arguments );\n\t} else {\n\t\t$.error( "Method " + method + " does not exist on jquery.wb" );\n\t}\n};\n\n} )( jQuery );\n\n/*\n:focusable and :tabable jQuery helper expressions - https://github.com/jquery/jquery-ui/blob/24756a978a977d7abbef5e5bce403837a01d964f/ui/jquery.ui.core.js\n*/\n( function( $ ) {\n\n"use strict";\n\nfunction focusable( element, isTabIndexNotNaN, visibility ) {\n\tvar map, mapName, img,\n\t\tnodeName = element.nodeName.toLowerCase( );\n\tif ( nodeName === "area" ) {\n\t\tmap = element.parentNode;\n\t\tmapName = map.name;\n\t\tif ( !element.href || !mapName || map.nodeName.toLowerCase( ) !== "map" ) {\n\t\t\treturn false;\n\t\t}\n\t\timg = $( "img[usemap=#" + mapName + "]" )[ 0 ];\n\t\treturn !!img && visible( img );\n\t}\n\tif ( visibility ) {\n\t\treturn ( /input|select|textarea|button|object/.test( nodeName ) ? !element.disabled :\n\t\t\tnodeName === "a" ?\n\t\t\telement.href || isTabIndexNotNaN :\n\t\t\tisTabIndexNotNaN ) &&\n\t\tvisible( element ); /* the element and all of its ancestors must be visible */\n\t} else {\n\t\treturn ( /input|select|textarea|button|object/.test( nodeName ) ? !element.disabled :\n\t\t\tnodeName === "a" ?\n\t\t\telement.href || isTabIndexNotNaN :\n\t\t\tisTabIndexNotNaN );\n\t}\n}\n\nfunction visible( element ) {\n\treturn $.expr.filters.visible( element ) && !$( element )\n\t\t.parents( )\n\t\t.addBack( )\n\t\t.filter( function() {\n\t\t\treturn $.css( this, "visibility" ) === "hidden";\n\t\t} )\n\t\t.length;\n}\n\n$.extend( $.expr[ ":" ], {\n\tdata: $.expr.createPseudo ? $.expr.createPseudo( function( dataName ) {\n\t\treturn function( elem ) {\n\t\t\treturn !!$.data( elem, dataName );\n\t\t};\n\t} ) :\n\n\t// support: jQuery <1.8\n\n\tfunction( elem, i, match ) {\n\t\treturn !!$.data( elem, match[ 3 ] );\n\t},\n\tfocusable: function( element ) {\n\t\treturn focusable( element, !isNaN( $.attr( element, "tabindex" ) ), true );\n\t},\n\tdiscoverable: function( element ) {\n\t\treturn focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );\n\t},\n\ttabbable: function( element ) {\n\t\tvar tabIndex = $.attr( element, "tabindex" ),\n\t\t\tisTabIndexNaN = isNaN( tabIndex );\n\t\treturn ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );\n\t}\n} );\n\n} )( jQuery );\n\n/**\n * @title WET-BOEW Ajax Fetch [ ajax-fetch ]\n * @overview A basic AjaxLoader wrapper for WET-BOEW\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author WET Community\n */\n( function( $, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar $document = wb.doc;\n\n// Event binding\n$document.on( "ajax-fetch.wb", function( event ) {\n\n\t// TODO: Remove event.element in future versions\n\tvar caller = event.element || event.target,\n\t\tfetchOpts = event.fetch,\n\t\turlParts = fetchOpts.url.split( " " ),\n\t\turl = urlParts[ 0 ],\n\t\turlSubParts = url.split( "#" ),\n\t\turlHash = urlSubParts[ 1 ],\n\t\tselector = urlParts[ 1 ] || ( urlHash ? "#" + urlHash : false ),\n\t\tfetchData, callerId, fetchNoCacheURL, urlSub,\n\t\tfetchNoCache = fetchOpts.nocache,\n\t\tfetchNoCacheKey = fetchOpts.nocachekey || wb.cacheBustKey || "wbCacheBust";\n\n\t// Separate the URL from the filtering criteria\n\tif ( selector ) {\n\t\tfetchOpts.url = urlParts[ 0 ];\n\t}\n\n\tif ( fetchNoCache ) {\n\t\tif ( fetchNoCache === "nocache" ) {\n\t\t\tfetchNoCacheURL = wb.guid();\n\t\t} else {\n\t\t\tfetchNoCacheURL = wb.sessionGUID();\n\t\t}\n\t\tfetchNoCacheURL = fetchNoCacheKey + "=" + fetchNoCacheURL;\n\n\t\turlSub = urlSubParts[ 0 ];\n\t\tif ( urlSub.indexOf( "?" ) !== -1 ) {\n\t\t\turl = urlSub + "&" + fetchNoCacheURL + ( urlHash ? "#" + urlHash : "" );\n\t\t} else {\n\t\t\turl = urlSub + "?" + fetchNoCacheURL + ( urlHash ? "#" + urlHash : "" );\n\t\t}\n\n\t\tfetchOpts.url = url;\n\t}\n\n\t// Filter out any events triggered by descendants\n\tif ( caller === event.target || event.currentTarget === event.target ) {\n\n\t\tif ( !caller.id ) {\n\t\t\tcaller.id = wb.getId();\n\t\t}\n\t\tcallerId = caller.id;\n\n\t\t$.ajax( fetchOpts )\n\t\t\t.done( function( response, status, xhr ) {\n\t\t\t\tvar responseType = typeof response;\n\n\t\t\t\tif ( selector ) {\n\t\t\t\t\tresponse = $( "<div>" + response + "</div>" ).find( selector );\n\t\t\t\t}\n\n\t\t\t\tfetchData = {\n\t\t\t\t\tresponse: response,\n\t\t\t\t\tstatus: status,\n\t\t\t\t\txhr: xhr\n\t\t\t\t};\n\n\t\t\t\tfetchData.pointer = $( "<div id=\'" + wb.getId() + "\' data-type=\'" + responseType + "\' />" )\n\t\t\t\t\t\t\t\t\t\t.append( responseType === "string" ? response : "" );\n\n\t\t\t\t$( "#" + callerId ).trigger( {\n\t\t\t\t\ttype: "ajax-fetched.wb",\n\t\t\t\t\tfetch: fetchData\n\t\t\t\t}, this );\n\t\t\t} )\n\t\t\t.fail( function( xhr, status, error ) {\n\t\t\t\t$( "#" + callerId ).trigger( {\n\t\t\t\t\ttype: "ajax-failed.wb",\n\t\t\t\t\tfetch: {\n\t\t\t\t\t\txhr: xhr,\n\t\t\t\t\t\tstatus: status,\n\t\t\t\t\t\terror: error\n\t\t\t\t\t}\n\t\t\t\t}, this );\n\t\t\t}, this );\n\t}\n} );\n\n} )( jQuery, wb );\n\n/**\n * @title WET-BOEW Events Calendar\n * @overview Dynamically generates a calendar interface for navigating a list of events.\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author WET Community\n */\n( function( $, window, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-calevt",\n\tselector = "." + componentName,\n\tinitEvent = "wb-init" + selector,\n\tevDetails = "ev-details",\n\tsetFocusEvent = "focus",\n\tdataAttr = componentName,\n\t$document = wb.doc,\n\ti18n, i18nText,\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered this handler\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\t$elm;\n\n\t\tif ( elm ) {\n\t\t\t$elm = $( elm );\n\n\t\t\t// Only initialize the i18nText once\n\t\t\tif ( !i18nText ) {\n\t\t\t\ti18n = wb.i18n;\n\t\t\t\ti18nText = {\n\t\t\t\t\tcalendar: i18n( "cal" )\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Load ajax content\n\t\t\t$.when.apply( $, $.map( $elm.find( "[data-calevt]" ), getAjax ) )\n\t\t\t\t.always( function() {\n\t\t\t\t\tprocessEvents( $elm );\n\n\t\t\t\t\t// Identify that initialization has completed\n\t\t\t\t\twb.ready( $elm, componentName );\n\t\t\t\t} );\n\t\t}\n\t},\n\n\tgetAjax = function( ajaxContainer ) {\n\t\tvar $ajaxContainer = $( ajaxContainer ),\n\t\t\turls = $ajaxContainer.data( "calevt" ).split( /\\s+/ ),\n\t\t\tdfd = $.Deferred(),\n\t\t\tlen = urls.length,\n\t\t\tpromises = [],\n\t\t\ti, appendData;\n\n\t\tappendData = function( data ) {\n\t\t\t$ajaxContainer.append( $.trim( data ) );\n\t\t};\n\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tpromises.push( $.get( urls[ i ], appendData, "html" ) );\n\t\t}\n\n\t\t$.when.apply( $, promises ).always( function() {\n\t\t\tdfd.resolve();\n\t\t} );\n\n\t\treturn dfd.promise();\n\t},\n\n\tprocessEvents = function( $elm ) {\n\t\tvar settings = $.extend( {}, window[ componentName ], $elm.data( dataAttr ) ),\n\t\t\tyear, month, events, containerId, $container,\n\t\t\tminDate, maxDate, minDateTime, maxDateTime,\n\t\t\tcurrDate = new Date(),\n\t\t\tcurrDateTime = currDate.getTime();\n\n\t\tevents = getEvents( $elm );\n\t\tcontainerId = $elm.data( "calevtSrc" );\n\t\t$container = $( "#" + containerId ).addClass( componentName + "-cal" );\n\n\t\tyear = settings.year;\n\t\tmonth = settings.month;\n\n\t\tminDate = events.minDate;\n\t\tmaxDate = events.maxDate;\n\t\tminDateTime = minDate.getTime();\n\t\tmaxDateTime = maxDate.getTime();\n\n\t\tif ( !year && minDateTime < currDateTime && currDateTime < maxDateTime ) {\n\t\t\tyear = currDate.getFullYear();\n\t\t} else if ( !year && currDateTime < minDateTime ) {\n\t\t\tyear = minDate.getFullYear();\n\t\t} else if ( !year && maxDateTime < currDateTime ) {\n\t\t\tyear = maxDate.getFullYear();\n\t\t}\n\n\t\tif ( !month && minDateTime < currDateTime && currDate.getTime() < maxDateTime ) {\n\t\t\tmonth = currDate.getMonth();\n\t\t} else if ( !month && currDateTime < minDateTime ) {\n\t\t\tmonth = minDate.getMonth();\n\t\t} else if ( !month && maxDateTime < currDateTime ) {\n\t\t\tmonth = maxDate.getMonth();\n\t\t}\n\n\t\twb.calendar.create( $container, {\n\t\t\tyear: year,\n\t\t\tmonth: month,\n\t\t\tminDate: minDate,\n\t\t\tmaxDate: maxDate,\n\t\t\tdaysCallback: addEvents,\n\t\t\tevents: events.list,\n\t\t\t$events: $elm\n\t\t} );\n\n\t\t$container.attr( "aria-label", i18nText.calendar );\n\t},\n\n\tdaysBetween = function( dateLow, dateHigh ) {\n\n\t\t// Simplified conversion to date object\n\t\tvar date1 = wb.date.convert( dateLow ),\n\t\t\tdate2 = wb.date.convert( dateHigh ),\n\t\t\tdstAdjust = 0,\n\t\t\toneMinute = 1000 * 60,\n\t\t\toneDay = oneMinute * 60 * 24,\n\t\t\tdiff;\n\n\t\t// Equalize times in case date objects have them\n\t\tdate1.setHours( 0 );\n\t\tdate1.setMinutes( 0 );\n\t\tdate1.setSeconds( 0 );\n\t\tdate2.setHours( 0 );\n\t\tdate2.setMinutes( 0 );\n\t\tdate2.setSeconds( 0 );\n\n\t\t// Take care of spans across Daylight Saving Time changes\n\t\tif ( date2 > date1 ) {\n\t\t\tdstAdjust = ( date2.getTimezoneOffset() - date1.getTimezoneOffset() ) * oneMinute;\n\t\t} else {\n\t\t\tdstAdjust = ( date1.getTimezoneOffset() - date2.getTimezoneOffset() ) * oneMinute;\n\t\t}\n\t\tdiff = Math.abs( date2.getTime() - date1.getTime() ) - dstAdjust;\n\t\treturn Math.ceil( diff / oneDay );\n\t},\n\n\t///TODO: Review this code\n\tgetEvents = function( obj ) {\n\t\tvar directLinking = !( $( obj ).hasClass( "evt-anchor" ) ),\n\t\t\tevents = {\n\t\t\t\tminDate: null,\n\t\t\t\tmaxDate: null,\n\t\t\t\tiCount: 0,\n\t\t\t\tlist: [\n\t\t\t\t\t{\n\t\t\t\t\t\ta: 1\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t},\n\t\t\tobjEventsList = obj.find( "ol > li, ul > li" ),\n\t\t\tiLen = objEventsList.length,\n\t\t\tdateTimeRegExp = /datetime\\s+\\{date\\:\\s*(\\d+-\\d+-\\d+)\\}/,\n\t\t\ti, $event, event, $objTitle, title, link, href, target,\n\t\t\tlinkId, date, tCollection, tCollectionTemp,\tstrDate1,\n\t\t\tstrDate2, z, zLen, className, dateClass;\n\n\t\tfor ( i = 0; i !== iLen; i += 1 ) {\n\t\t\t$event = objEventsList.eq( i );\n\t\t\tevent = $event[ 0 ];\n\t\t\t$objTitle = $event.find( "*:header:first" );\n\t\t\tclassName = $objTitle.attr( "class" );\n\t\t\ttitle = $objTitle.text();\n\t\t\tlink = $event.find( "a" )[ 0 ];\n\t\t\thref = link.getAttribute( "href" );\n\t\t\ttarget = link.getAttribute( "target" );\n\t\t\tzLen = 1;\n\n\t\t\t/*\n\t\t\t * Modification direct-linking or page-linking\n\t\t\t *\t- added the ability  to have class set the behaviour of the links\n\t\t\t *\t- default is to use the link of the item as the event link in the calendar\n\t\t\t *\t- \'evt-anchor\' class dynamically generates page anchors on the links it maps to the event\n\t\t\t */\n\t\t\tif ( !directLinking ) {\n\t\t\t\tlinkId = event.id || wb.getId();\n\t\t\t\tevent.id = linkId;\n\n\t\t\t\t/*\n\t\t\t\t * Fixes IE tabbing error:\n\t\t\t\t * http://www.earthchronicle.com/ECv1point8/Accessibility01IEAnchoredKeyboardNavigation.aspx\n\t\t\t\t */\n\n\t\t\t\t// TODO: Which versions of IE should this fix be limited to?\n\t\t\t\tif ( wb.ie ) {\n\t\t\t\t\tevent.tabIndex = "-1";\n\t\t\t\t}\n\t\t\t\thref = "#" + linkId;\n\t\t\t}\n\n\t\t\tdate = new Date();\n\t\t\tdate.setHours( 0, 0, 0, 0 );\n\t\t\ttCollection = event.getElementsByTagName( "time" );\n\n\t\t\t/*\n\t\t\t * Date spanning capability\n\t\t\t *   - since there may be some dates that are capable of spanning over months we need to identify them\n\t\t\t *     the process is see how many time nodes are in the event. 2 nodes will trigger a span\n\t\t\t */\n\t\t\tif ( tCollection.length !== 0 ) {\n\t\t\t\ttCollectionTemp = tCollection[ 0 ];\n\t\t\t\tstrDate1 = tCollectionTemp.nodeName.toLowerCase() === "time" ?\n\t\t\t\t\ttCollectionTemp.getAttribute( "datetime" ).substr( 0, 10 ).split( "-" ) :\n\t\t\t\t\ttCollectionTemp.className.match( dateTimeRegExp )[ 1 ].substr( 0, 10 ).split( "-" );\n\n\t\t\t\t// Convert to zero-based month\n\t\t\t\tstrDate1[ 1 ] = strDate1[ 1 ] - 1;\n\n\t\t\t\tdate.setFullYear( strDate1[ 0 ], strDate1[ 1 ], strDate1[ 2 ] );\n\n\t\t\t\tif ( tCollection.length !== 1 ) {\n\n\t\t\t\t\t// This is a spanning event\n\t\t\t\t\ttCollectionTemp = tCollection[ 1 ];\n\t\t\t\t\tstrDate2 = tCollectionTemp.nodeName.toLowerCase() === "time" ?\n\t\t\t\t\t\ttCollectionTemp.getAttribute( "datetime" ).substr( 0, 10 ).split( "-" ) :\n\t\t\t\t\t\ttCollectionTemp.className.match( dateTimeRegExp )[ 1 ].substr( 0, 10 ).split( "-" );\n\n\t\t\t\t\t// Convert to zero-based month\n\t\t\t\t\tstrDate2[ 1 ] = strDate2[ 1 ] - 1;\n\n\t\t\t\t\tzLen += daysBetween( strDate1, strDate2 );\n\t\t\t\t}\n\n\t\t\t\t// Now loop in events to load up all the days that it would be on tomorrow.setDate(tomorrow.getDate() + 1);\n\t\t\t\tfor ( z = 0; z !== zLen; z += 1 ) {\n\t\t\t\t\tif ( z !== 0 ) {\n\t\t\t\t\t\tdate = new Date( date.setDate( date.getDate() + 1 ) );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( events.minDate === null || date < events.minDate ) {\n\t\t\t\t\t\tevents.minDate = date;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( events.maxDate === null || date > events.maxDate ) {\n\t\t\t\t\t\tevents.maxDate = date;\n\t\t\t\t\t}\n\n\t\t\t\t\tevents.list[ events.iCount ] = {\n\t\t\t\t\t\ttitle: title,\n\t\t\t\t\t\tdate: new Date( date.getTime() ),\n\t\t\t\t\t\thref: href,\n\t\t\t\t\t\ttarget: target\n\t\t\t\t\t};\n\n\t\t\t\t\t// Add a viewfilter\n\t\t\t\t\tdateClass = "filter-" + ( date.getFullYear() ) + "-" +\n\t\t\t\t\t\twb.string.pad( date.getMonth() + 1, 2 );\n\t\t\t\t\tif ( !className ) {\n\t\t\t\t\t\tclassName = dateClass;\n\t\t\t\t\t} else if ( className.indexOf( dateClass ) === -1 ) {\n\t\t\t\t\t\tclassName += " " + dateClass;\n\t\t\t\t\t}\n\t\t\t\t\tevents.iCount += 1;\n\t\t\t\t}\n\t\t\t\t$objTitle.attr( "class", className );\n\t\t\t}\n\n\t\t// End of loop through objects/events\n\t\t}\n\n\t\t//Sort events\n\t\tevents.list.sort( function( firstEvent, secondEvent ) {\n\t\t\treturn firstEvent.date - secondEvent.date;\n\t\t} );\n\n\t\treturn events;\n\t},\n\n\taddEvents = function( year, month, $days ) {\n\t\tvar eventsList = this.events,\n\t\t\ti, eLen, date, dayIndex, $day, $dayEvents, event, eventMonth;\n\n\t\t// Fix required to make up with the IE z-index behaviour mismatch\n\t\t// TODO: Move ot IE CSS? Which versions of IE should this fix be limited to?\n\t\tif ( wb.ie ) {\n\t\t\tfor ( i = 0, eLen = $days.length; i !== eLen; i += 1 ) {\n\t\t\t\t$days.eq( i ).css( "z-index", 31 - i );\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Determines for each event, if it occurs in the display month\n\t\t */\n\t\tfor ( i = 0, eLen = eventsList.length; i !== eLen; i += 1 ) {\n\t\t\tevent = eventsList[ i ];\n\t\t\tdate = event.date;\n\n\t\t\tif ( date.getFullYear() === year ) {\n\t\t\t\teventMonth = date.getMonth();\n\t\t\t\tif ( eventMonth > month ) {\n\n\t\t\t\t\t//End the loop if the next event is in a future month because events are sorted chronologically\n\t\t\t\t\tbreak;\n\t\t\t\t} else if ( date.getMonth() === month ) {\n\t\t\t\t\tdayIndex = date.getDate() - 1;\n\t\t\t\t\t$day = $( $days[ dayIndex ] );\n\n\t\t\t\t\t//Get the appropriate day events if a day link exists\n\t\t\t\t\tif ( $day.parent().get( 0 ).nodeName !== "A" ) {\n\t\t\t\t\t\t$dayEvents = $day.next();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$dayEvents = $day.parent().next();\n\t\t\t\t\t}\n\n\t\t\t\t\t//Create the event list container if it doesn\'t exist\n\t\t\t\t\tif ( $dayEvents.length !== 1 ) {\n\t\t\t\t\t\t$dayEvents = $( "<ul></ul>" ).insertAfter( $day );\n\n\t\t\t\t\t\t//Determine the focus based on the day before\n\t\t\t\t\t\tif ( dayIndex && $days[ dayIndex - 1 ].parentNode.nodeName === "A" ) {\n\t\t\t\t\t\t\t$day.wrap( "<a href=\'javascript:;\' class=\'cal-evt\' tabindex=\'-1\'></a>" );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$day.wrap( "<a href=\'javascript:;\' class=\'cal-evt\'></a>" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//Add the event to the list\n\t\t\t\t\t$dayEvents.append( "<li><a tabindex=\'-1\' class=\'cal-evt-lnk\' href=\'" + event.href + "\'>" + event.title + "</a></li>" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tfilterEvents = function( year, month ) {\n\t\tthis.find( "li.cal-disp-onshow" )\n\t\t\t.addClass( "wb-inv" )\n\t\t\t.has( ":header[class*=filter-" + year + "-" +\n\t\t\t\twb.string.pad( parseInt( month, 10 ) + 1, 2 ) + "]" )\n\t\t\t.removeClass( "wb-inv" );\n\t},\n\n\tshowEvents = function() {\n\t\t$( this )\n\t\t\t.next()\n\t\t\t.addClass( evDetails );\n\t},\n\n\thideEvents = function() {\n\t\tvar $link = $( this ),\n\t\t\t$cell = $link.closest( "td" );\n\n\t\tsetTimeout( function() {\n\t\t\tif ( $cell.find( "a:focus" ).length === 0 ) {\n\t\t\t\t$cell.find( "ul" )\n\t\t\t\t\t.removeClass( evDetails )\n\t\t\t\t\t.find( "a" )\n\t\t\t\t\t.attr( "tabindex", "-1" );\n\t\t\t}\n\t\t}, 5 );\n\t};\n\n// Bind the init event of the plugin\n$document.on( "timerpoke.wb " + initEvent, selector, init );\n\n$document.on( "wb-navigate.wb-clndr", ".wb-calevt-cal", function( event ) {\n\tvar lib = event.target.lib,\n\t\t$calEvent;\n\n\tif ( lib ) {\n\t\t$calEvent = lib.$events;\n\n\t\tif ( $calEvent ) {\n\t\t\tfilterEvents.call( $calEvent, event.year, event.month );\n\n\t\t\t//TODO: Added for backwards compatibility. Remove in previous versions\n\t\t\t$calEvent.trigger( "wb-updated" + selector );\n\t\t}\n\t}\n} );\n\n$document.on( "focusin focusout keydown", ".wb-calevt-cal .cal-days td > a", function( event ) {\n\tvar eventType = event.type,\n\t\t$link;\n\n\tswitch ( eventType ) {\n\tcase "focusin":\n\t\tshowEvents.call( event.target );\n\t\tbreak;\n\tcase "focusout":\n\t\thideEvents.call( event.target );\n\t\tbreak;\n\tcase "keydown":\n\t\t$link = $( event.target );\n\t\tif ( ( event.which === 13 || event.which === 32 ) && $link.hasClass( "cal-evt" ) ) {\n\t\t\t$( event.target ).next().find( "a:first" ).trigger( setFocusEvent );\n\t\t}\n\t\tbreak;\n\t}\n} );\n\n$document.on( "keydown", ".wb-calevt-cal .cal-days td > ul li", function( event ) {\n\tvar $item = $( event.currentTarget ),\n\t\t$toFocus, $itemParent;\n\n\tswitch ( event.which ) {\n\tcase 38:\n\t\t$toFocus = $item.prev().find( "a" );\n\t\tif ( $toFocus.length === 0 ) {\n\t\t\t$toFocus = $item.siblings( ":last" ).find( "a" );\n\t\t}\n\t\t$toFocus.trigger( setFocusEvent );\n\t\tbreak;\n\tcase 40:\n\t\t$toFocus = $item.next().find( "a" );\n\t\tif ( $toFocus.length === 0 ) {\n\t\t\t$toFocus = $item.siblings( ":first" ).find( "a" );\n\t\t}\n\t\t$toFocus.trigger( setFocusEvent );\n\t\tbreak;\n\tcase 27:\n\t\t$itemParent = $item.closest( "td" ).children( "a" );\n\t\t$itemParent.trigger( setFocusEvent );\n\t\tbreak;\n\t}\n} );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, wb );\n\n( function( $, window, document, wb, undef ) {\n\nvar i18nText,\n\t$document = wb.doc,\n\tselector = ".wb-clndr",\n\tnavigateEvent = "wb-navigate" + selector,\n\tinited = false,\n\tcurrDate = new Date(),\n\tcurrYear = currDate.getFullYear(),\n\tcurrMonth = currDate.getMonth(),\n\tdefaults = {\n\t\tyear: currYear,\n\t\tmonth: currMonth,\n\t\tminDate: new Date( currYear, 0, 1 ),\n\t\tmaxDate: new Date( currYear, 11, 31 )\n\t},\n\t$calBase,\n\n\tinit = function() {\n\t\tvar i18n = wb.i18n,\n\t\t\ttextWeekDayNames, textMonthNames;\n\n\t\ti18nText = {\n\t\t\tmonthNames: i18n( "mnths" ),\n\t\t\tprevMonth: i18n( "prvMnth" ),\n\t\t\tnextMonth: i18n( "nxtMnth" ),\n\t\t\tgoToYear: i18n( "cal-goToYr" ),\n\t\t\tgoToMonth: i18n( "cal-goToMnth" ),\n\t\t\tdayNames: i18n( "days" ),\n\t\t\tcurrDay: i18n( "currDay" ),\n\t\t\tformat: i18n( "cal-format" )\n\t\t};\n\n\t\ttextWeekDayNames = i18nText.dayNames;\n\t\ttextMonthNames = i18nText.monthNames;\n\n\t\t$calBase = $( "<div class=\'wb-clndr\' role=\'application\'>" +\n\t\t\t"<div class=\'cal-nav\'>" +\n\t\t\t\t"<button type=\'button\' class=\'btn pull-left cal-month-prev\'>" +\n\t\t\t\t\t"<span class=\'glyphicon glyphicon-arrow-left\'></span>" +\n\t\t\t\t\t"<span class=\'wb-inv\'>" + i18nText.prevMonth + "<span></span></span>" +\n\t\t\t\t"</button>" +\n\t\t\t\t"<button type=\'button\' class=\'btn pull-right cal-month-next\'>" +\n\t\t\t\t\t"<span class=\'glyphicon glyphicon-arrow-right\'></span>" +\n\t\t\t\t\t"<span class=\'wb-inv\'>" + i18nText.nextMonth + "<span></span></span>" +\n\t\t\t\t"</button>" +\n\t\t\t\t"<div class=\'form-group\'>" +\n\t\t\t\t\t"<select title=\'" + i18nText.goToYear + "\' class=\'cal-year\'></select>\\n" +\n\t\t\t\t\t"<select title=\'" + i18nText.goToMonth + "\' class=\'cal-month\'>" +\n\t\t\t\t\t\t( function() {\n\t\t\t\t\t\t\tvar months = "",\n\t\t\t\t\t\t\t\tm;\n\n\t\t\t\t\t\t\tfor ( m = 0; m < 12; m += 1 ) {\n\t\t\t\t\t\t\t\tmonths += "<option value=\'" + m + "\'>" + textMonthNames[ m ] + "</option>";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn months;\n\t\t\t\t\t\t} )() +\n\t\t\t\t\t"</select>" +\n\t\t\t\t"</div>" +\n\t\t\t"</div>" +\n\t\t\t"<table>" +\n\t\t\t\t"<thead role=\'presentation\'>" +\n\t\t\t\t\t"<tr>" +\n\t\t\t\t\t\t( function() {\n\t\t\t\t\t\t\tvar days = "",\n\t\t\t\t\t\t\t\td;\n\n\t\t\t\t\t\t\tfor ( d = 0; d < 7; d += 1 ) {\n\t\t\t\t\t\t\t\tdays += "<th role=\'columnheader\'><abbr title=\'" + textWeekDayNames[ d ] + "\'>" + textWeekDayNames[ d ].substr( 0, 1 ) + "</abbr></th>";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn days;\n\t\t\t\t\t\t} )() +\n\t\t\t\t\t"</tr>" +\n\t\t\t\t"</thead>" +\n\t\t\t\t"<tbody class=\'cal-days\'></tbody>" +\n\t\t\t"</table>" +\n\t\t"</div>" );\n\n\t\tinited = true;\n\t},\n\n\tcreateCalendar = function( $container, settings ) {\n\t\tvar calendar = {\n\t\t\t\treInit: initCalendar\n\t\t\t}, $calendarObj, calendarObj;\n\n\t\tif ( !inited ) {\n\t\t\tinit();\n\t\t}\n\n\t\t$calendarObj = $calBase.clone();\n\t\tcalendarObj = $calendarObj.get( 0 );\n\n\t\tcalendar.$o = $calendarObj;\n\t\tcalendar.o = calendarObj;\n\t\tcalendarObj.lib = calendar;\n\n\t\t$calendarObj.appendTo( $container );\n\n\t\tcalendar.reInit( settings );\n\n\t\treturn calendar;\n\t},\n\n\tinitCalendar = function( settings ) {\n\t\tvar years = "",\n\t\t\t$calendarObj = this.$o,\n\t\t\t$yearField, lastYear, y, defaultsPartial;\n\n\t\tsettings = settings || {};\n\n\t\tif ( settings.year !== undef && settings.month !== undef ) {\n\t\t\tdefaultsPartial = {\n\t\t\t\tminDate: new Date( settings.year, 0, 1 ),\n\t\t\t\tmaxDate: new Date( settings.year, 11, 31 )\n\t\t\t};\n\t\t\t$.extend( this, defaultsPartial, settings );\n\t\t} else {\n\t\t\t$.extend( this, defaults );\n\t\t}\n\n\t\t//Generates the list of years\n\t\tlastYear = this.maxDate.getFullYear();\n\t\t$yearField = $calendarObj.find( ".cal-year" ).empty();\n\t\tfor ( y = this.minDate.getFullYear(); y <= lastYear; y += 1 ) {\n\t\t\tyears += "<option value=\'" + y + "\'>" + y + "</option>";\n\t\t}\n\t\t$yearField.append( years );\n\n\t\t$calendarObj\n\t\t\t.trigger( {\n\t\t\t\ttype: navigateEvent,\n\t\t\t\tyear: this.year,\n\t\t\t\tmonth: this.month\n\t\t\t} );\n\t},\n\n\tcreateDays = function( calendar, year, month ) {\n\t\tvar $container = $( calendar ).find( ".cal-days" ),\n\t\t\tdayCount = 1,\n\t\t\ttextCurrentDay = i18nText.currDay,\n\t\t\tlib = calendar.lib,\n\t\t\tminDate = lib.minDate,\n\t\t\tmaxDate = lib.maxDate,\n\t\t\tcallback = lib.daysCallback,\n\t\t\tcells = "",\n\t\t\tdate, firstDay, lastDay, currYear, currMonth, currDay, week, day, className, isCurrentDate, isoDate, printDate, breakAtEnd, days, inRange;\n\n\t\tdate = new Date( year, month, 1 );\n\n\t\tfirstDay = date.getDay();\n\t\tdate.setMonth( month + 1, 0 );\n\t\tlastDay = date.getDate();\n\n\t\t// Get the current date\n\t\tdate = new Date();\n\t\tcurrYear = date.getFullYear();\n\t\tcurrMonth = date.getMonth();\n\t\tcurrDay = date.getDate();\n\n\t\tfor ( week = 1; week < 7; week += 1 ) {\n\t\t\tcells += "<tr>";\n\t\t\tfor ( day = 0; day < 7; day += 1 ) {\n\n\t\t\t\tif ( ( week === 1 && day < firstDay ) || ( dayCount > lastDay ) ) {\n\n\t\t\t\t\t// Creates empty cells | Cree les cellules vides\n\t\t\t\t\tcells += "<td class=\'cal-empty\'>&#160;</td>";\n\t\t\t\t} else {\n\n\t\t\t\t\t// Creates date cells | Cree les cellules de date\n\t\t\t\t\tisCurrentDate = ( dayCount === currDay && month === currMonth && year === currYear );\n\t\t\t\t\tclassName = "cal-index-" + dayCount + ( isCurrentDate ? " cal-curr-day " : "" );\n\n\t\t\t\t\tdate.setFullYear( year, month, dayCount );\n\t\t\t\t\tisoDate = date.toLocalISOString().substr( 0, 10 );\n\t\t\t\t\tprintDate = displayDate( date ) + ( isCurrentDate ? "<span class=\'wb-inv\'>" + textCurrentDay + "</span>" : "" );\n\n\t\t\t\t\tcells += "<td class=\'" + className + "\'><time datetime=\'" + isoDate  + "\'>" + printDate + "</time></td>";\n\n\t\t\t\t\tif ( dayCount >= lastDay ) {\n\t\t\t\t\t\tbreakAtEnd = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tdayCount += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcells += "</tr>";\n\t\t\tif ( breakAtEnd ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t$container.empty().append( cells );\n\n\t\tif ( callback ) {\n\t\t\tdays = $container.find( "time" );\n\t\t\tinRange = {};\n\n\t\t\tif ( year === minDate.getFullYear() && month === minDate.getMonth() ) {\n\t\t\t\tinRange.min = minDate.getDate() - 1;\n\t\t\t}\n\n\t\t\tif ( year === maxDate.getFullYear() && month === maxDate.getMonth() ) {\n\t\t\t\tinRange.max = maxDate.getDate() - 1;\n\t\t\t}\n\n\t\t\tcallback.call( calendar.lib, year, month, days, inRange );\n\t\t}\n\t},\n\n\tdisplayDate = function( date ) {\n\t\tvar textWeekDayNames = i18nText.dayNames,\n\t\t\ttextMonthNames = i18nText.monthNames;\n\n\t\treturn i18nText.format.replace( /\\{ddd\\}|\\{d\\}|\\{M\\}|\\{Y\\}/g, function( match ) {\n\t\t\tswitch ( match ) {\n\t\t\tcase "{ddd}":\n\t\t\t\treturn textWeekDayNames[ parseInt( date.getDay(), 10 ) ];\n\t\t\tcase "{d}":\n\t\t\t\treturn parseInt( date.getDate(), 10 );\n\t\t\tcase "{M}":\n\t\t\t\treturn textMonthNames[ parseInt( date.getMonth(), 10 ) ];\n\t\t\tcase "{Y}":\n\t\t\t\treturn date.getFullYear();\n\t\t\t}\n\t\t} );\n\t};\n\nwb.calendar = {\n\tcreate: createCalendar\n};\n\n$document.on( navigateEvent, selector, function( event ) {\n\tvar calendarObj = event.currentTarget,\n\t\t$calendar = $( calendarObj ),\n\t\tyear = event.year,\n\t\tmonth = event.month,\n\t\tlib = calendarObj.lib,\n\t\tmaxYear = lib.maxDate.getFullYear(),\n\t\tmaxMonth = lib.maxDate.getMonth(),\n\t\tminYear = lib.minDate.getFullYear(),\n\t\tminMonth = lib.minDate.getMonth(),\n\t\t$prevArrow = $calendar.find( ".cal-month-prev" ),\n\t\t$nextArrow = $calendar.find( ".cal-month-next" ),\n\t\t$monthField = $calendar.find( ".cal-month" ),\n\t\tdisabled = "disabled";\n\n\tif ( year !== undef ) {\n\t\tlib.year = year;\n\t}\n\n\tif ( month !== undef ) {\n\t\tlib.month = month;\n\t}\n\n\t//Update UI\n\t$calendar.find( ".cal-year" ).val( year );\n\n\t$monthField.val( month );\n\n\t$monthField.children( ":" + disabled ).removeAttr( disabled );\n\n\tif ( year < minYear || ( year === minYear && month <= minMonth ) ) {\n\t\t$prevArrow.attr( disabled, disabled );\n\t} else {\n\t\t$prevArrow.removeAttr( disabled );\n\t}\n\n\tif ( year > maxYear || ( year === maxYear && month >= maxMonth ) ) {\n\t\t$nextArrow.attr( disabled, disabled );\n\t} else {\n\t\t$nextArrow.removeAttr( disabled );\n\t}\n\n\tif ( year === minYear ) {\n\t\t$monthField.children( ":lt(" + minMonth + ")" ).attr( disabled, disabled );\n\t}\n\n\tif ( year === maxYear ) {\n\t\t$monthField.children( ":gt(" + maxMonth + ")" ).attr( disabled, disabled );\n\t}\n\n\tcreateDays( event.currentTarget, event.year, event.month );\n} );\n\n$document.on( "change", selector, function( event ) {\n\tvar target = event.target,\n\t\tcalendar = event.currentTarget,\n\t\tyear, month;\n\n\tswitch ( target.className ) {\n\tcase "cal-year":\n\t\tyear = parseInt( target.value, 10 );\n\t\tmonth = calendar.lib.month;\n\t\tbreak;\n\tcase "cal-month":\n\t\tyear = calendar.lib.year;\n\t\tmonth = parseInt( target.value, 10 );\n\t\tbreak;\n\t}\n\n\t$( calendar ).trigger( {\n\t\ttype: navigateEvent,\n\t\tyear: year,\n\t\tmonth: month\n\t} );\n} );\n\n$document.on( "click vclick touchstart", ".cal-month-prev, .cal-month-next", function( event ) {\n\tvar $calendar = $( event.currentTarget ).closest( selector ),\n\t\tcalendar = $calendar.get( 0 ),\n\t\tclassName = event.currentTarget.className,\n\t\tmodifier = className.indexOf( "cal-month-prev" ) !== -1 ? -1 : 1,\n\t\tdate = new Date( calendar.lib.year, calendar.lib.month + modifier, 1 );\n\n\t$calendar.trigger( {\n\t\ttype: navigateEvent,\n\t\tyear: date.getFullYear(),\n\t\tmonth: date.getMonth()\n\t} );\n\tif ( wb.ie11 ) {\n\t\t$calendar.trigger( "focusin" );\n\t}\n} );\n\n$document.on( "keydown", selector, function( event ) {\n\tvar calendar = event.currentTarget,\n\t\t$days = $( event.currentTarget ).find( ".cal-days" ),\n\t\ttarget = event.target,\n\t\twhich = event.which,\n\t\tlib = calendar.lib,\n\t\tdate = new Date( lib.year, lib.month, 1 ),\n\t\tminDate = lib.minDate,\n\t\tmaxDate = lib.maxDate,\n\t\tcurrentDate = new Date( date ),\n\t\tnavigate = true,\n\t\tclassMatch, isDayLink, lastDay, modifier, day;\n\n\tif ( !event.altKey && !event.metaKey && which > 32 && which < 41 ) {\n\n\t\tclassMatch = target.parentNode.className.match( /cal-index-(\\d{1,2})/ );\n\t\tisDayLink = classMatch !== null;\n\n\t\t//Key binding for the entire calendar\n\t\tswitch ( which ) {\n\n\t\t//page up\n\t\tcase 33:\n\t\t\tdate.setDate( minDate.getDate() );\n\n\t\t\t/* falls through */\n\n\t\t//page down\n\t\tcase 34:\n\t\t\tmodifier = ( which === 33 ? -1 : 1 );\n\n\t\t\tif ( event.ctrlKey || event.shiftKey || event.altKey ) {\n\t\t\t\tdate.setYear( date.getFullYear() + modifier );\n\t\t\t} else {\n\t\t\t\tdate.setMonth( date.getMonth() + modifier );\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t//Key binding for navigating calendar days\n\t\tif ( isDayLink ) {\n\t\t\tday = parseInt( classMatch[ 1 ], 10 );\n\t\t\tdate.setMonth( date.getMonth() + 1, 0 );\n\t\t\tlastDay = date.getDate();\n\t\t\tdate.setDate( day > lastDay ? lastDay : day );\n\n\t\t\tswitch ( which ) {\n\n\t\t\t// end / home\n\t\t\tcase 35:\n\t\t\t\tdate.setDate( lastDay );\n\t\t\t\tbreak;\n\t\t\tcase 36:\n\t\t\t\tdate.setDate( 1 );\n\t\t\t\tbreak;\n\n\t\t\t// left / up / right / down arrows\n\t\t\tcase 37:\n\t\t\t\tdate.setDate( day - 1 );\n\t\t\t\tbreak;\n\t\t\tcase 38:\n\t\t\t\tdate.setDate( day - 7 );\n\t\t\t\tbreak;\n\t\t\tcase 39:\n\t\t\t\tdate.setDate( day + 1 );\n\t\t\t\tbreak;\n\t\t\tcase 40:\n\t\t\t\tdate.setDate( day + 7 );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ( date < minDate || date > maxDate ) {\n\t\t\tif ( which === 35 ) {\n\t\t\t\tdate.setDate( maxDate.getDate() );\n\t\t\t} else if ( which === 36 ) {\n\t\t\t\tdate = minDate;\n\t\t\t} else {\n\t\t\t\tnavigate = false;\n\t\t\t}\n\t\t}\n\n\t\tif ( navigate && ( date.getMonth() !== currentDate.getMonth() || date.getFullYear() !== currentDate.getFullYear() ) ) {\n\t\t\t$( calendar ).trigger( {\n\t\t\t\ttype: navigateEvent,\n\t\t\t\tyear: date.getFullYear(),\n\t\t\t\tmonth: date.getMonth()\n\t\t\t} );\n\t\t}\n\n\t\tif ( isDayLink ) {\n\t\t\t$days.find( ".cal-index-" + date.getDate() + " a:first" ).focus();\n\t\t}\n\n\t\tevent.preventDefault();\n\t\treturn false;\n\t}\n\n} );\n\n( function() {\n\n\tfunction pad( number ) {\n\t\tif ( number < 10 ) {\n\t\t\treturn "0" + number;\n\t\t}\n\t\treturn number;\n\t}\n\n\tDate.prototype.toLocalISOString = function() {\n\t\tvar tz = this.getTimezoneOffset();\n\t\tif ( tz === 0 ) {\n\t\t\treturn this.toISOString();\n\t\t}\n\t\treturn this.getFullYear() +\n\t\t\t"-" + pad( this.getMonth() + 1 ) +\n\t\t\t"-" + pad( this.getDate() ) +\n\t\t\t"T" + pad( this.getHours() ) +\n\t\t\t":" + pad( this.getMinutes() ) +\n\t\t\t":" + pad( this.getSeconds() ) +\n\t\t\t"." + ( this.getMilliseconds() / 1000 ).toFixed( 3 ).slice( 2, 5 ) +\n\t\t\t( tz < 0 ? "+" : "-" ) +\n\t\t\tpad( Math.floor( Math.abs( tz / 60 ) ) ) +\n\t\t\t":" + pad( tz % 60 );\n\t};\n\n\tif ( !Date.prototype.toISOString ) {\n\t\tDate.prototype.toISOString = function() {\n\t\t\treturn this.getUTCFullYear() +\n\t\t\t\t"-" + pad( this.getUTCMonth() + 1 ) +\n\t\t\t\t"-" + pad( this.getUTCDate() ) +\n\t\t\t\t"T" + pad( this.getUTCHours() ) +\n\t\t\t\t":" + pad( this.getUTCMinutes() ) +\n\t\t\t\t":" + pad( this.getUTCSeconds() ) +\n\t\t\t\t"." + ( this.getUTCMilliseconds() / 1000 ).toFixed( 3 ).slice( 2, 5 ) +\n\t\t\t\t"Z";\n\t\t};\n\t}\n}() );\n\n} )( jQuery, window, document, wb );\n\n/**\n * Web Experience Toolkit (WET) / Boîte à outils de l\'expérience Web (BOEW)\n * @title Charts and Graph\n * @overview Draw charts from an html simple and complex data table\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @duboisp\n *\n */\n( function( $, window, document, wb ) {\n"use strict";\n\n/**\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-charts",\n\tselector = "." + componentName,\n\tinitEvent = "wb-init" + selector,\n\ttableParsingEvent = "passiveparse.wb-tableparser",\n\ttableParsingCompleteEvent = "parsecomplete.wb-tableparser",\n\t$document = wb.doc,\n\ti18n, i18nText,\n\n\t/**\n\t * Main Entry function to create the charts\n\t * @method createCharts\n\t * @param {jQuery DOM element} $elm table element use to create the chart\n\t */\n\tcreateCharts = function( $elm ) {\n\t\tvar allSeries = [],\n\t\t\tchartslabels = [],\n\t\t\tdataSeries = [],\n\t\t\tnbBarChart = 0,\n\t\t\t$caption = $( "caption", $elm ),\n\t\t\tcaptionHtml = $caption.html() || "",\n\t\t\tcaptionText = $caption.text() || "",\n\t\t\tvaluePoint = 0,\n\t\t\tdataCellUnitRegExp = /[^\\+\\-\\.\\, 0-9]+[^\\-\\+0-9]*/,\n\t\t\tlowestFlotDelta, $imgContainer, $placeHolder,\n\t\t\t$wetChartContainer, htmlPlaceHolder, figurehtml,\n\t\t\tcellValue, datacolgroupfound, dataGroup, header,\n\t\t\ti, iLength, j, jLength, parsedData, rIndex, currVectorOptions,\n\t\t\tcurrentRowGroup, reverseTblParsing, dataGroupVector,\n\t\t\tcurrentDataGroupVector, dataCell, previousDataCell, currDataVector,\n\t\t\tpieQuaterFlotSeries, optionFlot, optionsCharts, globalOptions,\n\t\t\tdefaultsOptions = {\n\n\t\t\t\t// Flot Global Options\n\t\t\t\tflot: {\n\t\t\t\t\tprefix: "wb-charts-",\n\t\t\t\t\tdefaults: {\n\t\t\t\t\t\tcolors: wb.drawColours,\n\t\t\t\t\t\tcanvas: true,\n\t\t\t\t\t\txaxis: {\n\t\t\t\t\t\t\tticks: { }\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tline: { },\n\t\t\t\t\tarea: {\n\t\t\t\t\t\tlines: {\n\t\t\t\t\t\t\tshow: true,\n\t\t\t\t\t\t\tfill: true\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tbar: {\n\t\t\t\t\t\tbars: {\n\t\t\t\t\t\t\tshow: true,\n\t\t\t\t\t\t\tbarWidth: 1,\n\t\t\t\t\t\t\talign: "center"\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tpie: {\n\t\t\t\t\t\tseries: {\n\t\t\t\t\t\t\tpie: {\n\t\t\t\t\t\t\t\tshow: true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfn: {\n\t\t\t\t\t\t\t"/series/pie/label/formatter": function( label, series ) {\n\t\t\t\t\t\t\t\tvar textlabel;\n\t\t\t\t\t\t\t\tif ( !optionsCharts.decimal ) {\n\t\t\t\t\t\t\t\t\ttextlabel = Math.round( series.percent );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttextlabel = Math.round( series.percent * Math.pow( 10, optionsCharts.decimal ) );\n\t\t\t\t\t\t\t\t\ttextlabel = textlabel / Math.pow( 10, optionsCharts.decimal );\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( optionsCharts.nolegend ) {\n\n\t\t\t\t\t\t\t\t\t// Add the series label\n\t\t\t\t\t\t\t\t\ttextlabel = label + "<br />" + textlabel;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn textlabel + "%";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tdonut: {\n\t\t\t\t\t\tbase: "pie",\n\t\t\t\t\t\tseries: {\n\t\t\t\t\t\t\tpie: {\n\t\t\t\t\t\t\t\tradius: 1,\n\t\t\t\t\t\t\t\tlabel: {\n\t\t\t\t\t\t\t\t\tshow: true,\n\t\t\t\t\t\t\t\t\tradius: 1,\n\t\t\t\t\t\t\t\t\tthreshold: 0.08\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ttilt: 0.5,\n\t\t\t\t\t\t\t\tinnerRadius: 0.45,\n\t\t\t\t\t\t\t\tstartAngle: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tgrid: {\n\t\t\t\t\t\t\thoverable: true\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tslicelegend: {\n\t\t\t\t\t\tbase: "pie",\n\t\t\t\t\t\tseries: {\n\t\t\t\t\t\t\tpie: {\n\t\t\t\t\t\t\t\tradius: 1,\n\t\t\t\t\t\t\t\tlabel: {\n\t\t\t\t\t\t\t\t\tradius: 1,\n\t\t\t\t\t\t\t\t\tshow: true,\n\t\t\t\t\t\t\t\t\tthreshold: 0.05\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tcombine: {\n\t\t\t\t\t\t\t\t\tthreshold: 0.05,\n\t\t\t\t\t\t\t\t\tcolor: "#555",\n\t\t\t\t\t\t\t\t\tlabel: i18nText.slicelegend\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfn: {\n\t\t\t\t\t\t\t"/series/pie/label/formatter": function( label ) {\n\t\t\t\t\t\t\t\treturn label;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Flot Series Options\n\t\t\t\tseries: {\n\t\t\t\t\tprefix: "wb-charts-",\n\t\t\t\t\tdefaults: { },\n\t\t\t\t\tline: { },\n\t\t\t\t\tarea: {\n\t\t\t\t\t\tlines: {\n\t\t\t\t\t\t\tshow: true,\n\t\t\t\t\t\t\tfill: true\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tbar: {\n\t\t\t\t\t\tbars: {\n\t\t\t\t\t\t\tshow: true,\n\t\t\t\t\t\t\tbarWidth: 1,\n\t\t\t\t\t\t\talign: "center"\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tstacked: {\n\t\t\t\t\t\tbase: "bar"\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Wet-boew Charts Options\n\t\t\t\tcharts: {\n\t\t\t\t\tprefix: "wb-charts-",\n\t\t\t\t\tdefaults: {\n\n\t\t\t\t\t\t// [string] Class name added at the figure element container\n\t\t\t\t\t\tgraphclass: "wb-graph",\n\n\t\t\t\t\t\t// [boolean] Wrap or not the table in a details/summary elements\n\t\t\t\t\t\tnoencapsulation: false,\n\n\t\t\t\t\t\t// [number] false means the deepest vector will be used for labelling\n\t\t\t\t\t\tlabelposition: false,\n\n\t\t\t\t\t\t// [number] false means the deepest vector will be used for calculate the reference\n\t\t\t\t\t\treferencevalue: false,\n\n\t\t\t\t\t\t// [boolean] false means to move the legend from inside the charts to next to it\n\t\t\t\t\t\tlegendinline: false,\n\n\t\t\t\t\t\t// [boolean] true means that the legend will be destroyed and the label for pie chart will include the legend\n\t\t\t\t\t\tnolegend: false,\n\n\t\t\t\t\t\t// [number] Literal number of displayed decimal for a pie charts\n\t\t\t\t\t\tdecimal: 0,\n\n\t\t\t\t\t\t// [number] Provide a default width for the charts that will be rendered\n\t\t\t\t\t\twidth: $elm.width(),\n\n\t\t\t\t\t\t// [number] Provide a default height for the charts that will be rendered\n\t\t\t\t\t\theight: $elm.height(),\n\n\t\t\t\t\t\t// [boolean] Flag for defining if the data table should be read in reverse compared to HTML spec\n\t\t\t\t\t\treversettblparsing: false,\n\t\t\t\t\t\tfn: {\n\t\t\t\t\t\t\t"/getcellvalue": function( elem ) {\n\n\t\t\t\t\t\t\t\t// Get the number from the data cell, #3267\n\t\t\t\t\t\t\t\tvar cellValue = $.trim( elem.dataset.wbChartsValue || $( elem ).text() );\n\t\t\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t\t\tparseFloat( cellValue.replace( /(\\d{1,3}(?:(?: |,)\\d{3})*)(?:(?:.|,)(\\d{1,2}))?$/, function( a, b, c ) {\n\t\t\t\t\t\t\t\t\t\treturn b.replace( / |,/g, "" ) + "." + c || "0";\n\t\t\t\t\t\t\t\t\t} ), 10 ),\n\t\t\t\t\t\t\t\t\tcellValue.match( dataCellUnitRegExp )\n\t\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tdonut: {\n\t\t\t\t\t\tdecimal: 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t/**\n\t\t * A little function to overwrite and add preset into the default options\n\t\t *\n\t\t * @method overwriteDefaultsOptions\n\t\t * @param {string} scopekey - Key that represent the subject of the setting, [flot, charts, series,...]\n\t\t * @param {json object} target - DefaultOptions that will be overwritten\n\t\t * @param {json object} object - User defined object for overwriting options\n\t\t * @return {json object} - Return the new object\n\t\t */\n\t\tfunction overwriteDefaultsOptions( scopekey, target, object ) {\n\t\t\tvar cachedObj, key;\n\n\t\t\tcachedObj = object[ scopekey ];\n\t\t\tif ( !cachedObj ) {\n\t\t\t\treturn target;\n\t\t\t}\n\t\t\tfor ( key in cachedObj ) {\n\t\t\t\tif ( !cachedObj.hasOwnProperty( key ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttarget[ scopekey ][ key ] = cachedObj[ key ];\n\t\t\t}\n\t\t\treturn target;\n\t\t}\n\n\t\t// User defined options\n\t\tif ( !window.chartsGraphOpts ) {\n\t\t\tglobalOptions = window[ componentName ];\n\n\t\t\t// Global setting\n\t\t\tif ( globalOptions ) {\n\t\t\t\toverwriteDefaultsOptions( "flot", defaultsOptions, globalOptions );\n\t\t\t\toverwriteDefaultsOptions( "series", defaultsOptions, globalOptions );\n\t\t\t\toverwriteDefaultsOptions( "charts", defaultsOptions, globalOptions );\n\t\t\t}\n\n\t\t\t// Save the setting here in a case of a second graphic on the same page\n\t\t\twindow.chartsGraphOpts = defaultsOptions;\n\t\t}\n\t\tdefaultsOptions = window.chartsGraphOpts;\n\n\t\t/**\n\t\t * A little function to ease the web editor life\n\t\t *\n\t\t * Apply preset defined by a set of space-separated tokens from a baseline json object and at the same time extend the result by using the HTML5 data attribute\n\t\t *\n\t\t * @method applyPreset\n\t\t * @param {json object} baseline - Base line json object that includes predefined and userdefined preset\n\t\t * @param {jQuery} $elem - Element on which the class attribute will be taken for a set of space-separated tokens\n\t\t * @param {string} attribute - Name of the HTML5 data attribute for extending the object at the end\n\t\t * @return {json object} - Return a new object build from the ```baseline``` or ```baseline.default``` object with the preset applied.\n\t\t */\n\t\tfunction applyPreset( baseline, $elem, attribute ) {\n\n\t\t\tvar config = $.extend( true, {}, baseline.defaults || baseline ),\n\t\t\t\tfn = $.extend( true, {}, baseline.defaults && baseline.defaults.fn || { } ),\n\t\t\t\ttokens = $elem.attr( "class" ) || "",\n\t\t\t\ttblTokens, i, iLength, token, tokenLength,\n\n\t\t\t\t// Prefix used in front of the token\n\t\t\t\tprefix, prefixLength,\n\t\t\t\tpreset, key, tblFn, localKey, currObj;\n\n\t\t\tif ( tokens.length ) {\n\n\t\t\t\tprefix = ( baseline.prefix || "" );\n\t\t\t\tprefixLength = prefix.length;\n\n\t\t\t\t// split the set of space-separated tokens\n\t\t\t\ttblTokens = tokens.split( " " );\n\n\t\t\t\tfor ( i = 0, iLength = tblTokens.length; i !== iLength; i += 1 ) {\n\n\t\t\t\t\t// Get the current token\n\t\t\t\t\ttoken = tblTokens[ i ];\n\t\t\t\t\ttokenLength = token.length;\n\n\t\t\t\t\t// Remove the token is used\n\t\t\t\t\tif ( tokenLength <= prefixLength || token.slice( 0, prefixLength ) !== prefix ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\ttoken = token.slice( prefixLength, tokenLength );\n\n\t\t\t\t\tpreset = baseline[ token ];\n\n\t\t\t\t\t// Apply the preset\n\t\t\t\t\tif ( preset ) {\n\t\t\t\t\t\tif ( preset.base ) {\n\n\t\t\t\t\t\t\t// Like setting herited from a parent config\n\t\t\t\t\t\t\tconfig = $.extend( true, config, baseline[ preset.base ] );\n\t\t\t\t\t\t\tfn = $.extend( true, fn, baseline[ preset.base ].fn || { } );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconfig = $.extend( true, config, preset );\n\t\t\t\t\t\tfn = $.extend( true, fn, preset.fn || { } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Extend the config from the element @data attribute\n\t\t\tconfig = $.extend( true, config, wb.getData( $elem, attribute ) );\n\n\t\t\t// Merge and override the function.\n\t\t\tfor ( key in fn ) {\n\t\t\t\tif ( !fn.hasOwnProperty( key ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttblFn = key.split( "/" );\n\t\t\t\tcurrObj = config;\n\t\t\t\tfor ( i = 0, iLength = tblFn.length - 1; i !== iLength; i += 1 ) {\n\t\t\t\t\tlocalKey = tblFn.shift();\n\t\t\t\t\tif ( localKey === "" ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif ( !currObj[ localKey ] ) {\n\t\t\t\t\t\tcurrObj[ localKey ] = { };\n\t\t\t\t\t}\n\t\t\t\t\tcurrObj = currObj[ localKey ];\n\t\t\t\t}\n\t\t\t\tlocalKey = tblFn.shift();\n\t\t\t\tcurrObj[ localKey ] = fn[ key ];\n\t\t\t}\n\t\t\treturn config;\n\t\t}\n\n\t\t// Apply any preset\n\t\toptionFlot = applyPreset( defaultsOptions.flot, $elm, "flot" );\n\n\t\t// Apply any preset\n\t\toptionsCharts = applyPreset( defaultsOptions.charts, $elm, componentName );\n\n\t\t// Fix default width and height in case the table is hidden or too small.\n\t\toptionsCharts.width = ( optionsCharts.width && optionsCharts.width > 250 ? optionsCharts.width : 250 );\n\t\toptionsCharts.height = ( optionsCharts.height && optionsCharts.height > 250 ? optionsCharts.height : 250 );\n\n\t\t/**\n\t\t * @method getColumnGroupHeaderCalculateSteps\n\t\t * @param {object} colGroupHead - Column Group Header Object from the table parser\n\t\t * @param {number} referenceValuePosition - Vector position use as reference for defining the steps, zero based position\n\t\t */\n\t\tfunction getColumnGroupHeaderCalculateSteps( colGroupHead, referenceValuePosition ) {\n\n\t\t\t// Get the appropriate ticks\n\t\t\tvar headerCell, i, iLen,\n\t\t\t\tcalcStep = 1,\n\t\t\t\tcolRefValue, colCurent;\n\n\t\t\tif ( !colGroupHead ) {\n\n\t\t\t\t// There is an error. Possibly the series are missing a header.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcolRefValue = colGroupHead.col[ referenceValuePosition ];\n\t\t\tcolCurent = colGroupHead.col[ 0 ];\n\n\t\t\tfor ( i = 0, iLen = colRefValue.cell.length; i !== iLen; i += 1 ) {\n\n\t\t\t\theaderCell = colRefValue.cell[ i ];\n\n\t\t\t\tif ( i === 0 || ( i > 0 && colCurent.cell[ i - 1 ].uid !== headerCell.uid ) ) {\n\n\t\t\t\t\tif ( headerCell.rowgroup && headerCell.rowgroup.type === 3 ) {\n\n\t\t\t\t\t\t// We only process the first column data group\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( headerCell.type === 1 || headerCell.type === 7 ) {\n\t\t\t\t\t\tif ( headerCell.child.length !== 0 ) {\n\t\t\t\t\t\t\tcalcStep = calcStep * groupHeaderCalculateStepsRecursive( headerCell, 1 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn calcStep;\n\t\t}\n\n\t\t/**\n\t\t * @method getRowGroupHeaderCalculateSteps\n\t\t * @param {object} rowGroupHead - Row Group Header Object from the table parser\n\t\t * @param {number} referenceValuePosition - Vector position use as reference for defining the steps, zero based position\n\t\t * @param {number} dataColgroupStart - Column position where the column data group start\n\t\t */\n\t\tfunction getRowGroupHeaderCalculateSteps( rowGroupHead, referenceValuePosition, dataColgroupStart ) {\n\n\t\t\t// Find the range of the first data colgroup\n\t\t\tvar headerCell, i, iLen,\n\t\t\t\tcalcStep = 1,\n\t\t\t\trowRefValueCells = rowGroupHead[ referenceValuePosition ].elem.cells;\n\n\t\t\tfor ( i = 0, iLen = rowRefValueCells.length; i !== iLen; i += 1 ) {\n\n\t\t\t\theaderCell = $( rowRefValueCells[ i ] ).data().tblparser;\n\n\t\t\t\tif ( headerCell.colgroup && headerCell.colgroup.type === 3 ) {\n\n\t\t\t\t\t// We only process the first column data group\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( headerCell.colpos >= dataColgroupStart && ( headerCell.type === 1 || headerCell.type === 7 ) ) {\n\t\t\t\t\tif ( headerCell.child.length !== 0 ) {\n\t\t\t\t\t\tcalcStep = calcStep * headerCell.child.length * groupHeaderCalculateStepsRecursive( headerCell, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn calcStep;\n\t\t}\n\n\t\t/**\n\t\t * @method groupHeaderCalculateStepsRecursive\n\t\t * @param {object} headerCell - Header cell object from the table parser\n\t\t * @param {number} refValue - Reference Value (Dénominateur) of headerCell\n\t\t */\n\t\tfunction groupHeaderCalculateStepsRecursive( headerCell, refValue ) {\n\t\t\tvar childLength = headerCell.child.length,\n\t\t\t\tcalcStep = 1,\n\t\t\t\tkIndex, subRefValue, headerCellChild;\n\n\t\t\tif ( childLength === 0 ) {\n\t\t\t\treturn calcStep;\n\t\t\t}\n\n\t\t\tsubRefValue = childLength * refValue;\n\n\t\t\tcalcStep = calcStep * subRefValue;\n\n\t\t\tfor ( kIndex = 0; kIndex !== childLength; kIndex += 1 ) {\n\t\t\t\theaderCellChild = headerCell.child[ kIndex ];\n\t\t\t\tif ( headerCellChild.child.length !== 0 ) {\n\t\t\t\t\tcalcStep = calcStep * groupHeaderCalculateStepsRecursive( headerCellChild, subRefValue );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn calcStep;\n\t\t}\n\n\t\t/**\n\t\t * Set the inner step value (divisor) of an header cell and for his child\n\t\t *\n\t\t * @method setInnerStepValues\n\t\t * @param {object} vectorHead - Group Header Object from the table parser\n\t\t * @param {number} headerLevel - Hiearchical Level of heading\n\t\t * @param {number} stepsValue - Step Value for the reference value vector\n\t\t * @param {number} referenceValue - Reference Value Vector ID\n\t\t * @param {number} dataColgroupStart - Column position where the column data group start\n\t\t *\n\t\t */\n\t\tfunction setInnerStepValues( vectorHead, headerLevel, stepsValue, referenceValue, dataColgroupStart ) {\n\t\t\tvar i, iLength,\n\t\t\t\theaderCell,\n\t\t\t\tcumulativeValue = 0;\n\n\t\t\tfor ( i = 0, iLength = vectorHead.cell.length; i !== iLength; i += 1 ) {\n\t\t\t\theaderCell = vectorHead.cell[ i ];\n\t\t\t\tif ( i !== 0 && headerCell.uid === vectorHead.cell[ i - 1 ].uid || ( dataColgroupStart && headerCell.colpos < dataColgroupStart ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Only process the first data group\n\t\t\t\tif ( !reverseTblParsing ) {\n\t\t\t\t\tif ( headerCell.colgroup && headerCell.colgroup.type === 3 ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ( headerCell.rowgroup && headerCell.rowgroup.type === 3 ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( headerCell.child > 0 && headerLevel < referenceValue ) {\n\t\t\t\t\theaderCell.flotDelta = stepsValue * headerCell.child.length;\n\t\t\t\t} else {\n\t\t\t\t\theaderCell.flotDelta = stepsValue;\n\t\t\t\t}\n\t\t\t\tif ( headerCell.type === 1 || headerCell.type === 7  ) {\n\n\t\t\t\t\tif ( !lowestFlotDelta || headerCell.flotDelta < lowestFlotDelta ) {\n\t\t\t\t\t\tlowestFlotDelta = headerCell.flotDelta;\n\t\t\t\t\t}\n\t\t\t\t\theaderCell.flotValue = cumulativeValue;\n\n\t\t\t\t\tcumulativeValue = cumulativeValue + stepsValue;\n\n\t\t\t\t\tif ( headerCell.child.length > 0 ) {\n\t\t\t\t\t\tsetInnerStepValuesChildRecursive( headerCell, headerLevel, stepsValue, referenceValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Recursize - Set the inner step value (divisor) of an sub header cell\n\t\t *\n\t\t * @method setInnerStepValuesChildRecursive\n\t\t * @param {object} headerCell - Header cell object from the table parser\n\t\t * @param {number} headerLevel - Hiearchical Level of heading\n\t\t * @param {number} stepsValue - Specific Step Value applied for current headerCell\n\t\t * @param {number} referenceValue - Reference Value Vector ID\n\t\t */\n\t\tfunction setInnerStepValuesChildRecursive( headerCell, headerLevel, stepsValue, referenceValue ) {\n\t\t\tvar cumulativeValue = 0,\n\n\t\t\t\t// Step Values for childs header in headerCell\n\t\t\t\tflotDelta,\n\t\t\t\ti, iLength,\tcurrentHeaderCellChild;\n\n\t\t\theaderLevel += 1;\n\t\t\tcumulativeValue = headerCell.flotValue;\n\t\t\tflotDelta = stepsValue / headerCell.child.length;\n\n\t\t\t// Use to calculate the largest width for a bar in a bar chart\n\t\t\tif ( !lowestFlotDelta || flotDelta < lowestFlotDelta ) {\n\t\t\t\tlowestFlotDelta = flotDelta;\n\t\t\t}\n\n\t\t\tfor ( i = 0, iLength = headerCell.child.length; i !== iLength; i += 1 ) {\n\t\t\t\tcurrentHeaderCellChild = headerCell.child[ i ];\n\t\t\t\tif ( headerLevel < referenceValue ) {\n\t\t\t\t\tcurrentHeaderCellChild.flotDelta = flotDelta * currentHeaderCellChild.child.length;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentHeaderCellChild.flotDelta = flotDelta;\n\t\t\t\t}\n\t\t\t\tcurrentHeaderCellChild.flotValue = cumulativeValue;\n\t\t\t\tif ( currentHeaderCellChild.child.length > 0 ) {\n\t\t\t\t\tsetInnerStepValuesChildRecursive( currentHeaderCellChild, headerLevel, flotDelta, referenceValue );\n\t\t\t\t}\n\t\t\t\tcumulativeValue = cumulativeValue + flotDelta;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Set the header cell step value (flotDelta) for vector that regroup more than one reference\n\t\t *\n\t\t * @method setUpperStepValues\n\t\t * @param {object} vectorHead - Group Header Object from the table parser\n\t\t * @param {number} referenceValue - Reference Value Vector ID\n\t\t */\n\t\tfunction setUpperStepValues( vectorHead, referenceValue ) {\n\t\t\tvar i, k, m, kLen, mLen,\n\t\t\t\tcumulativeValue,\n\t\t\t\tcurrentCell,\n\t\t\t\tcurrentCellChild,\n\t\t\t\tcurrentVectorHead;\n\n\t\t\t// Calculate upper-step for cells that are\n\t\t\t// less precise than the reference value vector\n\t\t\tfor ( i = referenceValue - 1; i !== -1; i -= 1 ) {\n\t\t\t\tcurrentVectorHead = vectorHead[ i ];\n\n\t\t\t\tfor ( k = 0, kLen = currentVectorHead.cell.length; k !== kLen; k += 1 ) {\n\t\t\t\t\tcurrentCell = currentVectorHead.cell[ k ];\n\n\t\t\t\t\tif ( currentCell.flotDelta || k > 0 &&\n\t\t\t\t\t\tcurrentCell.uid === currentVectorHead.cell[ k - 1 ].uid ) {\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( !( currentCell.type === 1 || currentCell.type === 7 ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tcumulativeValue = 0;\n\t\t\t\t\tfor ( m = 0, mLen = currentCell.child.length; m !== mLen; m += 1 ) {\n\t\t\t\t\t\tcurrentCellChild = currentCell.child[ m ];\n\n\t\t\t\t\t\tcumulativeValue = currentCellChild.flotDelta;\n\t\t\t\t\t\tif ( !currentCell.flotValue ) {\n\t\t\t\t\t\t\tcurrentCell.flotValue = currentCellChild.flotValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcurrentCell.flotDelta = cumulativeValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Get labels for a specific vector\n\t\t *\n\t\t * @method getLabels\n\t\t * @param {object} labelVector - Vector Header Object from the table parser\n\t\t * @param {number} dataColgroupStart - Column position where the column data group start\n\t\t */\n\t\tfunction getLabels( labelVector, dataColgroupStart ) {\n\t\t\tvar labels = [],\n\t\t\t\ti, iLen, currentCell;\n\n\t\t\tfor ( i = 0, iLen = labelVector.cell.length; i !== iLen; i += 1 ) {\n\t\t\t\tcurrentCell = labelVector.cell[ i ];\n\n\t\t\t\tif ( ( i !== 0 && currentCell.uid === labelVector.cell[ i - 1 ].uid ) ||\n\t\t\t\t\t\t( !( currentCell.type === 1 || currentCell.type === 7 ) ) ||\n\t\t\t\t\t\t( dataColgroupStart && currentCell.colpos < dataColgroupStart ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlabels.push( [ currentCell.flotValue, $( currentCell.elem ).text() ] );\n\t\t\t}\n\t\t\treturn labels;\n\t\t}\n\n\t\t/**\n\t\t * Get the vector that would be used for labelling x-axis\n\t\t *\n\t\t * @method getlabelsVectorPosition\n\t\t * @param {object[]} arrVectorHeaders - Collection of vector headers\n\t\t */\n\t\tfunction getlabelsVectorPosition( arrVectorHeaders ) {\n\t\t\tvar labelPosition = optionsCharts.labelposition;\n\t\t\treturn ( !labelPosition || ( labelPosition && labelPosition > arrVectorHeaders.length ) ?\n\t\t\t\tparsedData.theadRowStack.length : labelPosition ) - 1;\n\t\t}\n\n\t\t/**\n\t\t * Get the vertical label and set the appropriate header cell x-axis Value\n\t\t *\n\t\t * @method verticalLabels\n\t\t * @param {object} parsedData - Generic object generated by the table parser\n\t\t */\n\t\tfunction verticalLabels( parsedData ) {\n\n\t\t\t// Get the appropriate ticks\n\t\t\tvar headerlevel = 0,\n\t\t\t\tlabelsVectorPosition, stepsValue, columnReferenceValue;\n\n\t\t\tif ( !reverseTblParsing || ( reverseTblParsing && optionsCharts.referencevalue === false ) ) {\n\t\t\t\tcolumnReferenceValue = parsedData.colgrouphead.col.length;\n\t\t\t} else {\n\t\t\t\tcolumnReferenceValue = optionsCharts.referencevalue;\n\t\t\t}\n\n\t\t\tcolumnReferenceValue = columnReferenceValue - 1;\n\n\t\t\tstepsValue = getColumnGroupHeaderCalculateSteps( parsedData.colgrouphead, columnReferenceValue );\n\n\t\t\tif ( !reverseTblParsing ) {\n\t\t\t\tlabelsVectorPosition = parsedData.colgrouphead.col.length - 1;\n\t\t\t} else {\n\t\t\t\tlabelsVectorPosition = getlabelsVectorPosition( parsedData.colgrouphead.col );\n\t\t\t}\n\n\t\t\theaderlevel = columnReferenceValue;\n\n\t\t\t// Calculate inner-step for cells that are more precise than the reference value vector\n\t\t\tsetInnerStepValues( parsedData.colgrouphead.col[ columnReferenceValue ], headerlevel, stepsValue, columnReferenceValue );\n\n\t\t\t// Calculate upper-step for cells that are less precise than the reference value vector\n\t\t\tsetUpperStepValues( parsedData.colgrouphead.col, columnReferenceValue );\n\n\t\t\t// Get the labelling\n\t\t\treturn getLabels( parsedData.colgrouphead.col[ labelsVectorPosition ] );\n\t\t}\n\n\t\t/**\n\t\t * Get the horizontal label and set the appropriate header cell x-axis Value\n\t\t *\n\t\t * @method horizontalLabels\n\t\t * @param {object} parsedData - Generic object generated by the table parser\n\t\t */\n\t\tfunction horizontalLabels( parsedData ) {\n\n\t\t\t// Find the range of the first data colgroup\n\t\t\tvar dataColgroupStart = -1,\n\t\t\t\theaderlevel = 0,\n\t\t\t\ttheadRowStack = parsedData.theadRowStack,\n\t\t\t\ti, iLength, labelsVectorPosition,\n\t\t\t\tstepsValue, rowReferenceValue;\n\n\t\t\tif ( !theadRowStack ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor ( i = 0, iLength = parsedData.colgroup.length; i !== iLength; i += 1 ) {\n\t\t\t\tif ( parsedData.colgroup[ i ].type === 2 ) {\n\t\t\t\t\tdataColgroupStart = parsedData.colgroup[ i ].start;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( ( !reverseTblParsing && optionsCharts.referencevalue === false ) || reverseTblParsing ) {\n\t\t\t\trowReferenceValue = theadRowStack.length;\n\t\t\t} else {\n\t\t\t\trowReferenceValue = optionsCharts.referencevalue;\n\t\t\t}\n\n\t\t\trowReferenceValue = rowReferenceValue - 1;\n\n\t\t\tstepsValue = getRowGroupHeaderCalculateSteps( theadRowStack, rowReferenceValue, dataColgroupStart );\n\n\t\t\tif ( !reverseTblParsing ) {\n\t\t\t\tlabelsVectorPosition = getlabelsVectorPosition( theadRowStack );\n\t\t\t} else {\n\t\t\t\tlabelsVectorPosition = theadRowStack.length - 1;\n\t\t\t}\n\n\t\t\theaderlevel = rowReferenceValue;\n\n\t\t\t// Calculate inner-step for cells that are more precise than the reference value vector\n\t\t\tsetInnerStepValues( theadRowStack[ rowReferenceValue ], headerlevel, stepsValue, rowReferenceValue, dataColgroupStart );\n\n\t\t\t// Calculate upper-step for cells that are less precise than the reference value vector\n\t\t\tsetUpperStepValues( theadRowStack, rowReferenceValue );\n\n\t\t\t// Get the labelling\n\t\t\treturn getLabels( theadRowStack[ labelsVectorPosition ], dataColgroupStart );\n\n\t\t}\n\n\t\t/**\n\t\t * Wrap the table into a smart details/summary element\n\t\t *\n\t\t * @method wrapTableIntoDetails\n\t\t */\n\t\tfunction wrapTableIntoDetails() {\n\t\t\tvar $summary;\n\n\t\t\tif ( !captionHtml.length ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$summary = $( "<summary>" + captionHtml + i18nText.tableMention + "</summary>" );\n\t\t\t$elm\n\t\t\t\t.wrap( "<details/>" )\n\t\t\t\t.before( $summary );\n\n\t\t\t$summary.trigger( "wb-init.wb-details" );\n\t\t}\n\n\t\tfunction createContainer( withDimension ) {\n\t\t\t$elm\n\t\t\t\t.wrap( "<figure class=\'" + optionsCharts.graphclass + "\'/>" )\n\t\t\t\t.before(\n\n\t\t\t\t\t// Copy to the inner table caption\n\t\t\t\t\t( captionHtml.length ? "<figcaption>" + captionHtml + "</figcaption>" : "" ) +\n\n\t\t\t\t\t// Image Container\n\t\t\t\t\t"<div role=\'img\' aria-label=\'" + captionText + i18nText.tableFollowing + "\'" +\n\n\t\t\t\t\t// Add Dimension\n\t\t\t\t\t( withDimension ? "style=\'height:" + optionsCharts.height +\n\t\t\t\t\t"px; width:" + optionsCharts.width + "px\'" : "" ) + "></div>"\n\t\t\t\t);\n\n\t\t\treturn $( "div:eq(0)", $elm.parent() );\n\t\t}\n\n\t\t// Retrieve the parsed data\n\t\tparsedData = $elm.data().tblparser;\n\n\t\t// Reverse table parsing\n\t\treverseTblParsing = optionsCharts.reversettblparsing;\n\n\t\t// first data row group\n\t\tcurrentRowGroup = parsedData.lstrowgroup[ 0 ];\n\n\t\tif ( optionFlot.series && optionFlot.series.pie ) {\n\n\t\t\t// WET Charts placeholder\n\t\t\t$wetChartContainer = createContainer( false );\n\n\t\t\t// Flot pie chart placeholder\n\t\t\thtmlPlaceHolder = "<div style=\'height:" + optionsCharts.height +\n\t\t\t\t"px; width:" + optionsCharts.width + "px\'></div>";\n\n\t\t\tif ( !reverseTblParsing ) {\n\n\t\t\t\t// If normal parsing\n\t\t\t\tdataGroup = parsedData.colgroup[ 0 ].type === 1 ?\n\t\t\t\t\tparsedData.colgroup[ 1 ] :\n\t\t\t\t\tparsedData.colgroup[ 0 ];\n\n\t\t\t\trIndex = currentRowGroup.row.length - 1;\n\t\t\t} else {\n\n\t\t\t\t// If reverse parsing\n\t\t\t\tdataGroup = currentRowGroup;\n\t\t\t\trIndex = ( parsedData.colgroup[ 0 ].type === 1 ?\n\t\t\t\t\tparsedData.colgroup[ 1 ].col.length :\n\t\t\t\t\tparsedData.colgroup[ 0 ].col.length ) - 1;\n\t\t\t}\n\n\t\t\tfor ( rIndex; rIndex >= 0; rIndex -= 1 ) {\n\n\t\t\t\tdataGroupVector = !reverseTblParsing ? dataGroup.col : dataGroup.row;\n\n\t\t\t\t// For each row or column\n\t\t\t\tfor ( i = 0, iLength = dataGroupVector.length; i !== iLength; i += 1 ) {\n\t\t\t\t\tdataSeries = [];\n\t\t\t\t\tvaluePoint = 0;\n\t\t\t\t\tcurrentDataGroupVector = dataGroupVector[ i ];\n\n\t\t\t\t\t// For each cells\n\t\t\t\t\tfor ( j = 0, jLength = currentDataGroupVector.cell.length; j !== jLength; j += 1 ) {\n\n\t\t\t\t\t\tdataCell = currentDataGroupVector.cell[ j ];\n\n\t\t\t\t\t\t// Skip the column if\n\t\t\t\t\t\tif ( reverseTblParsing && dataCell.col.type === 1 ) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpreviousDataCell = undefined;\n\t\t\t\t\t\tif ( j !== 0 ) {\n\t\t\t\t\t\t\tpreviousDataCell = currentDataGroupVector.cell[ j - 1 ];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Verify if the selected cell still in the scope of a data group in his another axes (eg. row/col)\n\t\t\t\t\t\t// Verify if we are still in the same datagroup as the previous data cell\n\t\t\t\t\t\tif ( ( !reverseTblParsing && ( dataCell.row.type !== 2  || ( previousDataCell &&\n\t\t\t\t\t\t\t\tpreviousDataCell.rowgroup.uid !== dataCell.rowgroup.uid ) ) ) ||\n\t\t\t\t\t\t\t\t( reverseTblParsing && ( dataCell.col.type !== 2 ) || ( previousDataCell &&\n\t\t\t\t\t\t\t\tpreviousDataCell.col.type !== 1 &&\n\t\t\t\t\t\t\t\tpreviousDataCell.col.groupstruct.uid !== dataCell.col.groupstruct.uid ) ) ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Gets the value\n\t\t\t\t\t\theader = !reverseTblParsing ? dataCell.row.header : dataCell.col.header;\n\n\t\t\t\t\t\tcellValue = optionsCharts.getcellvalue( !reverseTblParsing ?\n\t\t\t\t\t\t\tcurrentDataGroupVector.cell[ rIndex ].elem :\n\t\t\t\t\t\t\tcurrentDataGroupVector.datacell[ rIndex ].elem );\n\n\t\t\t\t\t\tdataSeries.push(\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\tvaluePoint,\n\t\t\t\t\t\t\t\ttypeof cellValue === "object" ?\n\t\t\t\t\t\t\t\t\tcellValue[ 0 ] :\n\t\t\t\t\t\t\t\t\tcellValue\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tvaluePoint += header[ header.length - 1 ].flotDelta;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tpieQuaterFlotSeries = { };\n\n\t\t\t\t\t// Get the setting from the associative cell header\n\t\t\t\t\tdataCell = !reverseTblParsing ?\n\t\t\t\t\t\tcurrentDataGroupVector.cell[ rIndex ] :\n\t\t\t\t\t\tcurrentDataGroupVector.datacell[ rIndex ];\n\t\t\t\t\theader = !reverseTblParsing ?\n\t\t\t\t\t\tdataCell.col.header :\n\t\t\t\t\t\tdataCell.row.header;\n\t\t\t\t\theader = header[ header.length - 1 ];\n\n\t\t\t\t\t// Apply any preset\n\t\t\t\t\tpieQuaterFlotSeries = applyPreset( defaultsOptions.series, $( header.elem ), "flot" );\n\n\t\t\t\t\t// Set the data issue from the table\n\t\t\t\t\tpieQuaterFlotSeries.data = dataSeries;\n\t\t\t\t\tpieQuaterFlotSeries.label = ( !reverseTblParsing ?\n\t\t\t\t\t\t$( currentDataGroupVector.dataheader[ currentDataGroupVector.dataheader.length - 1 ].elem ).text() :\n\t\t\t\t\t\t$( currentDataGroupVector.header[ currentDataGroupVector.header.length - 1 ].elem ).text() );\n\n\t\t\t\t\t// Add the series\n\t\t\t\t\tallSeries.push( pieQuaterFlotSeries );\n\t\t\t\t}\n\n\t\t\t\t// Create a sub Figure or use the main one\n\t\t\t\tif ( currentRowGroup.row.length === 1 &&\n\t\t\t\t\t( currentRowGroup.row[ 0 ].header[ 0 ].elem.innerHTML === captionHtml ||\n\t\t\t\t\tcurrentRowGroup.row[ 0 ].header.length === 0 ) ) {\n\n\t\t\t\t\t$placeHolder = $wetChartContainer;\n\t\t\t\t\t$placeHolder.css( {\n\t\t\t\t\t\theight: optionsCharts.height,\n\t\t\t\t\t\twidth: optionsCharts.width\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\theader = currentRowGroup.row[ rIndex ].header;\n\n\t\t\t\t\tfigurehtml = "<figure><figcaption>" +\n\t\t\t\t\t\theader[ header.length - 1 ].elem.innerHTML +\n\t\t\t\t\t\t"</figcaption>" + htmlPlaceHolder + "</figure>";\n\n\t\t\t\t\t$wetChartContainer.append( $( figurehtml ) );\n\n\t\t\t\t\t$placeHolder = $( "div:last()", $wetChartContainer );\n\t\t\t\t}\n\n\t\t\t\t// Create the graphic\n\t\t\t\t$.plot( $placeHolder, allSeries, optionFlot );\n\n\t\t\t\tif ( !optionsCharts.legendinline ) {\n\n\t\t\t\t\t// Move the legend under the graphic\n\t\t\t\t\t$( ".legend", $placeHolder ).appendTo( $wetChartContainer );\n\t\t\t\t}\n\n\t\t\t\tallSeries = [];\n\t\t\t}\n\n\t\t\tif ( optionsCharts.nolegend ) {\n\n\t\t\t\t// Remove the legend\n\t\t\t\t$( ".legend", $wetChartContainer ).remove();\n\t\t\t}\n\t\t\tif ( !optionsCharts.legendinline ) {\n\n\t\t\t\t// Fix the legend that appear under the graphic\n\t\t\t\t$( ".legend > div", $wetChartContainer ).remove();\n\t\t\t\t$( ".legend > table", $wetChartContainer ).removeAttr( "style" ).addClass( "font-small" );\n\t\t\t\t$( ".legend", $placeHolder ).appendTo( $imgContainer );\n\t\t\t}\n\n\t\t\t// Remove any "pieLabel" ids set by the flotPie.js plugin at line #457\n\t\t\t$( ".pieLabel" ).removeAttr( "id" );\n\n\t\t\tif ( !optionsCharts.noencapsulation ) {\n\t\t\t\twrapTableIntoDetails();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !reverseTblParsing ) {\n\n\t\t\t// If normal parsing\n\t\t\tdataGroup = currentRowGroup;\n\t\t\trIndex = ( parsedData.colgroup[ 0 ].type === 1 ?\n\t\t\t\tparsedData.colgroup[ 1 ].col.length :\n\t\t\t\tparsedData.colgroup[ 0 ].col.length ) - 1;\n\t\t\tchartslabels = horizontalLabels( parsedData );\n\t\t} else {\n\n\t\t\t// If reverse parsing\n\t\t\tdataGroup = parsedData.colgroup[ 0 ].type === 1 ?\n\t\t\t\tparsedData.colgroup[ 1 ] :\n\t\t\t\tparsedData.colgroup[ 0 ];\n\t\t\trIndex = currentRowGroup.row.length - 1;\n\t\t\tchartslabels = verticalLabels( parsedData );\n\t\t}\n\n\t\t// Add the labels at the Flot options\n\t\toptionFlot.xaxis.ticks = chartslabels;\n\n\t\tdataGroupVector = !reverseTblParsing ? dataGroup.row : dataGroup.col;\n\n\t\t// Count the number of bar charts,\n\t\tfor ( i = 0, iLength = dataGroupVector.length; i !== iLength; i += 1 ) {\n\t\t\tcurrentDataGroupVector = dataGroupVector[ i ];\n\t\t\tcurrDataVector = currentDataGroupVector.header[ currentDataGroupVector.header.length - 1 ];\n\n\t\t\t// Apply any preset\n\t\t\tcurrVectorOptions = applyPreset( defaultsOptions.series, $( currDataVector.elem ), "flot" );\n\n\t\t\tif ( currVectorOptions.bars || ( optionFlot.bars && !currVectorOptions.lines ) ) {\n\n\t\t\t\t// Count number of bars, this number is use to calculate the bar width.\n\t\t\t\tnbBarChart += 1;\n\n\t\t\t\t// Set a default setting specially for bar charts\n\t\t\t\tif ( !currVectorOptions.bars ) {\n\t\t\t\t\tcurrVectorOptions.bars = { show: true, barWidth: 0.9 };\n\t\t\t\t}\n\n\t\t\t\t// Set a default order for orderBars flot plugin\n\t\t\t\tif ( !currVectorOptions.bars.order ) {\n\t\t\t\t\tcurrVectorOptions.bars.order = nbBarChart;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// cache the compiled setting\n\t\t\tcurrDataVector.chartOption = currVectorOptions;\n\t\t}\n\n\t\t// First rowgroup assume is a data row group.\n\t\t// For all row....\n\t\tfor ( i = 0, iLength = dataGroupVector.length; i !== iLength; i += 1 ) {\n\t\t\tdataSeries = [];\n\t\t\tdatacolgroupfound = 0;\n\t\t\tvaluePoint = 0;\n\t\t\tcurrDataVector = dataGroupVector[ i ];\n\n\t\t\tcurrVectorOptions = currDataVector.header[ currDataVector.header.length - 1 ].chartOption;\n\n\t\t\t// For each cells\n\t\t\tfor ( j = 0, jLength = currDataVector.cell.length; j !== jLength; j += 1 ) {\n\n\t\t\t\tdataCell = currDataVector.cell[ j ];\n\n\t\t\t\tif ( datacolgroupfound > 1 && dataCell.col.groupstruct.type !== 2 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( ( !reverseTblParsing && dataCell.col.groupstruct.type === 2 ) ||\n\t\t\t\t\t\t( reverseTblParsing && dataCell.row.rowgroup.type === 2 ) ) {\n\n\t\t\t\t\t// Gets the value\n\t\t\t\t\theader = !reverseTblParsing ? dataCell.col.header : dataCell.row.header;\n\n\t\t\t\t\tcellValue = optionsCharts.getcellvalue( dataCell.elem );\n\n\t\t\t\t\t// Add the data point\n\t\t\t\t\tdataSeries.push(\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tvaluePoint,\n\t\t\t\t\t\t\ttypeof cellValue === "object" ?\n\t\t\t\t\t\t\t\tcellValue[ 0 ] :\n\t\t\t\t\t\t\t\tcellValue\n\t\t\t\t\t\t]\n\t\t\t\t\t);\n\t\t\t\t\tvaluePoint += header[ header.length - 1 ].flotDelta;\n\t\t\t\t\tdatacolgroupfound += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrVectorOptions.data = dataSeries;\n\t\t\tcurrVectorOptions.label = $( currDataVector.header[ currDataVector.header.length - 1 ].elem ).text();\n\n\t\t\tif ( currVectorOptions.bars ) {\n\n\t\t\t\t// Adjust the bars width\n\t\t\t\tcurrVectorOptions.bars.barWidth = currVectorOptions.bars.barWidth * ( 1 / nbBarChart );\n\t\t\t}\n\n\t\t\tallSeries.push( currVectorOptions );\n\n\t\t}\n\n\t\tif ( optionFlot.bars ) {\n\n\t\t\t// Adjust the bars width\n\t\t\toptionFlot.bars.barWidth = optionFlot.bars.barWidth * ( 1 / nbBarChart );\n\t\t}\n\n\t\t// WET Charts Placeholder\n\t\t$placeHolder = createContainer( true );\n\n\t\t// Maximum width\n\t\t$placeHolder.css( "width", "100%" );\n\n\t\t// Create the graphic\n\t\t$.plot( $placeHolder, allSeries, optionFlot );\n\n\t\tif ( !optionsCharts.legendinline ) {\n\n\t\t\t// Move the legend under the graphic\n\t\t\t$( ".legend > div", $placeHolder ).remove();\n\t\t\t$( ".legend > table", $placeHolder ).removeAttr( "style" ).addClass( "font-small" );\n\t\t\t$placeHolder.css( "height", "auto" );\n\t\t}\n\t\tif ( optionsCharts.nolegend ) {\n\n\t\t\t// Remove the legend\n\t\t\t$( ".legend", $placeHolder ).remove();\n\t\t}\n\n\t\tif ( !optionsCharts.noencapsulation ) {\n\t\t\twrapTableIntoDetails();\n\t\t}\n\n\t\t$( "canvas:eq(1)", $placeHolder ).css( "position", "static" );\n\t\t$( "canvas:eq(0)", $placeHolder ).css( "width", "100%" );\n\n\t\t$elm.trigger( "wb-updated" + selector );\n\t},\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered this handler\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\tsettings = window[ componentName ],\n\t\t\telmId, modeJS, deps;\n\n\t\tif ( elm ) {\n\t\t\telmId = elm.id;\n\t\t\tmodeJS = wb.getMode() + ".js";\n\t\t\tdeps = [\n\t\t\t\t"site!deps/jquery.flot" + modeJS,\n\t\t\t\t"site!deps/jquery.flot.pie" + modeJS,\n\t\t\t\t"site!deps/jquery.flot.canvas" + modeJS,\n\t\t\t\t"site!deps/jquery.flot.orderBars" + modeJS,\n\t\t\t\t"site!deps/tableparser" + modeJS\n\t\t\t];\n\n\t\t\t//TODO: Revist this in the new plugin structure\n\t\t\tif ( settings && settings.plugins ) {\n\t\t\t\tdeps = deps.concat( settings.plugins );\n\t\t\t}\n\n\t\t\t// Only initialize the i18nText once\n\t\t\tif ( !i18nText ) {\n\t\t\t\ti18n = wb.i18n;\n\t\t\t\ti18nText = {\n\t\t\t\t\ttableMention: i18n( "hyphen" ) + i18n( "tbl-txt" ),\n\t\t\t\t\ttableFollowing: i18n( "hyphen" ) + i18n( "tbl-dtls" ),\n\t\t\t\t\tslicelegend: i18n( "chrt-cmbslc" )\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Load the required dependencies\n\t\t\tModernizr.load( {\n\n\t\t\t\t// For loading multiple dependencies\n\t\t\t\tload: deps,\n\t\t\t\tcomplete: function() {\n\t\t\t\t\tvar $elm = $( "#" + elmId );\n\n\t\t\t\t\t// Let\'s parse the table\n\t\t\t\t\t$elm.trigger( tableParsingEvent );\n\n\t\t\t\t\t// Identify that initialization has completed\n\t\t\t\t\twb.ready( $elm, componentName );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t};\n\n// Bind the init event of the plugin\n$document.on( "timerpoke.wb " + initEvent + " " + tableParsingCompleteEvent, selector, function( event ) {\n\tvar eventType = event.type,\n\t\telm = event.target;\n\n\tswitch ( eventType ) {\n\n\t/*\n\t * Init\n\t */\n\tcase "timerpoke":\n\tcase "wb-init":\n\t\tinit( event );\n\t\tbreak;\n\n\t/*\n\t * Data table parsed\n\t */\n\tcase "parsecomplete":\n\t\tif ( event.currentTarget === elm ) {\n\t\t\tcreateCharts( $( elm ) );\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Since we are working with events we want to ensure that we are being passive about our control,\n\t * so returning true allows for events to always continue\n\t */\n\treturn true;\n} );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, document, wb );\n\n/**\n * @title WET-BOEW Collapsible alerts plugin\n * @overview Collapsible alerts (details/summary)\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author WET community\n */\n( function( $, window, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the event - meaning that they will be initialized once per page,\n * not once per instance of event on the page.\n */\nvar componentName = "wb-collapsible",\n\tselector = "details.alert",\n\tinitEvent = "wb-init." + componentName,\n\t$document = wb.doc,\n\tkey,\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar details = wb.init( event, componentName, selector ),\n\t\t\t$details;\n\n\t\tif ( details ) {\n\t\t\t$details = $( details );\n\n\t\t\tkey = "alert-collapsible-state-" + details.getAttribute( "id" );\n\n\t\t\ttry {\n\t\t\t\tif ( localStorage.getItem( key ) ) {\n\n\t\t\t\t\t// Set open/closed state for existing localStorage keys\n\t\t\t\t\tif ( localStorage.getItem( key ) === "open" ) {\n\t\t\t\t\t\tdetails.setAttribute( "open", "open" );\n\t\t\t\t\t\tdetails.className += " open";\n\t\t\t\t\t} else if ( localStorage.getItem( key ) === "closed" ) {\n\t\t\t\t\t\tdetails.removeAttribute( "open" );\n\t\t\t\t\t\tdetails.className = details.className.replace( " open", "" );\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Set new localStorage values\n\t\t\t\t\tif ( details.hasAttribute( "open" ) ) {\n\t\t\t\t\t\tlocalStorage.setItem( key, "open" );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlocalStorage.setItem( key, "closed" );\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Identify that initialization has completed\n\t\t\twb.ready( $details, componentName );\n\t\t}\n\t};\n\n// Bind the init event of the plugin\n$document.on( "timerpoke.wb " + initEvent, selector, init );\n\n// Do not bind events if details polyfill is active\nif ( Modernizr.details ) {\n\n\t// Bind the the event handlers of the plugin\n\t$document.on( "click keydown toggle." + componentName, selector + " summary", function( event ) {\n\t\tvar which = event.which,\n\t\t\tcurrentTarget = event.currentTarget,\n\t\t\tisClosed,\n\t\t\tdetails;\n\n\t\t// Ignore middle/right mouse buttons and wb-toggle enhanced summary elements (except for toggle)\n\t\tif ( ( !which || which === 1 ) &&\n\t\t\t( currentTarget.className.indexOf( "wb-toggle" ) === -1 ||\n\t\t\t( event.type === "toggle" && event.namespace === componentName ) ) ) {\n\n\t\t\tdetails = currentTarget.parentNode;\n\t\t\tisClosed = details.getAttribute( "open" ) === null;\n\t\t\tkey = "alert-collapsible-state-" + details.getAttribute( "id" );\n\n\t\t\tif ( isClosed ) {\n\t\t\t\ttry {\n\t\t\t\t\tlocalStorage.setItem( key, "open" );\n\t\t\t\t} catch ( e ) {}\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tlocalStorage.setItem( key, "closed" );\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\t\t} else if ( which === 13 || which === 32 ) {\n\t\t\tevent.preventDefault();\n\t\t\t$( currentTarget ).trigger( "click" );\n\t\t}\n\n\t\t/*\n\t\t * Since we are working with events we want to ensure that we are being passive about our control,\n\t\t * so returning true allows for events to always continue\n\t\t */\n\t\treturn true;\n\t} );\n}\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, wb );\n\n/**\n * @title WET-BOEW Country Content\n * @overview A basic AjaxLoader wrapper that inserts AJAXed in content based on a visitors country as resolved by http://freegeoip.net\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @nschonni\n */\n( function( $, window, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once\n * per page, not once per instance of plugin on the page. So, this is a good\n * place to define variables that are common to all instances of the plugin on a\n * page.\n */\nvar componentName = "wb-ctrycnt",\n\tselector = "[data-ctrycnt]",\n\tinitEvent = "wb-init." + componentName,\n\t$document = wb.doc,\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered this handler\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\t$elm, url;\n\n\t\tif ( elm ) {\n\t\t\t$elm = $( elm );\n\t\t\turl = $elm.data( "ctrycnt" );\n\n\t\t\t$.when( getCountry() ).then( function( countryCode ) {\n\n\t\t\t\tif ( countryCode === "" ) {\n\n\t\t\t\t\t// Leave default content since we couldn\'t find the country\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\n\t\t\t\t\t// @TODO: Handle bad country values or any whitelist of countries.\n\t\t\t\t}\n\n\t\t\t\turl = url.replace( "{country}", countryCode.toLowerCase() );\n\n\t\t\t\t$elm.load( url, function() {\n\n\t\t\t\t\t// Identify that initialization has completed\n\t\t\t\t\twb.ready( $elm, componentName );\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\t},\n\tgetCountry = function() {\n\t\tvar dfd = $.Deferred(),\n\t\t\tcountryCode = localStorage.getItem( "countryCode" );\n\n\t\t// Couldn"t find a value in the session\n\t\tif ( countryCode === null ) {\n\n\t\t\t// From https://github.com/aFarkas/webshim/blob/master/src/shims/geolocation.js#L89-L127\n\t\t\t$.ajax( {\n\t\t\t\turl: "https://freegeoip.net/json/",\n\t\t\t\tdataType: "jsonp",\n\t\t\t\tcache: true,\n\t\t\t\tjsonp: "callback",\n\t\t\t\tsuccess: function( data ) {\n\t\t\t\t\tif ( data ) {\n\t\t\t\t\t\tcountryCode = data.country_code;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlocalStorage.setItem( "countryCode", countryCode );\n\t\t\t\t\t\t} catch ( error ) {\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdfd.resolve( countryCode );\n\t\t\t\t},\n\t\t\t\terror: function() {\n\t\t\t\t\tdfd.reject( "" );\n\t\t\t\t}\n\t\t\t} );\n\t\t} else {\n\t\t\tdfd.resolve( countryCode );\n\t\t}\n\n\t\treturn dfd.promise();\n\t};\n\n// Bind the init event of the plugin\n$document.on( "timerpoke.wb " + initEvent, selector, init );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, wb );\n\n/**\n * @title WET-BOEW Data Ajax [data-ajax-after], [data-ajax-append],\n * [data-ajax-before], [data-ajax-prepend] and [data-ajax-replace]\n * @overview A basic AjaxLoader wrapper that inserts AJAXed-in content\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author WET Community\n */\n( function( $, window, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once\n * per page, not once per instance of plugin on the page. So, this is a good\n * place to define variables that are common to all instances of the plugin on a\n * page.\n */\nvar componentName = "wb-data-ajax",\n\tshortName = "wb-ajax",\n\tselectors = [\n\t\t"[data-ajax-after]",\n\t\t"[data-ajax-append]",\n\t\t"[data-ajax-before]",\n\t\t"[data-ajax-prepend]",\n\t\t"[data-ajax-replace]",\n\t\t"[data-" + shortName + "]"\n\t],\n\tajaxTypes = [\n\t\t"before",\n\t\t"replace",\n\t\t"after",\n\t\t"append",\n\t\t"prepend"\n\t],\n\tselectorsLength = selectors.length,\n\tselector = selectors.join( "," ),\n\tinitEvent = "wb-init." + componentName,\n\tupdateEvent = "wb-update." + componentName,\n\tcontentUpdatedEvent = "wb-contentupdated",\n\t$document = wb.doc,\n\ts,\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered this handler\n\t * @param {string} ajaxType The type of AJAX operation, either after, append, before or replace\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar ajxInfo = getAjxInfo( event.target ),\n\t\t\tajaxType = ajxInfo.type,\n\t\t\telm = wb.init( event, componentName + "-" + ajaxType, selector );\n\n\t\tif ( elm && ajxInfo.url ) {\n\n\t\t\tajax.call( this, event, ajxInfo );\n\n\t\t\t// Identify that initialization has completed\n\t\t\twb.ready( $( elm ), componentName, [ ajaxType ] );\n\t\t}\n\t},\n\n\tajax = function( event, ajxInfo ) {\n\t\tvar elm = event.target,\n\t\t\t$elm = $( elm ),\n\t\t\tsettings = window[ componentName ],\n\t\t\turl,\n\t\t\tfetchObj,\n\t\t\turlParts;\n\n\t\tif ( !ajxInfo ) {\n\t\t\tajxInfo = getAjxInfo( elm );\n\t\t}\n\t\turl = ajxInfo.url;\n\t\tfetchObj = {\n\t\t\turl: url,\n\t\t\tnocache: ajxInfo.nocache,\n\t\t\tnocachekey: ajxInfo.nocachekey\n\t\t};\n\n\t\t// Detect CORS requests\n\t\tif ( settings && ( url.substr( 0, 4 ) === "http" || url.substr( 0, 2 ) === "//" ) ) {\n\t\t\turlParts = wb.getUrlParts( url );\n\t\t\tif ( ( wb.pageUrlParts.protocol !== urlParts.protocol || wb.pageUrlParts.host !== urlParts.host ) && ( !Modernizr.cors || settings.forceCorsFallback ) ) {\n\t\t\t\tif ( typeof settings.corsFallback === "function" ) {\n\t\t\t\t\tfetchObj.dataType = "jsonp";\n\t\t\t\t\tfetchObj.jsonp = "callback";\n\t\t\t\t\tfetchObj = settings.corsFallback( fetchObj );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t$elm.trigger( {\n\t\t\ttype: "ajax-fetch.wb",\n\t\t\tfetch: fetchObj\n\t\t} );\n\t},\n\n\t// Get Info and return { "url": "the/ajax/URL", "atype" }\n\tgetAjxInfo = function( elm ) {\n\t\tvar ajaxType,\n\t\t\tlen = ajaxTypes.length,\n\t\t\ti, url, dtAttr, nocache, nocachekey;\n\n\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\tajaxType = ajaxTypes[ i ];\n\t\t\turl = elm.getAttribute( "data-ajax-" + ajaxType );\n\t\t\tif ( url ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ( !url ) {\n\t\t\tdtAttr = wb.getData( $( elm ), shortName );\n\n\t\t\t// Abort the init when called on an invalid element (related to #8058)\n\t\t\tif ( !dtAttr ) {\n\t\t\t\treturn {};\n\t\t\t}\n\n\t\t\turl = getURL( dtAttr.url, dtAttr.httpref );\n\t\t\tif ( !url ) {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t\tajaxType = dtAttr.type;\n\t\t\tif ( ajaxTypes.indexOf( ajaxType ) === -1 ) {\n\t\t\t\tthrow "Invalid ajax type";\n\t\t\t}\n\t\t\tnocache = dtAttr.nocache;\n\t\t\tnocachekey = dtAttr.nocachekey;\n\t\t}\n\n\t\treturn {\n\t\t\t"url": url,\n\t\t\t"type": ajaxType,\n\t\t\t"nocache": nocache,\n\t\t\t"nocachekey": nocachekey\n\t\t};\n\t},\n\n\t// Return url for conditional display if regexp match http refer\n\tgetURL = function( url, referer ) {\n\t\tvar refers, httpRef, regHttpRef,\n\t\t\ti, i_len;\n\n\t\tif ( referer ) {\n\t\t\tif ( !$.isArray( referer ) ) {\n\t\t\t\trefers = [];\n\t\t\t\trefers.push( referer );\n\t\t\t} else {\n\t\t\t\trefers = referer;\n\t\t\t}\n\n\t\t\thttpRef = window.document.referrer;\n\t\t\ti_len = refers.length;\n\t\t\tfor ( i = 0; i !== i_len; i += 1 ) {\n\t\t\t\tregHttpRef = new RegExp( refers[ i ] );\n\t\t\t\tif ( regHttpRef.test( httpRef ) ) {\n\t\t\t\t\tif ( $.isArray( url ) && url.length === i_len ) {\n\t\t\t\t\t\treturn url[ i ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn url;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn url;\n\t\t}\n\t\treturn "";\n\t},\n\n\tajxFetched = function( elm, fetchObj ) {\n\t\tvar $elm = $( elm ),\n\t\t\tajxInfo = getAjxInfo( elm ),\n\t\t\tajaxType = ajxInfo.type,\n\t\t\tcontent, jQueryCaching;\n\n\t\t// ajax-fetched event\n\t\tcontent = fetchObj.response;\n\t\tif ( content &&  content.length > 0 ) {\n\n\t\t\t//Prevents the force caching of nested resources\n\t\t\tjQueryCaching = jQuery.ajaxSettings.cache;\n\t\t\tjQuery.ajaxSettings.cache = true;\n\n\t\t\t// "replace" is the only event that doesn\'t map to a jQuery function\n\t\t\tif ( ajaxType === "replace" ) {\n\t\t\t\t$elm.html( content );\n\t\t\t} else {\n\t\t\t\t$elm[ ajaxType ]( content );\n\t\t\t}\n\n\t\t\t//Resets the initial jQuery caching setting\n\t\t\tjQuery.ajaxSettings.cache = jQueryCaching;\n\n\t\t\t$elm.trigger( contentUpdatedEvent, { "ajax-type": ajaxType, "content": content } );\n\t\t}\n\t};\n\n$document.on( "timerpoke.wb " + initEvent + " " + updateEvent + " ajax-fetched.wb", selector, function( event ) {\n\tvar eventTarget = event.target;\n\n\tswitch ( event.type ) {\n\n\tcase "timerpoke":\n\tcase "wb-init":\n\t\tinit( event );\n\t\tbreak;\n\tcase "wb-update":\n\t\tajax( event );\n\t\tbreak;\n\tdefault:\n\n\t\t// Filter out any events triggered by descendants\n\t\tif ( event.currentTarget === eventTarget ) {\n\t\t\tajxFetched( eventTarget, event.fetch );\n\t\t}\n\t}\n\n\t/*\n\t * Since we are working with events we want to ensure that we are being\n\t * passive about our control, so returning true allows for events to always\n\t * continue\n\t */\n\treturn true;\n} );\n\n// Add the timerpoke to initialize the plugin\nfor ( s = 0; s !== selectorsLength; s += 1 ) {\n\twb.add( selectors[ s ] );\n}\n\n} )( jQuery, window, wb );\n\n/**\n * @title WET-BOEW Data InView\n * @overview A simplified data-attribute driven plugin that responds to moving in and out of the viewport.\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author WET Community\n */\n( function( $, window, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-inview",\n\tselector = "." + componentName,\n\tinitEvent = "wb-init" + selector,\n\tscrollEvent = "scroll" + selector,\n\t$document = wb.doc,\n\t$window = wb.win,\n\t$elms = $(),\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered this handler\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\t$elm;\n\n\t\tif ( elm ) {\n\t\t\t$elm = $( elm );\n\t\t\t$elms = $elms.add( $elm );\n\n\t\t\t// Allow other plugins to run first\n\t\t\tsetTimeout( function() {\n\t\t\t\tonInView( $elm );\n\n\t\t\t\t// Identify that initialization has completed\n\t\t\t\twb.ready( $elm, componentName );\n\t\t\t}, 1 );\n\t\t}\n\t},\n\n\t/**\n\t * @method onInView\n\t * @param {jQuery DOM element} $elm The plugin element\n\t */\n\tonInView = function( $elm ) {\n\t\tvar elementWidth = $elm.outerWidth(),\n\t\t\telementHeight = $elm.outerHeight(),\n\t\t\tscrollTop = $window.scrollTop(),\n\t\t\tscrollBottom = scrollTop + $window.height(),\n\t\t\tscrollRight = $window.scrollLeft() + elementWidth,\n\t\t\tx1 = $elm.offset().left,\n\t\t\tx2 = x1 + elementWidth,\n\t\t\ty1 = $elm.offset().top,\n\t\t\ty2 = y1 + elementHeight,\n\t\t\toldViewState = $elm.attr( "data-inviewstate" ),\n\t\t\tinView = ( scrollBottom < y1 || scrollTop > y2 ) || ( scrollRight < x1 || scrollRight > x2 ),\n\n\t\t\t// this is a bit of a play on true/false to get the desired effect. In short this variable depicts\n\t\t\t// the view state of the element\n\t\t\t// all - the whole element is in the viewport\n\t\t\t// partial - part of the element is in the viewport\n\t\t\t// none - no part of the element is in the viewport\n\t\t\tviewState = ( scrollBottom > y2 && scrollTop < y1 ) ? "all" : inView ? "none" : "partial",\n\t\t\t$dataInView = $( "#" + $elm.attr( "data-inview" ) ),\n\t\t\tshow;\n\n\t\t// Remove any element that no longer exists in the DOM\n\t\tif ( elementWidth === 0 || elementHeight === 0 ) {\n\t\t\t$elms = $elms.not( $elm );\n\t\t\t$dataInView.addClass( "user-closed" );\n\t\t\t$dataInView.trigger( {\n\t\t\t\ttype: ( "close" ),\n\t\t\t\tnamespace: "wb-overlay",\n\t\t\t\tnoFocus: true\n\t\t\t} );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Link the overlay close button to the dismiss action if the inview content is dismissable\n\t\tif ( $elm.hasClass( "wb-dismissable" ) ) {\n\t\t\tif ( $dataInView.hasClass( "wb-overlay" ) ) {\n\t\t\t\t$dataInView.children( ".overlay-close" ).on( "click vclick", function( event ) {\n\t\t\t\t\tvar which = event.which;\n\n\t\t\t\t\t// Ignore middle/right mouse buttons\n\t\t\t\t\tif ( !which || which === 1 ) {\n\t\t\t\t\t\t$elm.parent().siblings( ".content-dismiss" ).trigger( "click" );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\t// Only if the view state has changed\n\t\tif ( viewState !== oldViewState ) {\n\n\t\t\t// Show on "partial"/"none" (default) or just "none" (requires "show-none" class)\n\t\t\tshow = inView || ( $elm.hasClass( "show-none" ) ? false : viewState === "partial" );\n\n\t\t\t$elm.attr( "data-inviewstate", viewState );\n\n\t\t\tif ( $dataInView.length !== 0 ) {\n\n\t\t\t\t// Keep closed if the user closed the inView result\n\t\t\t\tif ( !$dataInView.hasClass( "user-closed" ) ) {\n\t\t\t\t\tif ( $dataInView.hasClass( "wb-overlay" ) ) {\n\t\t\t\t\t\tif ( !oldViewState ) {\n\t\t\t\t\t\t\t$dataInView.addClass( "outside-off" );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$dataInView.trigger( {\n\t\t\t\t\t\t\ttype: ( show ? "open" : "close" ),\n\t\t\t\t\t\t\tnamespace: "wb-overlay",\n\t\t\t\t\t\t\tnoFocus: true\n\t\t\t\t\t\t} );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$dataInView\n\t\t\t\t\t\t\t.attr( "aria-hidden", !show )\n\t\t\t\t\t\t\t.toggleClass( "in", !show )\n\t\t\t\t\t\t\t.toggleClass( "out", show );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Trigger an event on the element identifying that the view state has changed\n\t\t\t// (e.g., "all.wb-inview", "partial.wb-inview", "none.wb-inview")\n\t\t\t$elm.trigger( viewState + selector );\n\t\t}\n\t};\n\n// Bind the init event of the plugin\n$document.on( "timerpoke.wb " + initEvent + " " + scrollEvent, selector, function( event ) {\n\tvar eventTarget = event.target,\n\t\teventType = event.type;\n\n\tswitch ( eventType ) {\n\tcase "timerpoke":\n\tcase "wb-init":\n\t\tinit( event );\n\t\tbreak;\n\n\tcase "scroll":\n\n\t\t// Filter out any events triggered by descendants\n\t\tif ( event.currentTarget === eventTarget ) {\n\t\t\tonInView( $( eventTarget ) );\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Since we are working with events we want to ensure that we are being passive about our control,\n\t * so returning true allows for events to always continue\n\t */\n\treturn true;\n} );\n\n$window.on( "scroll scrollstop", function() {\n\t$elms.trigger( scrollEvent );\n} );\n\n$document.on( "txt-rsz.wb win-rsz-width.wb win-rsz-height.wb", function() {\n\t$elms.trigger( scrollEvent );\n} );\n\n$document.on( "refresh.wb", function() {\n\t$elms.each( function() {\n\t\tonInView( $( this ) );\n\t} );\n} );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, wb );\n\n/**\n * @title WET-BOEW Data Picture\n * @overview Event driven port of the Picturefill library: https://github.com/scottjehl/picturefill\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @patheard\n */\n( function( $, window, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar imgClass,\n\tcomponentName = "wb-pic",\n\tselector = "[data-pic]",\n\tinitEvent = "wb-init." + componentName,\n\tpicturefillEvent = "picfill." + componentName,\n\t$document = wb.doc,\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered this handler\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\t$elm;\n\n\t\tif ( elm ) {\n\t\t\t$elm = $( elm );\n\n\t\t\t// Store the class attribute of the plugin element.  It\n\t\t\t// will be added to the image created by the plugin.\n\t\t\timgClass = $elm.data( "class" ) || "";\n\n\t\t\t$elm.trigger( picturefillEvent );\n\n\t\t\t// Identify that initialization has completed\n\t\t\twb.ready( $elm, componentName );\n\t\t}\n\t},\n\n\t/**\n\t * Updates the image displayed according to media queries.\n\t * This is the logic ported from Picturefill.\n\t * @method picturefill\n\t * @param {DOM element} elm The element containing the images to be updated\n\t */\n\tpicturefill = function( elm ) {\n\t\tvar matches = [],\n\t\t\timg = elm.getElementsByTagName( "img" )[ 0 ],\n\t\t\tsources = elm.getElementsByTagName( "span" ),\n\t\t\ti, len, matchedElm, media;\n\n\t\t// Loop over the data-media elements and find matching media queries\n\t\tfor ( i = 0, len = sources.length; i !== len; i += 1 ) {\n\t\t\tmedia = sources[ i ].getAttribute( "data-media" );\n\t\t\tif ( !media || Modernizr.mq( media ) ) {\n\t\t\t\tmatches.push( sources[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// If a media query match was found, add the image to the page\n\t\tif ( matches.length !== 0 ) {\n\t\t\tmatchedElm = matches.pop();\n\t\t\tif ( !img ) {\n\t\t\t\timg = $document[ 0 ].createElement( "img" );\n\t\t\t\timg.alt = elm.getAttribute( "data-alt" );\n\t\t\t\timg.className = imgClass;\n\t\t\t}\n\t\t\timg.src = matchedElm.getAttribute( "data-src" );\n\t\t\tmatchedElm.appendChild( img );\n\n\t\t\t// Fixes bug with IE8 constraining the height of the image\n\t\t\t// when the .img-responsive class is used.\n\t\t\tif ( wb.ielt9 ) {\n\t\t\t\timg.removeAttribute( "width" );\n\t\t\t\timg.removeAttribute( "height" );\n\t\t\t}\n\n\t\t// No match and an image exists: delete it\n\t\t} else if ( img ) {\n\t\t\timg.parentNode.removeChild( img );\n\t\t}\n\n\t\t// Identify that the picture has been updated\n\t\t$( elm ).trigger( "wb-updated." + componentName );\n\t};\n\n// Bind the init event of the plugin\n$document.on( "timerpoke.wb " + initEvent + " " + picturefillEvent, selector, function( event ) {\n\tvar eventTarget = event.target,\n\t\teventType = event.type;\n\n\tswitch ( eventType ) {\n\tcase "timerpoke":\n\tcase "wb-init":\n\t\tinit( event );\n\t\tbreak;\n\n\tcase "picfill":\n\n\t\t// Filter out any events triggered by descendants\n\t\tif ( event.currentTarget === eventTarget ) {\n\t\t\tpicturefill( eventTarget );\n\t\t}\n\t\tbreak;\n\t}\n} );\n\n// Handles window resize so images can be updated as new media queries match\n$document.on( "txt-rsz.wb win-rsz-width.wb win-rsz-height.wb", function() {\n\t$( selector ).trigger( picturefillEvent );\n} );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, wb );\n\n/**\n * @title WET-BOEW Dismissable content plugin\n * @overview Enables content to be dismissed\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @thomasgohard\n */\n( function( $, window, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the event - meaning that they will be initialized once per page,\n * not once per instance of event on the page.\n */\nvar componentName = "wb-dismissable",\n\tselector = "." + componentName,\n\tinitEvent = "wb-init." + componentName,\n\tcontainerClass = "wb-dismissable-container",\n\twrapperClass = "wb-dismissable-wrapper",\n\tdismissClass = "content-dismiss",\n\tidKey = "dismissable-item-id",\n\t$document = wb.doc,\n\ti18n, i18nText,\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\titemId, dismissedState, contentContainer, contentWrapper, dismissButton;\n\n\t\tif ( elm ) {\n\n\t\t\t// Only initialize the i18nText once\n\t\t\tif ( !i18nText ) {\n\t\t\t\ti18n = wb.i18n;\n\t\t\t\ti18nText = {\n\t\t\t\t\tdismiss: i18n( "dismiss" )\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Give the dismissable element a unique ID\n\t\t\tif ( elm.hasAttribute( "id" ) ) {\n\t\t\t\titemId = elm.getAttribute( "id" );\n\n\t\t\t\t// Ignore an ID assigned by wb\n\t\t\t\tif ( itemId.indexOf( "wb-auto-" ) === 0 ) {\n\t\t\t\t\titemId = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( itemId === undefined ) {\n\t\t\t\titemId = wb.hashString( wb.stripWhitespace( elm.innerHTML ) );\n\t\t\t}\n\n\t\t\tdismissedState = getDismissedState( itemId );\n\n\t\t\tif ( dismissedState === "true" ) {\n\n\t\t\t\t// Remove the element if it has been dismissed\n\t\t\t\tif ( elm.parentNode ) {\n\t\t\t\t\telm.parentNode.removeChild( elm );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$( elm ).wrap( "<div class=\'" + wrapperClass + "\'>" );\n\t\t\t\tcontentWrapper = elm.parentNode;\n\n\t\t\t\t$( contentWrapper ).wrap( "<div class=\'" + containerClass + "\'>" );\n\t\t\t\tcontentContainer = contentWrapper.parentNode;\n\n\t\t\t\tdismissButton = "<button type=\'button\' class=\'mfp-close " + dismissClass +\n\t\t\t\t\t"\' title=\'" + i18nText.dismiss + "\'>&#xd7;<span class=\'wb-inv\'> " +\n\t\t\t\t\ti18nText.dismiss + "</span></button>";\n\t\t\t\t$( contentContainer ).append( dismissButton );\n\n\t\t\t\tcontentContainer.setAttribute( "data-" + idKey, itemId );\n\t\t\t}\n\n\t\t\t// Identify that initialization has completed\n\t\t\twb.ready( $document, componentName );\n\t\t}\n\t},\n\n\tgetDismissedState = function( id ) {\n\t\tvar dismissState = localStorage.getItem( id );\n\n\t\tif ( dismissState === null ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn dismissState;\n\t},\n\n\tdismissContent = function( elm ) {\n\t\tlocalStorage.setItem( elm.getAttribute( "data-" + idKey ), true );\n\t\telm.parentNode.removeChild( elm );\n\t\t$document.trigger( "refresh.wb" );\n\t};\n\n// Bind the init event of the plugin\n$document.on( "timerpoke.wb " + initEvent, selector, init );\n\n// Handler for clicking on the dismiss button\n$document.on( "click vclick", "." + dismissClass, function( event ) {\n\tvar elm = event.currentTarget,\n\t\twhich = event.which;\n\n\t// Ignore middle/right mouse buttons\n\tif ( !which || which === 1 ) {\n\t\tdismissContent( elm.parentNode );\n\t}\n} );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, wb );\n\n/**\n * @title WET-BOEW Responsive equal height\n * @overview Sets the same height for all elements in a container that are rendered on the same baseline (row). Adapted from http://codepen.io/micahgodbolt/pen/FgqLc.\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @thomasgohard\n */\n( function( $, window, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-eqht",\n\tselector = "." + componentName,\n\t$document = wb.doc,\n\teventTimerpoke = "timerpoke.wb",\n\tinitEvent = "wb-init" + selector,\n\tvAlignCSS = "vertical-align",\n\tvAlignDefault = "top",\n\tcontentUpdatedEvent = "wb-contentupdated",\n\tminHeightCSS = "min-height",\n\tminHeightDefault = "0",\n\tcssValueSeparator = ":",\n\tcssPropertySeparator = ";",\n\tregexCSSValue = " ?[^;]+",\n\tregexVAlign = new RegExp( vAlignCSS + cssValueSeparator + " ?" + regexCSSValue + cssPropertySeparator + "?", "i" ),\n\tregexMinHeight = new RegExp( minHeightCSS + cssValueSeparator + " ?" + regexCSSValue + cssPropertySeparator + "?", "i" ),\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector );\n\n\t\tif ( elm ) {\n\n\t\t\t// Remove the event handler since only want init fired once per page (not per element)\n\t\t\t$document.off( eventTimerpoke, selector );\n\n\t\t\tonResize();\n\n\t\t\t// Identify that initialization has completed\n\t\t\twb.ready( $document, componentName );\n\t\t}\n\t},\n\n\t/**\n\t * Re-equalise any time the window/document or a child element of \'selector\' is resized.\n\t * @method onResize\n\t */\n\tonResize = function() {\n\t\tvar $elm, $children, $anchor, currentChild, childCSS, i, j,\n\t\t\t$elms = $( selector ),\n\t\t\trow = [],\n\t\t\trowTop = -1,\n\t\t\tcurrentChildTop = -1,\n\t\t\tcurrentChildHeight = -1,\n\t\t\ttallestHeight = -1;\n\n\t\tfor ( i = $elms.length - 1; i !== -1; i -= 1 ) {\n\t\t\t$elm = $elms.eq( i );\n\t\t\t$children = $elm.find( ".eqht-trgt" );\n\t\t\tif ( !$children.length ) {\n\t\t\t\t$children = $elm.children();\n\t\t\t}\n\n\t\t\t// Reinitialize the row at the beginning of each section of equal height\n\t\t\trow = [];\n\n\t\t\t$anchor = detachElement( $elm );\n\t\t\tfor ( j = $children.length - 1; j !== -1; j -= 1 ) {\n\t\t\t\tcurrentChild = $children[ j ];\n\t\t\t\tchildCSS = currentChild.style.cssText.toLowerCase();\n\n\t\t\t\t//Ensure the CSS string ends by a seperator\n\t\t\t\tif ( childCSS.length > 0 && childCSS.substr( childCSS.length - 1 ) !== cssPropertySeparator ) {\n\t\t\t\t\tchildCSS += cssPropertySeparator;\n\t\t\t\t}\n\n\t\t\t\t// Ensure all children that are on the same baseline have the same \'top\' value.\n\t\t\t\tif ( childCSS.indexOf( vAlignCSS ) !== -1 ) {\n\t\t\t\t\tchildCSS = childCSS.replace( regexVAlign, vAlignCSS + cssValueSeparator + vAlignDefault + cssPropertySeparator );\n\t\t\t\t} else {\n\t\t\t\t\tchildCSS += " " + vAlignCSS + cssValueSeparator + vAlignDefault + cssPropertySeparator;\n\t\t\t\t}\n\n\t\t\t\t// Remove any previously set min height\n\t\t\t\tif ( childCSS.indexOf( minHeightCSS ) !== -1 ) {\n\t\t\t\t\tchildCSS = childCSS.replace( regexMinHeight, minHeightCSS + cssValueSeparator + minHeightDefault + cssPropertySeparator );\n\t\t\t\t} else {\n\t\t\t\t\tchildCSS += " " + minHeightCSS + cssValueSeparator + minHeightDefault + cssPropertySeparator;\n\t\t\t\t}\n\n\t\t\t\tcurrentChild.style.cssText = childCSS;\n\t\t\t\t$children.eq( j ).data( minHeightCSS, minHeightDefault );\n\t\t\t}\n\t\t\t$elm = reattachElement( $anchor );\n\n\t\t\t// set the top and tallest to the first element\n\t\t\trowTop = $children[ 0 ] ? $children[ 0 ].offsetTop : 0;\n\t\t\ttallestHeight = $children[ 0 ] ? $children[ 0 ].offsetHeight : 0;\n\n\t\t\t// first, the loop MUST be from start to end to work.\n\t\t\tfor ( j = 0; j < $children.length; j++ ) {\n\t\t\t\tcurrentChild = $children[ j ];\n\n\t\t\t\tcurrentChildTop = currentChild.offsetTop;\n\t\t\t\tcurrentChildHeight = currentChild.offsetHeight;\n\n\t\t\t\tif ( currentChildTop !== rowTop ) {\n\n\t\t\t\t\t// as soon as we find an element not on this row (not the same offsetTop)\n\t\t\t\t\t// we need to equalize each items in that row to align the next row.\n\t\t\t\t\tequalize( row, tallestHeight );\n\n\t\t\t\t\t// since the elements of the previous row was equalized\n\t\t\t\t\t// we need to get the new offsetTop of the current element\n\t\t\t\t\tcurrentChildTop = currentChild.offsetTop;\n\n\t\t\t\t\t// reset the row, rowTop and tallestHeight\n\t\t\t\t\trow.length = 0;\n\t\t\t\t\trowTop = currentChildTop;\n\t\t\t\t\ttallestHeight = currentChildHeight;\n\t\t\t\t}\n\n\t\t\t\ttallestHeight = Math.max( currentChildHeight, tallestHeight );\n\t\t\t\trow.push( $children.eq( j ) );\n\t\t\t}\n\n\t\t\t// equalize the last row\n\t\t\tequalize( row, tallestHeight );\n\n\t\t\t// Identify that the height equalization was updated\n\t\t\t$document.trigger( "wb-updated" + selector );\n\t\t}\n\t},\n\n\t/**\n\t* @method equalize\n\t* @param {array} row the array of items to be equalized\n\t* @param {int} tallestHeight the talest height to use to equalize\n\t*/\n\tequalize = function( row, tallestHeight ) {\n\t\tfor ( var i = 0; i < row.length; i++ ) {\n\n\t\t\t// added a +1 because some floated element got stuck if the\n\t\t\t// shortest element was the last element in the row\n\t\t\tvar minHeight = tallestHeight + 1;\n\t\t\trow[ i ][ 0 ].style.minHeight = minHeight + "px";\n\t\t}\n\t},\n\n\t/**\n\t * @method detachElement\n\t * @param {jQuery object} $elm The element to detach\n\t * @returns {object} The detached element\n\t */\n\tdetachElement = function( $elm ) {\n\t\tvar $prev = $elm.prev(),\n\t\t\t$next = $elm.next(),\n\t\t\t$parent = $elm.parent();\n\n\t\tif ( $prev.length ) {\n\t\t\t$elm.data( { anchor: $prev, anchorRel: "prev" } );\n\t\t} else if ( $next.length ) {\n\t\t\t$elm.data( { anchor: $next, anchorRel: "next" } );\n\t\t} else if ( $parent.length ) {\n\t\t\t$elm.data( { anchor: $parent, anchorRel: "parent" } );\n\t\t}\n\n\t\treturn $elm.detach();\n\t},\n\n\t/**\n\t * @method reattachElement\n\t * @param {jQuery object} $elm The element to reattach\n\t * @returns {object} The reattached element\n\t */\n\treattachElement = function( $elm ) {\n\t\tvar $anchor = $elm.data( "anchor" ),\n\t\t\tanchorRel = $elm.data( "anchorRel" );\n\n\t\tswitch ( anchorRel ) {\n\t\tcase "prev":\n\t\t\t$anchor.after( $elm );\n\t\t\tbreak;\n\t\tcase "next":\n\t\t\t$anchor.before( $elm );\n\t\t\tbreak;\n\t\tcase "parent":\n\t\t\t$anchor.append( $elm );\n\t\t\tbreak;\n\t\t}\n\n\t\treturn $elm;\n\t};\n\n// Bind the init event of the plugin\n$document.on( eventTimerpoke + " " + initEvent, selector, init );\n\n// Handle text and window resizing\n$document.on( "txt-rsz.wb win-rsz-width.wb win-rsz-height.wb " + contentUpdatedEvent + " wb-updated.wb-tables wb-update" + selector, onResize );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, wb );\n\n/**\n* @title WET-BOEW Facebook embedded page\n* @overview Helps with implementing Facebook embedded pages.\n* @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n* @author @pjackson28\n*/\n( function( $, window, wb ) {\n"use strict";\n\n\t/*\n\t* Variable and function definitions.\n\t* These are global to the plugin - meaning that they will be initialized once per page,\n\t* not once per instance of plugin on the page. So, this is a good place to define\n\t* variables that are common to all instances of the plugin on a page.\n\t*/\nvar componentName = "wb-facebook",\n\tselector = "." + componentName,\n\tinitEvent = "wb-init" + selector,\n\t$document = wb.doc,\n\tfbinited = false,\n\n\t/**\n\t* @method init\n\t* @param {jQuery Event} event Event that triggered the function call\n\t*/\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar ele = wb.init( event, componentName, selector ),\n\t\t\tprotocol = wb.pageUrlParts.protocol;\n\n\t\tif ( ele ) {\n\t\t\tModernizr.load(\n\t\t\t\t{\n\t\t\t\t\tload: [ ( protocol.indexOf( "http" ) === -1 ? "http:" : protocol ) + "//connect.facebook.net/" + wb.lang + "_US/sdk.js" ],\n\t\t\t\t\tcomplete: function() {\n\t\t\t\t\t\tif ( !fbinited ) {\n\t\t\t\t\t\t\twindow.FB.init( {\n\t\t\t\t\t\t\t\tversion: "v2.4"\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\tfbinited = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twindow.FB.XFBML.parse( ele[ 0 ] );\n\t\t\t\t\t\twb.ready( $( ele ), componentName );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t};\n\n$document.on( "timerpoke.wb " + initEvent, selector, init );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, wb );\n\n/**\n * @title WET-BOEW Favicon Plugin\n * @overview Provides the ability to add and update a page\'s favicons\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @patheard\n *\n * This plugin provides the ability to add and update the favicon\'s on a web page. Its default behaviour is to add a mobile favicon to web pages that have a favicon defined by a `<link rel=\'icon\'>` element.\n *\n * The mobile favicon\'s file name, rel, path and sizes can be set with data attributes on the `<link rel=\'icon\'/>`:\n *\n * -**data-filename:** filename of the mobile favicon (defaults to "favicon-mobile.png"). This will be appended to the favicon\'s path.\n * -**data-path:** path to the mobile favicon (defaults to using the same path as the shortcut icon).\n * -**data-rel:** rel attribute of the mobile favicon (defaults to "apple-touch-icon").\n * -**data-sizes:** sizes attribute of the mobile favicon (defaults to "57x57 72x72 114x114 144x144 150x150").\n *\n * For example, the following overides the rel and file name attributes of the mobile favicon:\n *\n *     <link href="favion.ico" rel=\'icon\' data-rel="apple-touch-icon-precomposed" data-filename="my-mobile-favicon.ico"/>\n */\n( function( $, window, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-favicon",\n\tselector = "link[rel=\'icon\']",\n\tinitEvent = "wb-init." + componentName,\n\tupdatedEvent = "wb-updated." + componentName,\n\tmobileEvent = "mobile." + componentName,\n\ticonEvent = "icon." + componentName,\n\t$document = wb.doc,\n\n\t/*\n\t * Plugin users can override these defaults by setting attributes on the html elements that the\n\t * selector matches.\n\t * For example, adding the attribute data-option1="false", will override option1 for that plugin instance.\n\t */\n\tdefaults = {\n\t\tfilename: "favicon-mobile.png",\n\t\tpath: null,\n\t\trel: "apple-touch-icon",\n\t\tsizes: "57x57 72x72 114x114 144x144 150x150"\n\t},\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector, true ),\n\t\t\t$favicon, settings;\n\n\t\tif ( elm ) {\n\t\t\t$favicon = $( elm );\n\n\t\t\t// Merge default settings with overrides from the selected plugin element.\n\t\t\tsettings = $.extend( {}, defaults, $favicon.data() );\n\n\t\t\t$favicon.trigger( mobileEvent, settings );\n\n\t\t\t// Identify that initialization has completed\n\t\t\twb.ready( $document, componentName );\n\t\t}\n\t},\n\n\t/**\n\t * Adds, or updates, the mobile favicon on a page. Mobile favicons are identified by the\n\t * `apple` prefix in the `<link>` elements rel attribute.\n\t * @method mobile\n\t * @param {DOM element} favicon Favicon element\n\t * @param {jQuery Event} event Event that triggered this handler\n\t * @param {Object} data Key-value data object passed with the event\n\t */\n\tmobile = function( favicon, event, data ) {\n\t\tvar faviconPath,\n\t\t\tfaviconMobile = $( "link[rel^=\'apple\']" ),\n\t\t\tisFaviconMobile = faviconMobile.length !== 0;\n\n\t\t// Create the mobile favicon if it doesn\'t exist\n\t\tif ( !isFaviconMobile ) {\n\t\t\tfaviconMobile = $( "<link rel=\'" + data.rel + "\' sizes=\'" + data.sizes + "\' class=\'" + componentName + "\'/>" );\n\t\t}\n\n\t\t// Only add/update a mobile favicon that was created by the plugin\n\t\tif ( faviconMobile.hasClass( componentName ) ) {\n\t\t\tfaviconPath = data.path !== null ? data.path : getPath( favicon.getAttribute( "href" ) );\n\t\t\tfaviconMobile.attr( "href", faviconPath + data.filename );\n\n\t\t\tif ( !isFaviconMobile ) {\n\t\t\t\tfavicon.parentNode.insertBefore( faviconMobile[ 0 ], favicon );\n\t\t\t}\n\t\t}\n\n\t\t$document.trigger( updatedEvent, [ "mobile" ] );\n\t},\n\n\t/**\n\t * Updates the the page\'s shortcut icon\n\t * @method icon\n\t * @param {DOM element} favicon Favicon element\n\t * @param {jQuery Event} event Event that triggered this handler\n\t * @param {Object} data Key-value data object passed with the event\n\t */\n\ticon = function( favicon, event, data ) {\n\t\tvar faviconPath = data.path !== null ? data.path : getPath( favicon.getAttribute( "href" ) );\n\t\tfavicon.setAttribute( "href", faviconPath + data.filename );\n\n\t\t$document.trigger( updatedEvent, [ "icon" ] );\n\t},\n\n\t/**\n\t * Given a full file path, returns the path without the filename\n\t * @method getPath\n\t * @param {string} filepath The full path to file, including filename\n\t * @returns {string} The path to the file\n\t */\n\tgetPath = function( filepath ) {\n\t\treturn filepath.substring( 0, filepath.lastIndexOf( "/" ) + 1 );\n\t};\n\n// Bind the init event\n$document.on( "timerpoke.wb " + initEvent, selector, init );\n\n// Bind the mobile and icon events\n$document.on( mobileEvent + " " + iconEvent, selector, function( event, data ) {\n\tvar eventTarget = event.target;\n\n\t// Filter out any events triggered by descendants\n\tif ( event.currentTarget === eventTarget ) {\n\t\tswitch ( event.type ) {\n\t\tcase "mobile":\n\t\t\tmobile( eventTarget, event, data );\n\t\t\tbreak;\n\n\t\tcase "icon":\n\t\t\ticon( eventTarget, event, data );\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Since we are working with events we want to ensure that we are being passive about our control,\n\t * so returning true allows for events to always continue\n\t */\n\treturn true;\n} );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, wb );\n\n/**\n * @title WET-BOEW Feeds\n * @overview Aggregates and displays entries from one or more Web feeds.\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @pjackson28\n */\n( function( $, window, wb, undef ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-feeds",\n\tselector = "." + componentName,\n\tfeedLinkSelector = "li > a",\n\tinitEvent = "wb-init" + selector,\n\t$document = wb.doc,\n\tpatt = /\\\\u([\\d\\w]{4})/g,\n\n\t/**\n\t * @object Templates\n\t * @properties {function}\n\t * @param {object} requires a entry object of various ATOM based properties\n\t * @returns {string} modified string with appropiate markup/format for a entry object\n\t */\n\tTemplates = {\n\n\t\t/**\n\t\t * [fickr template]\n\t\t * @param  {entry object} data\n\t\t * @return {string}\tHTML string for creating a photowall effect\n\t\t */\n\t\tflickr: function( data ) {\n\t\t\tvar media = data.media.m,\n\t\t\t\tflickrData = {\n\t\t\t\t\ttitle: data.title,\n\t\t\t\t\tthumbnail: media.replace( "_m.", "_s." ),\n\t\t\t\t\timage: media.replace( "_m", "" ),\n\t\t\t\t\tdescription: data.description.replace( /^\\s*<p>(.*?)<\\/p>\\s*<p>(.*?)<\\/p>/i, "" )\n\t\t\t\t};\n\n\t\t\t// due to CORS we cannot default to simple ajax pulls of the image. We have to inline the content box\n\t\t\treturn "<li><a class=\'feed-flickr\' href=\'javascript:;\' data-flickr=\'" +\n\t\t\t\twb.escapeAttribute( JSON.stringify( flickrData ) ) + "\'><img src=\'" + flickrData.thumbnail + "\' alt=\'" +\n\t\t\t\twb.escapeAttribute( flickrData.title ) + "\' title=\'" + wb.escapeAttribute( flickrData.title ) +\n\t\t\t\t"\' class=\'img-responsive\'/></a></li>";\n\t\t},\n\n\t\t/**\n\t\t * [Youtube template]\n\t\t * @param  {entry object} data\n\t\t * @return {string}\tHTML string for creating a photowall effect\n\t\t */\n\t\tyoutube: function( data ) {\n\t\t\tvar youtubeDate = {\n\t\t\t\ttitle: data.title,\n\t\t\t\tvideoId: data.id\n\t\t\t};\n\n\t\t\t// Due to CORS we cannot default to simple ajax pulls of the image. We have to inline the content box\n\t\t\treturn "<li class=\'col-md-4 col-sm-6 feed-youtube\' data-youtube=\'" +\n\t\t\t\twb.escapeAttribute( JSON.stringify( youtubeDate ) ) + "\'><a href=\'javascript:;\'><img src=\'" +\n\t\t\t\twb.pageUrlParts.protocol + "//img.youtube.com/vi/" + youtubeDate.videoId + "/mqdefault.jpg\' alt=\'" +\n\t\t\t\twb.escapeAttribute( youtubeDate.title ) + "\' title=\'" + wb.escapeAttribute( youtubeDate.title ) +\n\t\t\t\t"\' class=\'img-responsive\' /></a></li>";\n\t\t},\n\n\t\t/**\n\t\t * [pinterest template]\n\t\t * @param  {entry object}    data\n\t\t * @return {string}    HTML string of formatted using a simple list / anchor view\n\t\t */\n\t\tpinterest: function( data ) {\n\t\t\tvar content = fromCharCode( data.description ).replace( /<a href="\\/pin[^"]*"><img ([^>]*)><\\/a>([^<]*)(<a .*)?/, "<a href=\'" +\n\t\t\t\tdata.link + "\'><img alt=\'\' class=\'center-block\' $1><br/>$2</a>$3" );\n\t\t\treturn "<li class=\'media\'>" + content +\n\t\t\t( data.publishedDate !== "" ? " <small class=\'small feeds-date\'><time>" +\n\t\t\twb.date.toDateISO( data.publishedDate, true ) + "</time></small>" : "" ) + "</li>";\n\t\t},\n\n\t\t/**\n\t\t * [generic template]\n\t\t * @param  {entry object}\tdata\n\t\t * @return {string}\tHTML string of formatted using a simple list / anchor view\n\t\t */\n\t\tgeneric: function( data ) {\n\t\t\tvar title = data.title;\n\n\t\t\tif ( typeof( title ) === "object" ) {\n\t\t\t\tif ( title.content ) {\n\t\t\t\t\ttitle = title.content;\n\t\t\t\t} else if ( title.type === "xhtml" && title.div ) {\n\t\t\t\t\ttitle = title.div.content;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn "<li><a href=\'" + data.link + "\'>" + title + "</a><br />" +\n\t\t\t\t( data.publishedDate !== "" ? " <small class=\'feeds-date\'><time>" +\n\t\t\t\twb.date.toDateISO( data.publishedDate, true ) + "</time></small>" : "" ) + "</li>";\n\t\t}\n\t},\n\n\t/**\n\t * Helper function that returns the string representaion of a unicode character\n\t * @method decode\n\t * @param  {regex} match  unicode pattern\n\t * @param  {string} code  string where unicode is needed to be converted\n\t * @return {string}\tunicode string character\n\t */\n\tdecode = function( match, code ) {\n\t\treturn String.fromCharCode( parseInt( code, 16 ) );\n\t},\n\n\t/**\n\t * Helper wrapper function that performs unicode decodes on a string\n\t * @method fromCharCode\n\t * @param  {string} s string to sanitize with escaped unicode characters\n\t * @return {string}\tsanitized string\n\t */\n\tfromCharCode = function( s ) {\n\t\treturn s.replace( patt, decode );\n\t},\n\n\t/**\n\t * Helper function that returns a class-based set limit on plugin instances\n\t * @method getLimit\n\t * @param {DOM object} elm The element to search for a class of the form limit-5\n\t * @return {number} 0 if none found, which means the plugin default\n\t */\n\tgetLimit = function( elm ) {\n\t\tvar count = elm.className.match( /\\blimit-\\d+/ );\n\t\tif ( !count ) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn Number( count[ 0 ].replace( /limit-/i, "" ) );\n\t},\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\tfetch, url, $content, limit, feeds, fType, last, i, callback, fElem, fIcon, youtubeData, $elm;\n\t\tif ( elm ) {\n\t\t\t$elm = $( elm );\n\t\t\t$content = $elm.find( ".feeds-cont" );\n\t\t\tlimit = getLimit( elm );\n\t\t\tfeeds = $content.find( feedLinkSelector );\n\t\t\tlast = feeds.length - 1;\n\n\t\t\t// Lets bind some variables to the node to ensure safe ajax thread counting\n\n\t\t\t$content.data( "toProcess", feeds.length )\n\t\t\t\t\t.data( "feedLimit", limit )\n\t\t\t\t\t.data( "entries", [] );\n\n\t\t\tfor ( i = last; i !== -1; i -= 1 ) {\n\t\t\t\tfElem = feeds.eq( i );\n\t\t\t\tfIcon = fElem.find( "> img" );\n\n\t\t\t\tfetch = {\n\t\t\t\t\tdataType: "jsonp",\n\t\t\t\t\ttimeout: 10000\n\t\t\t\t};\n\n\t\t\t\tif ( fElem.attr( "data-ajax" ) ) {\n\n\t\t\t\t\tif ( fElem.attr( "href" ).indexOf( "flickr" ) !== -1 ) {\n\t\t\t\t\t\tfType =  "flickr";\n\t\t\t\t\t\tcallback = "jsoncallback";\n\t\t\t\t\t\t$content.data( componentName + "-postProcess", [ ".wb-lbx" ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfType = "generic";\n\t\t\t\t\t\tcallback = false;\n\t\t\t\t\t\tfetch.dataType = "json";\n\t\t\t\t\t}\n\n\t\t\t\t\t// We need a Gallery so lets add another plugin\n\t\t\t\t\t// #TODO: Lightbox review for more abstraction we should not have to add a wb.add() for overlaying\n\t\t\t\t\tfetch.url = fElem.attr( "data-ajax" );\n\t\t\t\t\tfetch.jsonp = callback;\n\t\t\t\t} else if ( fElem.attr( "data-youtube" ) ) {\n\t\t\t\t\tyoutubeData = wb.getData( fElem, "youtube" );\n\n\t\t\t\t\t$content.data( componentName + "-postProcess", [ ".wb-lbx", ".wb-mltmd" ] );\n\n\t\t\t\t\tif ( youtubeData.playlist ) {\n\t\t\t\t\t\tfElem.trigger( {\n\t\t\t\t\t\t\ttype: "data-ready.wb-feeds",\n\t\t\t\t\t\t\tfeedsData: youtubeData.playlist\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\tfeedType: "youtube",\n\t\t\t\t\t\t\t_content: $content\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\turl = fElem.attr( "href" );\n\t\t\t\t\tfetch.dataType = "xml";\n\t\t\t\t\tfetch.url = url;\n\n\t\t\t\t\t// Let\'s bind the template to the Entries\n\t\t\t\t\tif ( url.indexOf( "pinterest.com" ) > -1  ) {\n\t\t\t\t\t\tfType = "pinterest";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfType = "generic";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfetch.jsonp = callback;\n\n\t\t\t\tfetch.context = {\n\t\t\t\t\tfIcon: ( fIcon.length !== 0 ) ? fIcon.attr( "src" ) : "",\n\t\t\t\t\tfeedType: fType,\n\t\t\t\t\t_content: $content\n\t\t\t\t};\n\n\t\t\t\tfElem.trigger( {\n\t\t\t\t\ttype: "ajax-fetch.wb",\n\t\t\t\t\tfetch: fetch\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Process Feed/JSON Entries for CORS Enabled\n\t * @method corsEntry\n\t */\n\tcorsEntry = function( xmlDoc, limit ) {\n\t\tvar arr_entry = [],\n\t\t\tcorsObj = {},\n\t\t\tlimit = limit,\n\t\t\tjsonString = JSON.stringify( xmlToJson( xmlDoc ) ),\n\t\t\tjsonObj = JSON.parse( jsonString ),\n\t\t\ti, iCache;\n\t\tfor ( i = 0; i < limit; i++ ) {\n\t\t\tiCache = jsonObj.feed.entry[ i ];\n\t\t\tcorsObj = {\n\t\t\t\ttitle: iCache.title[ "#text" ],\n\t\t\t\tlink: iCache.id[ "#text" ],\n\t\t\t\tupdated: iCache.updated[ "#text" ]\n\t\t\t};\n\t\t\tarr_entry.push( corsObj );\n\t\t}\n\t\treturn arr_entry;\n\t},\n\n\t/**\n\t * Process XML to JSON\n\t * @method xmlToJson\n\t * @param  {xml}\n\t */\n\txmlToJson = function( xml ) {\n\n\t\tvar obj = {},\n\t\t\ti, iCache, nodeName, old,\n\t\t\txmlAttributes, xmlChildNodes,\n\t\t\txmlNodeType = xml.nodeType;\n\n\t\tif ( xmlNodeType === 1 ) {\n\t\t\txmlAttributes = xml.attributes;\n\t\t\tif ( xmlAttributes.length ) {\n\t\t\t\tobj[ "@attributes" ] = {};\n\t\t\t\tfor ( i = 0; i < xmlAttributes.length; i++ ) {\n\t\t\t\t\tiCache = xmlAttributes.item( i );\n\t\t\t\t\tobj[ "@attributes" ][ iCache.nodeName ] = iCache.nodeValue;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( xmlNodeType === 3 ) {\n\t\t\tobj = xml.nodeValue;\n\t\t}\n\n\t\tif ( xml.hasChildNodes() ) {\n\t\t\txmlChildNodes = xml.childNodes;\n\t\t\tfor ( i = 0; i < xmlChildNodes.length; i++ ) {\n\t\t\t\tiCache = xmlChildNodes.item( i );\n\t\t\t\tnodeName = iCache.nodeName;\n\t\t\t\tif ( typeof( obj[ nodeName ] ) === "undefined" ) {\n\t\t\t\t\tobj[ nodeName ] = xmlToJson( iCache );\n\t\t\t\t} else {\n\t\t\t\t\tif ( typeof( obj[ nodeName ].push ) === "undefined" ) {\n\t\t\t\t\t\told = obj[ nodeName ];\n\t\t\t\t\t\tobj[ nodeName ] = [];\n\t\t\t\t\t\tobj[ nodeName ].push( old );\n\t\t\t\t\t}\n\t\t\t\t\tobj[ nodeName ].push( xmlToJson( iCache ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn obj;\n\t},\n\n\t/**\n\t * Process Feed/JSON Entries\n\t * @method processEntries\n\t * @param  {data} JSON formatted data to process\n\t * @return {string} of HTML output\n\t */\n\tprocessEntries = function( data ) {\n\t\tvar items = data,\n\t\t\tentries = [],\n\t\t\ticon = this.fIcon,\n\t\t\t$content = this._content,\n\t\t\ttoProcess = $content.data( "toProcess" ),\n\t\t\ti, len;\n\n\t\tlen = items.length;\n\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\titems[ i ].fIcon =  icon;\n\n\t\t\tif ( items[ i ].publishedDate === undef ) {\n\t\t\t\titems[ i ].publishedDate = ( items[ i ].published || items[ i ].pubDate || items[ i ].updated || "" );\n\t\t\t}\n\n\t\t\tvar link = items[ i ].link;\n\n\t\t\tif ( link && link.href ) {\n\t\t\t\titems[ i ].link = link.href;\n\t\t\t}\n\n\t\t\tentries.push( items[ i ] );\n\t\t}\n\n\t\t// lets merge with latest entries\n\t\tentries = $.merge( entries, $content.data( "entries" ) );\n\n\t\tif ( toProcess === 1 ) {\n\t\t\tparseEntries( entries, $content.data( "feedLimit" ), $content, this.feedType );\n\t\t\treturn 0;\n\t\t}\n\n\t\ttoProcess -= 1;\n\t\t$content.data( {\n\t\t\t"toProcess": toProcess,\n\t\t\t"entries": entries\n\t\t} );\n\n\t\treturn toProcess;\n\t},\n\n\t/**\n\t * Parses the results from a JSON request and appends to an element\n\t * @method parseEntries\n\t * @param {object} entries Results from a JSON request.\n\t * @param {integer} limit Limit on the number of results to append to the element.\n\t * @param {jQuery DOM element} $elm Element to which the elements will be appended.\n\t * @return {url} The URL for the JSON request\n\t */\n\tparseEntries = function( entries, limit, $elm, feedtype ) {\n\t\tvar cap = ( limit > 0 && limit < entries.length ? limit : entries.length ),\n\t\t\tresult = "",\n\t\t\tcompare = wb.date.compare,\n\t\t\t$details = $elm.closest( "details" ),\n\t\t\tactivate = true,\n\t\t\tfeedContSelector = ".feeds-cont",\n\t\t\thasVisibilityHandler = "vis-handler",\n\t\t\ti, sorted, sortedEntry, $tabs;\n\n\t\tif ( feedtype !== "youtube" ) {\n\t\t\tsorted = entries.sort( function( a, b ) {\n\t\t\t\treturn compare( b.publishedDate, a.publishedDate );\n\t\t\t} );\n\t\t} else {\n\t\t\tsorted = entries;\n\t\t}\n\n\t\tfor ( i = 0; i !== cap; i += 1 ) {\n\t\t\tsortedEntry = sorted[ i ];\n\t\t\tresult += Templates[ feedtype ]( sortedEntry );\n\t\t}\n\t\t$elm.data( componentName + "-result", result );\n\n\t\t// Check to see if feed should be activated (only if visible)\n\t\t// and add handler to determine visibility\n\t\tif ( $details.length !== 0 ) {\n\t\t\tif ( $details.attr( "role" ) === "tabpanel" ) {\n\t\t\t\tif ( $details.attr( "aria-hidden" ) === "true" ) {\n\t\t\t\t\tactivate = false;\n\t\t\t\t\t$elm.empty().addClass( "waiting" );\n\t\t\t\t\t$tabs = $details.closest( ".wb-tabs" );\n\t\t\t\t\tif ( !$tabs.hasClass( hasVisibilityHandler ) ) {\n\t\t\t\t\t\t$tabs\n\t\t\t\t\t\t\t.on( "wb-updated.wb-tabs", function( event, $newPanel ) {\n\t\t\t\t\t\t\t\tvar $feedCont = $newPanel.find( feedContSelector );\n\t\t\t\t\t\t\t\tif ( !$feedCont.hasClass( "feed-active" ) ) {\n\t\t\t\t\t\t\t\t\tactivateFeed( $feedCont );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} )\n\t\t\t\t\t\t\t.addClass( hasVisibilityHandler );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if ( !$details.attr( "open" ) ) {\n\t\t\t\tactivate = false;\n\t\t\t\t$elm.empty().addClass( "waiting" );\n\t\t\t\t$details\n\t\t\t\t\t.children( "summary" )\n\t\t\t\t\t\t.on( "click.wb-feeds", function( event ) {\n\t\t\t\t\t\t\tvar $summary = $( event.currentTarget ).off( "click.wb-feeds" );\n\t\t\t\t\t\t\tactivateFeed( $summary.parent().find( feedContSelector ) );\n\t\t\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tif ( activate ) {\n\t\t\tactivateFeed( $elm );\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * Activates feed results view\n\t * @method activateFeed\n\t * @param = {jQuery object} $elm Feed container\n\t */\n\tactivateFeed = function( $elm ) {\n\t\tvar result = $elm.data( componentName + "-result" ),\n\t\t\tpostProcess = $elm.data( componentName + "-postProcess" ),\n\t\t\ti, postProcessSelector;\n\n\t\t$elm.empty()\n\t\t\t.removeClass( "waiting" )\n\t\t\t.addClass( "feed-active" )\n\t\t\t.append( result );\n\n\t\tif ( postProcess ) {\n\t\t\tfor ( i = postProcess.length - 1; i !== -1; i -= 1 ) {\n\t\t\t\tpostProcessSelector = postProcess[ i ];\n\t\t\t\t$elm.find( postProcessSelector )\n\t\t\t\t\t.trigger( "wb-init" + postProcessSelector );\n\t\t\t}\n\t\t}\n\n\t\t// Identify that the feed has now been displayed\n\t\t$elm.trigger( "wb-feed-ready" + selector );\n\t};\n\n$document.on( "ajax-fetched.wb data-ready.wb-feeds", selector + " " + feedLinkSelector, function( event, context ) {\n\tvar eventTarget = event.target,\n\t\tdata, response, $emlRss, limit, results;\n\n\t// Filter out any events triggered by descendants\n\tif ( event.currentTarget === eventTarget ) {\n\t\t$emlRss = $( eventTarget ).parentsUntil( selector ).parent();\n\t\tswitch ( event.type ) {\n\t\tcase "ajax-fetched":\n\t\t\tresponse = event.fetch.response;\n\t\t\tif ( response.documentElement ) {\n\t\t\t\tlimit = getLimit( $emlRss[ Object.keys( $emlRss )[ 0 ] ] );\n\t\t\t\tdata = corsEntry( response, limit );\n\t\t\t} else if ( response.query ) {\n\t\t\t\tresults = response.query.results;\n\t\t\t\tif ( !results ) {\n\t\t\t\t\tdata = results.item; // Flicker feeds\n\t\t\t\t\tif ( !Array.isArray( data ) ) {\n\t\t\t\t\t\tdata = [ data ];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdata = [];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdata = ( response.responseData ) ? response.responseData.feed.entries : response.items || response.feed.entry;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdata = event.feedsData;\n\t\t}\n\n\t\t// Identify that initialization has completed\n\t\t// if there are no entries left to process\n\t\tif ( processEntries.apply( context, [ data ] ) === 0 ) {\n\t\t\twb.ready( $( eventTarget ).closest( selector ), componentName );\n\t\t}\n\t}\n} );\n\n$document.on( "click", selector + " .feed-youtube", function( event ) {\n\tvar youTubeOverlaySelector  = "#wb-feeds-youtube-lbx",\n\t\t$youTubeOverlay = $( youTubeOverlaySelector ),\n\t\tyoutubeData = wb.getData( event.currentTarget, "youtube" ),\n\t\tvideoUrl = wb.pageUrlParts.protocol + "//www.youtube.com/watch?v=" + youtubeData.videoId,\n\t\tvideoSource = "<figure class=\'wb-mltmd\'><video title=\'" + youtubeData.title + "\'>" +\n\t\t\t"<source type=\'video/youtube\' src=\'" + videoUrl + "\' />" +\n\t\t\t"</video><figcaption><p>" +  youtubeData.title + "</p>" +\n\t\t\t"</figcaption></figure>";\n\n\tif ( $youTubeOverlay.length === 0 ) {\n\t\t$youTubeOverlay = $( "<section id=\'wb-feeds-youtube-lbx\' class=\'mfp-hide modal-dialog modal-content overlay-def\'>" +\n\t\t\t"<header class=\'modal-header\'><h2 class=\'modal-title\'>" + youtubeData.title + "</h2></header>" +\n\t\t\t"<div class=\'modal-body\'>" +\n\t\t\tvideoSource +\n\t\t\t"</div></section>" ).insertAfter( "main" );\n\t} else {\n\n\t\t//Modify lightbox\n\t\t$youTubeOverlay.find( ".modal-title" ).text( youtubeData.title );\n\t\t$youTubeOverlay.find( ".modal-body" ).empty().append( videoSource );\n\t}\n\n\t//Temporary fix until lightbox auto initialize the multimedia player\n\t$youTubeOverlay.find( ".wb-mltmd" ).trigger( "wb-init.wb-mltmd" );\n\n\t$( document ).trigger( "open.wb-lbx", [ {\n\t\tsrc: youTubeOverlaySelector,\n\t\ttype: "inline"\n\t} ] );\n} );\n\n$document.on( "click", selector + " .feed-flickr", function( event ) {\n\tvar flickrOverlaySelector  = "#wb-feeds-flick-lbx",\n\t\t$flickrOverlay = $( flickrOverlaySelector ),\n\t\tflickrData = wb.getData( event.currentTarget, "flickr" ),\n\t\tbody = "<img src=\'" + flickrData.image + "\' class=\'thumbnail center-block\' alt=\'" + flickrData.title + "\' /><span>" +\n\t\t\tflickrData.description + "</span>";\n\n\tif ( $flickrOverlay.length === 0 ) {\n\t\t$flickrOverlay = $( "<section id=\'wb-feeds-flick-lbx\' class=\'mfp-hide modal-dialog modal-content overlay-def\'>" +\n\t\t\t"<header class=\'modal-header\'><h2 class=\'modal-title\'>" + flickrData.title + "</h2></header>" +\n\t\t\t"<div class=\'modal-body\'>" + body + "</div></section>" ).insertAfter( "main" );\n\t} else {\n\n\t\t//Modify lightbox\n\t\t$flickrOverlay.find( ".modal-title" ).text( flickrData.title );\n\t\t$flickrOverlay.find( ".modal-body" ).empty().append( body );\n\t}\n\n\t$( document ).trigger( "open.wb-lbx", [ {\n\t\tsrc: flickrOverlaySelector,\n\t\ttype: "inline"\n\t} ] );\n} );\n\n// Bind the init event to the plugin\n$document.on( "timerpoke.wb " + initEvent, selector, init );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, wb );\n\n( function( $, window, wb ) {\n"use strict";\n\nvar componentName = "wb-filter",\n\tselector = "." + componentName,\n\tinitEvent = "wb-init" + selector,\n\t$document = wb.doc,\n\tfilterClass = "wb-fltr-out",\n\tnotFilterClassSel = ":not(." + filterClass + ")",\n\tinputClass = "wb-fltr-inpt",\n\tdtNameFltrArea = "wbfltrid",\n\tvisibleSelector = ":visible",\n\tselectorInput = "." + inputClass,\n\tdefaults = {\n\t\tstd: {\n\t\t\tselector: "li"\n\t\t},\n\t\tgrp: {\n\t\t\tselector: "li",\n\t\t\tsection: ">section"\n\t\t},\n\t\ttbl: {\n\t\t\tselector: "tr",\n\t\t\tsection: ">tbody"\n\t\t},\n\t\ttblgrp: {\n\t\t\tselector: "th:not([scope])",\n\t\t\thdnparentuntil: "tbody",\n\t\t\tsection: ">tbody"\n\t\t}\n\t},\n\ti18n, i18nText,\n\tinfoText,\n\twait,\n\n\tinit = function( event ) {\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\t$elm, elmTagName, filterUI, prependUI,\n\t\t\tsettings, setDefault,\n\t\t\tinptId, totalEntries;\n\t\tif ( elm ) {\n\t\t\t$elm = $( elm );\n\n\t\t\telmTagName = elm.nodeName;\n\t\t\tif ( [ "DIV", "SECTION", "ARTICLE" ].indexOf( elm.nodeName ) >= 0 ) {\n\t\t\t\tsetDefault = defaults.grp;\n\t\t\t\tprependUI = true;\n\t\t\t} else if ( elmTagName === "TABLE" ) {\n\t\t\t\tif ( $elm.find( "tbody" ).length > 1 ) {\n\t\t\t\t\tsetDefault = defaults.tblgrp;\n\t\t\t\t} else {\n\t\t\t\t\tsetDefault = defaults.tbl;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsetDefault = defaults.std;\n\t\t\t}\n\n\t\t\tsettings = $.extend( true, {}, setDefault, window[ componentName ], wb.getData( $elm, componentName ) );\n\t\t\t$elm.data( settings );\n\n\t\t\tif ( !i18nText ) {\n\t\t\t\ti18n = wb.i18n;\n\t\t\t\ti18nText = {\n\t\t\t\t\tfilter_label: i18n( "fltr-lbl" ),\n\t\t\t\t\tfltr_info: i18n( "fltr-info" )\n\t\t\t\t};\n\n\t\t\t\tinfoText = i18nText.fltr_info;\n\t\t\t}\n\n\t\t\tModernizr.addTest( "stringnormalize", "normalize" in String );\n\t\t\tModernizr.load( {\n\t\t\t\ttest: Modernizr.stringnormalize,\n\t\t\t\tnope: [\n\t\t\t\t\t"site!deps/unorm" + wb.getMode() + ".js"\n\t\t\t\t]\n\t\t\t} );\n\n\t\t\tif ( !elm.id ) {\n\t\t\t\telm.id = wb.getId();\n\t\t\t}\n\t\t\tinptId = elm.id + "-inpt";\n\n\t\t\ttotalEntries = $elm.find( ( settings.section || "" ) + " " + settings.selector ).length;\n\n\t\t\tfilterUI = "<div class=\\"input-group\\"><label for=\\"" + inptId + "\\" class=\\"input-group-addon\\"><span class=\\"glyphicon glyphicon-filter\\" aria-hidden=\\"true\\"></span> " + i18nText.filter_label + "</label><input id=\\"" + inptId + "\\" class=\\"form-control " + inputClass + "\\" data-" + dtNameFltrArea + "=\\"" + elm.id + "\\" type=\\"search\\"></div>" + "<p aria-live=\\"polite\\" id=\\"" + elm.id + "-info\\">" + infoFormater( totalEntries, totalEntries ) + "</p>";\n\n\t\t\tif ( prependUI ) {\n\t\t\t\t$elm.prepend( filterUI );\n\t\t\t} else {\n\t\t\t\t$elm.before( filterUI );\n\t\t\t}\n\n\t\t\twb.ready( $elm, componentName );\n\t\t}\n\t},\n\tinfoFormater = function( nbItem, total ) {\n\t\treturn infoText.\n\t\t\treplace( /_NBITEM_/g, nbItem ).\n\t\t\treplace( /_TOTAL_/g, total );\n\t},\n\n\t/*\n\t * Takes in the text from the filter box\n\t * Returns:\n\t *  An array of search words\n\t *      Special characters are escaped\n\t *      Double and single quotes removed\n\t */\n\tfilterQueryParser = function( filter ) {\n\n\t\t// Pattern to seperate the filter text into "words"\n\t\tvar pattern = /[^\\s"]+|"([^"]*)"/gi;\n\n\t\t// Make strings safe again for regex\n\t\t// Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\n\t\tfilter = filter.replace( /[.*+?^${}()|[\\]\\\\]/g, "\\\\$&" );\n\n\t\t// Apply the word match pattern and return\n\t\treturn filter.match( pattern );\n\t},\n\n\t/**\n\t * Build the Regular Expression that we are going\n\t * to use to filter content\n\t * This involves identifying the type of search being\n\t * applied and then breaking up the search string into\n\t * words\n\t */\n\tbuildSearchFilterRegularExp =  function( filterType, filter ) {\n\n\t\tvar words, wordRegExFilter = filter,\n\t\t\ti, i_len;\n\n\t\tswitch ( filterType ) {\n\n\t\tcase "and":\n\t\t\twords = filterQueryParser( filter );\n\t\t\tif ( words ) {\n\t\t\t\twordRegExFilter = ".*";\n\t\t\t\ti_len = words.length;\n\t\t\t\tfor ( i = 0; i < i_len; i++ ) {\n\t\t\t\t\twordRegExFilter = wordRegExFilter + ( "(?=.*" + words[ i ] + ")" );\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase "or": // If one word fall back on default\n\t\t\twords = filterQueryParser( filter );\n\t\t\tif ( words ) {\n\t\t\t\twordRegExFilter =  words.join( "|" );\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\n\t\t}\n\n\t\treturn new RegExp( wordRegExFilter, "i" );\n\n\t},\n\n\tfilter = function( $field, $elm, settings ) {\n\t\tvar unAccent = function( str ) {\n\t\t\t\treturn str.normalize( "NFD" ).replace( /[\\u0300-\\u036f]/g, "" );\n\t\t\t},\n\t\t\tfilter = unAccent( $field.val().trim() ),\n\t\t\tfCallBack = settings.filterCallback,\n\t\t\tsecSelector = ( settings.section || "" )  + " ",\n\t\t\thndParentSelector = settings.hdnparentuntil,\n\t\t\t$items = $elm.find( secSelector + settings.selector ),\n\t\t\titemsLength = $items.length,\n\t\t\ti, $item, text, searchFilterRegularExp;\n\n\t\t$elm.find( "." + filterClass ).removeClass( filterClass );\n\n\t\tsearchFilterRegularExp = buildSearchFilterRegularExp( settings.filterType, filter );\n\n\t\tfor ( i = 0; i < itemsLength; i += 1 ) {\n\t\t\t$item = $items.eq( i );\n\t\t\ttext = unAccent( $item.text() );\n\n\t\t\tif ( !text.match( searchFilterRegularExp ) ) {\n\t\t\t\tif ( hndParentSelector ) {\n\t\t\t\t\t$item = $item.parentsUntil( hndParentSelector );\n\t\t\t\t}\n\t\t\t\t$item.addClass( filterClass );\n\t\t\t}\n\t\t}\n\n\t\tif ( !fCallBack || typeof fCallBack !== "function"  ) {\n\t\t\tfCallBack = filterCallback;\n\t\t}\n\t\tfCallBack.apply( this, arguments );\n\n\t\t$( "#" + $elm.get( 0 ).id + "-info" ).html( infoFormater( $elm.find( secSelector + notFilterClassSel + settings.selector + visibleSelector ).length, itemsLength ) );\n\t},\n\tfilterCallback = function( $field, $elm, settings ) {\n\t\tvar $sections =\t$elm.find( settings.section + visibleSelector ),\n\t\t\tsectionsLength = $sections.length,\n\t\t\tfndSelector = notFilterClassSel + settings.selector + visibleSelector,\n\t\t\ts, $section;\n\n\t\tfor ( s = 0; s < sectionsLength; s += 1 ) {\n\t\t\t$section = $sections.eq( s );\n\t\t\tif ( $section.find( fndSelector ).length === 0 ) {\n\t\t\t\t$section.addClass( filterClass );\n\t\t\t}\n\t\t}\n\t};\n\n$document.on( "keyup", selectorInput, function( event ) {\n\tvar target = event.target,\n\t\t$input = $( target ),\n\t\t$elm = $( "#" + $input.data( dtNameFltrArea ) );\n\n\tif ( wait ) {\n\t\tclearTimeout( wait );\n\t}\n\twait = setTimeout( filter.bind( this, $input, $elm, $elm.data() ), 250 );\n\n} );\n\n$document.on( "timerpoke.wb " + initEvent, selector, init );\n\nwb.add( selector );\n} )( jQuery, window, wb );\n\n/**\n * @title WET-BOEW Footnotes\n * @overview Provides a consistent, accessible way of handling footnotes across websites.\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @EricDunsworth\n */\n( function( $, window, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-fnote",\n\tselector = "." + componentName,\n\tinitEvent = "wb-init" + selector,\n\tsetFocusEvent = "setfocus.wb",\n\t$document = wb.doc,\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\t$elm, footnoteDd, footnoteDt, i, len, dd, dt, dtId;\n\n\t\tif ( elm ) {\n\t\t\t$elm = $( elm );\n\t\t\tfootnoteDd = elm.getElementsByTagName( "dd" );\n\t\t\tfootnoteDt = elm.getElementsByTagName( "dt" );\n\n\t\t\t// Apply aria-labelledby and set initial event handlers for return to referrer links\n\t\t\tlen = footnoteDd.length;\n\t\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\t\tdd = footnoteDd[ i ];\n\t\t\t\tdt = footnoteDt[ i ];\n\t\t\t\tdtId = dd.id + "-dt";\n\t\t\t\tdd.setAttribute( "tabindex", "-1" );\n\t\t\t\tdd.setAttribute( "aria-labelledby", dtId );\n\t\t\t\tdt.id = dtId;\n\t\t\t}\n\n\t\t\t// Remove "first/premier/etc"-style text from certain footnote return links (via the child spans that hold those bits of text)\n\t\t\t$elm.find( "dd p.fn-rtn a span span" ).remove();\n\n\t\t\t// Listen for footnote reference links that get clicked\n\t\t\t$document.on( "click vclick", "main :not(" + selector + ") sup a.fn-lnk", function( event ) {\n\t\t\t\tvar eventTarget = event.target,\n\t\t\t\t\twhich = event.which,\n\t\t\t\t\trefId, $refLinkDest;\n\n\t\t\t\t// Ignore middle/right mouse button\n\t\t\t\tif ( !which || which === 1 ) {\n\t\t\t\t\trefId = "#" + wb.jqEscape( eventTarget.getAttribute( "href" ).substring( 1 ) );\n\t\t\t\t\t$refLinkDest = $document.find( refId );\n\n\t\t\t\t\t$refLinkDest.find( "p.fn-rtn a" )\n\t\t\t\t\t\t\t\t.attr( "href", "#" + eventTarget.parentNode.id );\n\n\t\t\t\t\t// Assign focus to $refLinkDest\n\t\t\t\t\t$refLinkDest.trigger( setFocusEvent );\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\t// Listen for footnote return links that get clicked\n\t\t\t$document.on( "click vclick", selector + " dd p.fn-rtn a", function( event ) {\n\t\t\t\tvar which = event.which,\n\t\t\t\t\tref,\n\t\t\t\t\trefId;\n\n\t\t\t\t// Ignore middle/right mouse button\n\t\t\t\tif ( !which || which === 1 ) {\n\t\t\t\t\tref = event.target.getAttribute( "href" );\n\n\t\t\t\t\t// Focus on associated referrer link (if the return link points to an ID)\n\t\t\t\t\tif ( ref.charAt( 0 ) === "#" ) {\n\t\t\t\t\t\trefId = "#" + wb.jqEscape( ref.substring( 1 ) );\n\n\t\t\t\t\t\t// Assign focus to the link\n\t\t\t\t\t\t$document.find( refId + " a" ).trigger( setFocusEvent );\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\t// Identify that initialization has completed\n\t\t\twb.ready( $elm, componentName );\n\t\t}\n\t};\n\n// Bind the init event of the plugin\n$document.on( "timerpoke.wb " + initEvent, selector, init );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, wb );\n\n/**\n * @title WET-BOEW Form validation\n * @overview Provides generic validation and error message handling for Web forms.\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @pjackson28\n */\n( function( $, window, document, wb ) {\n"use strict";\n\n/*\n* Variable and function definitions.\n* These are global to the plugin - meaning that they will be initialized once per page,\n* not once per instance of plugin on the page. So, this is a good place to define\n* variables that are common to all instances of the plugin on a page.\n*/\nvar componentName = "wb-frmvld",\n\tselector = "." + componentName,\n\tinitEvent = "wb-init" + selector,\n\tsetFocusEvent = "setfocus.wb",\n\t$document = wb.doc,\n\tidCount = 0,\n\ti18n, i18nText,\n\n\tdefaults = {\n\t\thdLvl: "h2",\n\t\tignore: ":hidden"\n\t},\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar eventTarget = wb.init( event, componentName, selector ),\n\t\t\telmId, modeJS;\n\n\t\tif ( eventTarget ) {\n\t\t\telmId = eventTarget.id;\n\n\t\t\t// Ensure there is a unique id on the element\n\t\t\tif ( !elmId ) {\n\t\t\t\telmId = componentName + "-id-" + idCount;\n\t\t\t\tidCount += 1;\n\t\t\t\teventTarget.id = elmId;\n\t\t\t}\n\n\t\t\t// Read the selector node for parameters\n\t\t\tmodeJS = wb.getMode() + ".js";\n\n\t\t\t// Only initialize the i18nText once\n\t\t\tif ( !i18nText ) {\n\t\t\t\ti18n = wb.i18n;\n\t\t\t\ti18nText = {\n\t\t\t\t\tcolon: i18n( "colon" ),\n\t\t\t\t\thyphen: i18n( "hyphen" ),\n\t\t\t\t\terror: i18n( "err" ),\n\t\t\t\t\terrorFound: i18n( "err-fnd" ),\n\t\t\t\t\terrorsFound: i18n( "errs-fnd" ),\n\t\t\t\t\tformNotSubmitted: i18n( "frm-nosubmit" ),\n\t\t\t\t\terrorCorrect: i18n( "err-correct" )\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tModernizr.load( {\n\n\t\t\t\t// For loading multiple dependencies\n\t\t\t\tboth: [\n\t\t\t\t\t"site!deps/jquery.validate" + modeJS,\n\t\t\t\t\t"site!deps/additional-methods" + modeJS\n\t\t\t\t],\n\t\t\t\ttestReady: function() {\n\t\t\t\t\treturn ( $.validator && $.validator.methods.bic );\n\t\t\t\t},\n\t\t\t\tcomplete: function() {\n\t\t\t\t\tvar $elm = $( "#" + elmId ),\n\t\t\t\t\t\t$form = $elm.find( "form" ),\n\t\t\t\t\t\tformDOM = $form.get( 0 ),\n\t\t\t\t\t\tformId = $form.attr( "id" ),\n\t\t\t\t\t\tlabels = formDOM.getElementsByTagName( "label" ),\n\t\t\t\t\t\t$formElms = $form.find( "input, select, textarea" ),\n\t\t\t\t\t\t$inputs = $formElms.filter( "input" ),\n\t\t\t\t\t\t$pattern = $inputs.filter( "[pattern]" ),\n\t\t\t\t\t\tsubmitted = false,\n\t\t\t\t\t\t$required = $formElms.filter( "[required], [data-rule-required], .required" ),\n\t\t\t\t\t\terrorFormId = "errors-" + ( !formId ? "default" : formId ),\n\t\t\t\t\t\tsettings = $.extend(\n\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\tdefaults,\n\t\t\t\t\t\t\twindow[ componentName ],\n\t\t\t\t\t\t\twb.getData( $elm, componentName )\n\t\t\t\t\t\t),\n\t\t\t\t\t\tsummaryHeading = settings.hdLvl,\n\t\t\t\t\t\ti, len, validator;\n\n\t\t\t\t\t// Append the aria-live region (for provide message updates to screen readers)\n\t\t\t\t\t$elm.append( "<div class=\'arialive wb-inv\' aria-live=\'polite\' aria-relevant=\'all\'></div>" );\n\n\t\t\t\t\t// Add space to the end of the labels (so separation between label and error when CSS turned off)\n\t\t\t\t\tlen = labels.length;\n\t\t\t\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\t\t\t\tlabels[ i ].innerHTML += " ";\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remove the pattern attribute until it is safe to use with jQuery Validation\n\t\t\t\t\tlen = $pattern.length;\n\t\t\t\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\t\t\t\t$pattern.eq( i ).removeAttr( "pattern" );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Change form attributes and values that interfere with validation in IE7/8\n\t\t\t\t\t// TODO: Need better way of dealing with this rather than browser sniffing\n\t\t\t\t\tif ( wb.ieVersion > 0 && wb.ieVersion < 9 ) {\n\t\t\t\t\t\tlen = $required.length;\n\t\t\t\t\t\t$required.removeAttr( "required" );\n\t\t\t\t\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\t\t\t\t\t$required[ i ].setAttribute( "data-rule-required", "true" );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$inputs.filter( "[type=date]" ).each( function() {\n\t\t\t\t\t\t\tvar $this = $( this ),\n\t\t\t\t\t\t\t\t$parent = $this.wrap( "<div/>" ).parent(),\n\t\t\t\t\t\t\t\tnewElm = $( $parent.html().replace( "type=date", "type=text" ) );\n\t\t\t\t\t\t\t$parent.replaceWith( newElm );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\t$formElms = $form.find( "input, select, textarea" );\n\t\t\t\t\t}\n\n\t\t\t\t\t// The jQuery validation plug-in in action\n\t\t\t\t\tvalidator = $form.validate( {\n\t\t\t\t\t\tmeta: "validate",\n\t\t\t\t\t\tfocusInvalid: false,\n\t\t\t\t\t\tignore: settings.ignore,\n\n\t\t\t\t\t\t// Set the element which will wrap the inline error messages\n\t\t\t\t\t\terrorElement: "strong",\n\n\t\t\t\t\t\t// Location for the inline error messages\n\t\t\t\t\t\t// In this case we will place them in the associated label element\n\t\t\t\t\t\terrorPlacement: function( $error, $element ) {\n\t\t\t\t\t\t\tvar type = $element.attr( "type" ),\n\t\t\t\t\t\t\t\tgroup = $element.attr( "data-rule-require_from_group" ),\n\t\t\t\t\t\t\t\t$fieldset, $legend;\n\n\t\t\t\t\t\t\t$error.data( "element-id", $element.attr( "id" ) );\n\t\t\t\t\t\t\tif ( type ) {\n\t\t\t\t\t\t\t\ttype = type.toLowerCase();\n\t\t\t\t\t\t\t\tif ( type === "radio" || type === "checkbox" ) {\n\t\t\t\t\t\t\t\t\t$fieldset = $element.closest( "fieldset" );\n\t\t\t\t\t\t\t\t\tif ( $fieldset.length !== 0 ) {\n\t\t\t\t\t\t\t\t\t\t$legend = $fieldset.find( "legend" ).first();\n\t\t\t\t\t\t\t\t\t\tif ( $legend.length !== 0 && $fieldset.find( "input[name=\'" + $element.attr( "name" ) + "\']" ) !== 1 ) {\n\t\t\t\t\t\t\t\t\t\t\t$error.appendTo( $legend );\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( group ) {\n\t\t\t\t\t\t\t\t$fieldset = $element.closest( "fieldset" );\n\t\t\t\t\t\t\t\tif ( $fieldset.length !== 0 ) {\n\t\t\t\t\t\t\t\t\t$legend = $fieldset.find( "legend" ).first();\n\t\t\t\t\t\t\t\t\tif ( $legend.length !== 0 && $fieldset.find( "input[name=\'" + $element.attr( "name" ) + "\']" ) !== 1 ) {\n\t\t\t\t\t\t\t\t\t\tvar $strong = $legend.find( "strong.error" ),\n\t\t\t\t\t\t\t\t\t\t\tid = $legend.attr( "id" );\n\n\t\t\t\t\t\t\t\t\t\tif ( $strong.length > 0 ) {\n\t\t\t\t\t\t\t\t\t\t\t$strong.remove();\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( !id ) {\n\t\t\t\t\t\t\t\t\t\t\tid = "required-group-" + idCount;\n\t\t\t\t\t\t\t\t\t\t\tidCount += 1;\n\n\t\t\t\t\t\t\t\t\t\t\t$legend.attr( "id", id );\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t$error.data( "element-id", id );\n\t\t\t\t\t\t\t\t\t\t$error.attr( "id", id );\n\t\t\t\t\t\t\t\t\t\t$error.appendTo( $legend );\n\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//Std If we have a label and the input field is inside the label\n\t\t\t\t\t\t\t// need to add a css-implicite-input\n\t\t\t\t\t\t\tif ( $form.find( "label" ).find( "input[name=\'" + $element.attr( "name" ) + "\']" ).length > 0 ) {\n\t\t\t\t\t\t\t\t$error.insertBefore( $form.find( "input[name=\'" + $element.attr( "name" ) + "\']" ) );\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t$error.appendTo( $form.find( "label[for=\'" + $element.attr( "id" ) + "\']" ) );\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Create our error summary that will appear before the form\n\t\t\t\t\t\tshowErrors: function( errorMap ) {\n\t\t\t\t\t\t\tthis.defaultShowErrors();\n\t\t\t\t\t\t\tvar $errors = $form.find( ".wb-server-error, strong.error" ).filter( ":not(:hidden)" ),\n\t\t\t\t\t\t\t\t$errorfields = $form.find( "input.error, select.error, textarea.error" ),\n\t\t\t\t\t\t\t\tprefixStart = "<span class=\'prefix\'>" + i18nText.error + "&#160;",\n\t\t\t\t\t\t\t\tprefixEnd = i18nText.colon + " </span>",\n\t\t\t\t\t\t\t\tseparator = i18nText.hyphen,\n\t\t\t\t\t\t\t\tariaLive = $form.parent().find( ".arialive" )[ 0 ],\n\t\t\t\t\t\t\t\t$summaryContainer, summary, key, i, len, $error, prefix, $fieldName, $fieldset, label, labelString;\n\n\t\t\t\t\t\t\t// Correct the colouring of fields that are no longer invalid\n\t\t\t\t\t\t\t$form\n\t\t\t\t\t\t\t\t.find( ".has-error [aria-invalid=false]" )\n\t\t\t\t\t\t\t\t.closest( ".has-error" )\n\t\t\t\t\t\t\t\t.removeClass( "has-error" );\n\n\t\t\t\t\t\t\tif ( $errors.length !== 0 ) {\n\n\t\t\t\t\t\t\t\t// Post process\n\t\t\t\t\t\t\t\tsummary = "<" + summaryHeading + ">" +\n\t\t\t\t\t\t\t\t\ti18nText.formNotSubmitted + $errors.length +\n\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\t$errors.length !== 1 ?\n\t\t\t\t\t\t\t\t\t\ti18nText.errorsFound :\n\t\t\t\t\t\t\t\t\t\ti18nText.errorFound\n\t\t\t\t\t\t\t\t\t) + "</" + summaryHeading + "><ul>";\n\t\t\t\t\t\t\t\t$errorfields\n\t\t\t\t\t\t\t\t\t.closest( ".form-group" )\n\t\t\t\t\t\t\t\t\t.addClass( "has-error" );\n\t\t\t\t\t\t\t\tlen = $errors.length;\n\t\t\t\t\t\t\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\t\t\t\t\t\t\t$error = $errors.eq( i );\n\t\t\t\t\t\t\t\t\tprefix = prefixStart + ( i + 1 ) + prefixEnd;\n\t\t\t\t\t\t\t\t\t$fieldName = $error.closest( "label" ).find( ".field-name" );\n\n\t\t\t\t\t\t\t\t\t// Try to find the field name in the legend (if one exists)\n\t\t\t\t\t\t\t\t\tif ( $fieldName.length === 0 ) {\n\t\t\t\t\t\t\t\t\t\t$fieldset = $error.closest( "fieldset" );\n\t\t\t\t\t\t\t\t\t\tif ( $fieldset.length !== 0 ) {\n\t\t\t\t\t\t\t\t\t\t\t$fieldName = $fieldset.find( "legend .field-name" );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t$error.find( "span.prefix" ).detach();\n\n\t\t\t\t\t\t\t\t\t//Verify if it is a wb-server-error\n\t\t\t\t\t\t\t\t\tif ( $errors[ i ].classList.contains( "wb-server-error" ) ) {\n\t\t\t\t\t\t\t\t\t\tif ( $errors[ i ].id ) {\n\t\t\t\t\t\t\t\t\t\t\tvar myParent = document.getElementById( $errors[ i ].id ).parentElement;\n\t\t\t\t\t\t\t\t\t\t\tif ( myParent === null ) {\n\t\t\t\t\t\t\t\t\t\t\t\tsummary += "<li><a>" + prefix + ( $fieldName.length !== 0 ? $fieldName.html() + separator : "" ) + $error.text() + separator + i18nText.errorCorrect + "</a></li>";\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tif ( myParent.hasAttribute( "for" ) && myParent.getAttribute( "for" ).length > 0 ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tsummary += "<li><a href=\'#" + myParent.getAttribute( "for" ) + "\'>" + prefix + ( $fieldName.length !== 0 ? $fieldName.html() + separator : "" ) + $error.text() + separator + i18nText.errorCorrect + "</a></li>";\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif ( myParent.getElementsByTagName( "input" )[ 0 ] && myParent.getElementsByTagName( "input" )[ 0 ].name.length > 0 ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsummary += "<li><a href=\'#" + myParent.getElementsByTagName( "input" )[ 0 ].id + "\'>" + prefix + ( $fieldName.length !== 0 ? $fieldName.html() + separator : "" ) + $error.text() + separator + i18nText.errorCorrect + "</a></li>";\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ( myParent.tagName === ( "LEGEND" ) && ( myParent.parentElement.getElementsByTagName( "input" )[ 0 ].type === "checkbox" || myParent.parentElement.getElementsByTagName( "input" )[ 0 ].type === "radio" && myParent.parentElement.getElementsByTagName( "input" )[ 0 ].name.length > 0 ) ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsummary += "<li><a href=\'#" + myParent.parentElement.getElementsByTagName( "input" )[ 0 ].id + "\'>" + prefix + ( $fieldName.length !== 0 ? $fieldName.html() + separator : "" ) + $error.text() + separator + i18nText.errorCorrect + "</a></li>";\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsummary += "<li><a>" + prefix + ( $fieldName.length !== 0 ? $fieldName.html() + separator : "" ) + $error.text() + separator + i18nText.errorCorrect + "</a></li>";\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t$error.html( "<strong>" + prefix + $error.text() + "</strong>" );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tsummary += "<li><a href=\'#" + $error.data( "element-id" ) + "\'>" + prefix + ( $fieldName.length !== 0 ? $fieldName.html() + separator : "" ) + $error.text() + "</a></li>";\n\t\t\t\t\t\t\t\t\t\t$error.html( "<span class=\'label label-danger\'>" + prefix + $error.text() + "</span>" );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsummary += "</ul>";\n\n\t\t\t\t\t\t\t\tif ( !submitted ) {\n\n\t\t\t\t\t\t\t\t\t// Update the aria-live region as necessary\n\t\t\t\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\t\t\t\tfor ( key in errorMap ) {\n\t\t\t\t\t\t\t\t\t\tif ( errorMap.hasOwnProperty( key ) ) {\n\t\t\t\t\t\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif ( i !== 0 ) {\n\t\t\t\t\t\t\t\t\t\tlen = $errors.length;\n\t\t\t\t\t\t\t\t\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\t\t\t\t\t\t\t\t\tlabel = $errors[ i ].parentNode;\n\t\t\t\t\t\t\t\t\t\t\tif ( label.getAttribute( "for" ) === key ) {\n\t\t\t\t\t\t\t\t\t\t\t\tlabelString = label.innerHTML;\n\t\t\t\t\t\t\t\t\t\t\t\tif ( labelString !== ariaLive.innerHTML ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tariaLive.innerHTML = labelString;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if ( ariaLive.innerHTML.length !== 0 ) {\n\t\t\t\t\t\t\t\t\t\tariaLive.innerHTML = "";\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Delay updating the summary container in case a summary link was clicked\n\t\t\t\t\t\t\t\tsetTimeout( function() {\n\t\t\t\t\t\t\t\t\t$summaryContainer = $form.find( "#" + errorFormId );\n\n\t\t\t\t\t\t\t\t\t// Output our error summary and place it in the error container\n\t\t\t\t\t\t\t\t\t// Create our container if one doesn\'t already exist\n\t\t\t\t\t\t\t\t\tif ( $summaryContainer.length === 0 ) {\n\t\t\t\t\t\t\t\t\t\t$summaryContainer = $( "<section id=\'" + errorFormId + "\' class=\'alert alert-danger\' tabindex=\'-1\'>" + summary + "</section>" ).prependTo( $form );\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t$summaryContainer.empty().append( summary );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Put focus on the error if the errors are generated by an attempted form submission\n\t\t\t\t\t\t\t\t\tif ( submitted ) {\n\n\t\t\t\t\t\t\t\t\t\t// Assign focus to $summaryContainer\n\t\t\t\t\t\t\t\t\t\t$summaryContainer.trigger( setFocusEvent );\n\t\t\t\t\t\t\t\t\t\tsubmitted = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}, 100 );\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Update the aria-live region as necessary\n\t\t\t\t\t\t\t\tif ( ariaLive.innerHTML.length !== 0 ) {\n\t\t\t\t\t\t\t\t\tariaLive.innerHTML = "";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$form.find( "#" + errorFormId ).detach();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t/* End of showErrors() */\n\n\t\t\t\t\t\tinvalidHandler: function() {\n\t\t\t\t\t\t\tsubmitted = true;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t/* adds on tab validation */\n\t\t\t\t\t\tonfocusout: function( element ) {\n\t\t\t\t\t\t\tthis.element( element );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} ); /* end of validate() */\n\n\t\t\t\t\t/* fixes validation issue (see PR #7913) */\n\t\t\t\t\t$form.on( "change", "input[type=date], input[type=file], select", function() {\n\t\t\t\t\t\t$form.validate().element( this );\n\t\t\t\t\t} );\n\n\t\t\t\t\t// Clear the form and remove error messages on reset\n\t\t\t\t\t$document.on( "click vclick touchstart", selector + " input[type=reset]", function( event ) {\n\t\t\t\t\t\tvar which = event.which,\n\t\t\t\t\t\t\tariaLive;\n\n\t\t\t\t\t\t// Ignore middle/right mouse buttons\n\t\t\t\t\t\tif ( !which || which === 1 ) {\n\t\t\t\t\t\t\tvalidator.resetForm();\n\t\t\t\t\t\t\t$( "#" + errorFormId ).detach();\n\n\t\t\t\t\t\t\tariaLive = $form.parent().find( ".arialive" )[ 0 ];\n\t\t\t\t\t\t\tif ( ariaLive.innerHTML.length !== 0 ) {\n\t\t\t\t\t\t\t\tariaLive.innerHTML = "";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Correct the colouring of fields that are no longer invalid\n\t\t\t\t\t\t\t$form.find( ".has-error" ).removeClass( "has-error" );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\n\t\t\t\t\t//Trigger validation on wb-server-error\n\t\t\t\t\t$form.find( ".wb-server-error" ).filter( ":not( :hidden )" ).parent().each( function() {\n\t\t\t\t\t\tif ( this.attributes.for && this.attributes.for.value.length > 0 ) {\n\t\t\t\t\t\t\t$( "form" ).validate().element( $( "[id =" + this.attributes.for.value + "]" ) );\n\t\t\t\t\t\t} else if ( $( this ).find( "input" )[ 0 ] ) {\n\t\t\t\t\t\t\t$( "form" ).validate().element( $( this ).find( "input" )[ 0 ] );\n\t\t\t\t\t\t} else if ( $( this ).next( ".radio, .checkbox" ).children( "label" ).children( "input" )[ 0 ] ) {\n\t\t\t\t\t\t\tif ( $( this ).find( $( this ).next( ".radio, .checkbox" ).children( "label" ).children( "input " )[ 0 ].id ) ) {\n\t\t\t\t\t\t\t\t$( "form" ).validate().element( $( this ).next( ".radio, .checkbox" ).children( "label" ).children( "input" )[ 0 ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\n\t\t\t\t\t// Tell the i18n file to execute to run any $.validator extends\n\t\t\t\t\t$form.trigger( "formLanguages.wb" );\n\n\t\t\t\t\t// Identify that initialization has completed\n\t\t\t\t\twb.ready( $( eventTarget ), componentName );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t};\n\n// Bind the init event of the plugin\n$document.on( "timerpoke.wb " + initEvent, selector, init );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, document, wb );\n\n/*\n * @title WET-BOEW Geomap\n * @overview Displays a dynamic map over which information from additional sources can be overlaid.\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @pjackson28\n */\n( function( $, wb ) {\n"use strict";\n\nvar componentName = "wb-geomap",\n\tselector = "." + componentName,\n\tinitEvent = "wb-init" + selector,\n\t$document = wb.doc,\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\t$elm, modeJS;\n\n\t\tif ( elm ) {\n\t\t\t$elm = $( elm );\n\t\t\tmodeJS = wb.getMode() + ".js";\n\n\t\t\tModernizr.load( [ {\n\n\t\t\t\t// For loading multiple dependencies\n\t\t\t\tboth: [\n\t\t\t\t\t"site!deps/proj4" + modeJS,\n\t\t\t\t\t"site!deps/OpenLayers" + modeJS,\n\t\t\t\t\t"site!deps/geomap-lib" + modeJS\n\t\t\t\t],\n\t\t\t\tcomplete: function() {\n\t\t\t\t\t$elm.trigger( "geomap.wb" );\n\t\t\t\t}\n\t\t\t} ] );\n\t\t}\n\t};\n\n// Bind the init function to the timerpoke event\n$document.on( "timerpoke.wb " + initEvent, selector, init );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, wb );\n\n/**\n * @title WET-BOEW Lightbox\n * @overview Helps build a photo gallery on a web page.\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @pjackson28\n */\n( function( $, window, document, wb, undef ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-lbx",\n\tselector = "." + componentName,\n\tinitEvent = "wb-init" + selector,\n\tsetFocusEvent = "setfocus.wb",\n\tdependenciesLoadedEvent = "deps-loaded" + selector,\n\tmodalHideSelector = "#wb-tphp, body > header, body > main, body > footer",\n\t$document = wb.doc,\n\tcallbacks, i18n, i18nText,\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\telmId;\n\n\t\tif ( elm ) {\n\t\t\telmId = elm.id;\n\n\t\t\t// Ensure the dependencies are loaded first\n\t\t\t$document.one( dependenciesLoadedEvent, function() {\n\t\t\t\tvar elm = document.getElementById( elmId ),\n\t\t\t\t\t$elm = $( elm ),\n\t\t\t\t\tsettings = {},\n\t\t\t\t\tfirstLink;\n\n\t\t\t\tif ( !elm ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// TODO: Add swipe support\n\n\t\t\t\tsettings.callbacks = callbacks;\n\n\t\t\t\tif ( elm.nodeName.toLowerCase() !== "a" ) {\n\t\t\t\t\tsettings.delegate = "a:not(" + selector + "-skip)";\n\t\t\t\t\tfirstLink = elm.getElementsByTagName( "a" )[ 0 ];\n\n\t\t\t\t\t// Is the element a gallery?\n\t\t\t\t\tif ( elm.className.indexOf( "-gal" ) !== -1 ) {\n\t\t\t\t\t\tsettings.gallery = {\n\t\t\t\t\t\t\tenabled: true\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfirstLink = elm;\n\t\t\t\t}\n\n\t\t\t\tif ( firstLink ) {\n\t\t\t\t\tif ( firstLink.getAttribute( "href" ).charAt( 0 ) === "#" ) {\n\t\t\t\t\t\tsettings.type = "inline";\n\t\t\t\t\t} else if ( firstLink.className.indexOf( "lbx-iframe" ) !== -1 ) {\n\t\t\t\t\t\tsettings.type = "iframe";\n\t\t\t\t\t} else if ( firstLink.getElementsByTagName( "img" ).length === 0 ) {\n\t\t\t\t\t\tsettings.type = "ajax";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsettings.type = "image";\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( elm.className.indexOf( "lbx-modal" ) !== -1 ) {\n\t\t\t\t\t\tsettings.modal = true;\n\t\t\t\t\t}\n\t\t\t\t\tif ( elm.className.indexOf( "lbx-ajax" ) !== -1 ) {\n\t\t\t\t\t\tsettings.type = "ajax";\n\t\t\t\t\t}\n\t\t\t\t\tif ( elm.className.indexOf( "lbx-image" ) !== -1 ) {\n\t\t\t\t\t\tsettings.type = "image";\n\t\t\t\t\t}\n\t\t\t\t\tif ( elm.className.indexOf( "lbx-inline" ) !== -1 ) {\n\t\t\t\t\t\tsettings.type = "inline";\n\t\t\t\t\t}\n\n\t\t\t\t\t// Extend the settings with window[ "wb-lbx" ] then data-wb-lbx\n\t\t\t\t\tsettings = $.extend(\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tsettings,\n\t\t\t\t\t\twindow[ componentName ],\n\t\t\t\t\t\twb.getData( $elm, componentName )\n\t\t\t\t\t);\n\t\t\t\t\t$elm.magnificPopup(\n\t\t\t\t\t\tsettings\n\t\t\t\t\t).data( "wbLbxFilter", settings.filter );\n\t\t\t\t}\n\n\t\t\t\t// Identify that initialization has completed\n\t\t\t\twb.ready( $elm, componentName );\n\t\t\t} );\n\n\t\t\t// Load dependencies as needed\n\t\t\tsetup();\n\t\t}\n\t},\n\n\t/**\n\t * @method setup\n\t */\n\tsetup = function() {\n\n\t\t// Only initialize the i18nText and callbacks once\n\t\tif ( !i18nText ) {\n\t\t\ti18n = wb.i18n;\n\t\t\ti18nText = {\n\t\t\t\tfClose: i18n( "close" ),\n\t\t\t\ttClose: i18n( "overlay-close" ) + i18n( "space" ) + i18n( "esc-key" ),\n\t\t\t\ttLoading: i18n( "load" ),\n\t\t\t\tgallery: {\n\t\t\t\t\ttPrev: i18n( "prv-l" ),\n\t\t\t\t\ttNext: i18n( "nxt-r" ),\n\t\t\t\t\ttCounter: i18n( "lb-curr" )\n\t\t\t\t},\n\t\t\t\timage: {\n\t\t\t\t\ttError: i18n( "lb-img-err" ) + " (<a href=\\"url%\\">)"\n\t\t\t\t},\n\t\t\t\tajax: {\n\t\t\t\t\ttError: i18n( "lb-xhr-err" ) + " (<a href=\\"url%\\">)"\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tcallbacks = {\n\t\t\t\topen: function() {\n\n\t\t\t\t\t// TODO: Better if dealt with upstream by Magnific popup\n\t\t\t\t\tvar $item = this.currItem,\n\t\t\t\t\t\t$content = this.contentContainer,\n\t\t\t\t\t\t$wrap = this.wrap,\n\t\t\t\t\t\t$modal = $wrap.find( ".modal-dialog" ),\n\t\t\t\t\t\t$buttons = $wrap.find( ".mfp-close, .mfp-arrow" ),\n\t\t\t\t\t\tlen = $buttons.length,\n\t\t\t\t\t\ti, button;\n\n\t\t\t\t\tcreateCloseButton( $modal );\n\n\t\t\t\t\t$document.find( "body" ).addClass( "wb-modal" );\n\t\t\t\t\t$document.find( modalHideSelector ).attr( "aria-hidden", "true" );\n\t\t\t\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\t\t\t\tbutton = $buttons[ i ];\n\t\t\t\t\t\tbutton.innerHTML += "<span class=\'wb-inv\'> " + button.title + "</span>";\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( $item.type === "image" ) {\n\t\t\t\t\t\t$content.find( ".mfp-bottom-bar" ).attr( "id", "lbx-title" );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$content.attr( "role", "document" );\n\t\t\t\t\t}\n\n\t\t\t\t\t$wrap.append( "<span tabindex=\'0\' class=\'lbx-end wb-inv\'></span>" )\n\t\t\t\t\t\t.find( ".activate-open" )\n\t\t\t\t\t\t.trigger( "wb-activate" );\n\n\t\t\t\t\tthis.contentContainer.attr( "data-pgtitle", document.getElementsByTagName( "H1" )[ 0 ].textContent );\n\t\t\t\t},\n\t\t\t\tclose: function() {\n\t\t\t\t\t$document.find( "body" ).removeClass( "wb-modal" );\n\t\t\t\t\t$document.find( modalHideSelector ).removeAttr( "aria-hidden" );\n\t\t\t\t},\n\t\t\t\tchange: function() {\n\t\t\t\t\tvar $item = this.currItem,\n\t\t\t\t\t\t$content = this.contentContainer,\n\t\t\t\t\t\t$el, $bottomBar, $source, $target,\n\t\t\t\t\t\tdescription, altTitleId, altTitle;\n\n\t\t\t\t\tif ( $item.type === "image" ) {\n\t\t\t\t\t\t$el = $item.el;\n\t\t\t\t\t\t$target = $item.img;\n\t\t\t\t\t\t$bottomBar = $content.find( ".mfp-bottom-bar" );\n\n\t\t\t\t\t\tif ( $el ) {\n\t\t\t\t\t\t\t$source = $el.find( "img" );\n\t\t\t\t\t\t\t$target.attr( "alt", $source.attr( "alt" ) );\n\n\t\t\t\t\t\t\t// Replicate aria-describedby if it exists\n\t\t\t\t\t\t\tdescription = $source.attr( "aria-describedby" );\n\t\t\t\t\t\t\tif ( description ) {\n\t\t\t\t\t\t\t\t$target.attr( "aria-describedby", description );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Replicate longdesc if it exists\n\t\t\t\t\t\t\tdescription = $source.attr( "longdesc" );\n\t\t\t\t\t\t\tif ( description ) {\n\t\t\t\t\t\t\t\t$target.attr( "longdesc", description );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Handle alternate titles\n\t\t\t\t\t\t\taltTitleId = $el.attr( "data-title" );\n\t\t\t\t\t\t\tif ( altTitleId ) {\n\t\t\t\t\t\t\t\taltTitle = document.getElementById( altTitleId );\n\t\t\t\t\t\t\t\tif ( altTitle !== null ) {\n\t\t\t\t\t\t\t\t\t$bottomBar.find( ".mfp-title" ).html( altTitle.innerHTML );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$target.attr( "alt", $bottomBar.find( ".mfp-title" ).html() );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$content\n\t\t\t\t\t\t\t.find( ".modal-title, h1" )\n\t\t\t\t\t\t\t.first()\n\t\t\t\t\t\t\t.attr( "id", "lbx-title" );\n\t\t\t\t\t}\n\n\t\t\t\t\t$content.attr( "aria-labelledby", "lbx-title" );\n\t\t\t\t},\n\t\t\t\tparseAjax: function( mfpResponse ) {\n\t\t\t\t\tvar currItem = this.currItem,\n\t\t\t\t\t\tcurrEl = currItem.el,\n\t\t\t\t\t\turlHash = currItem.src.split( "#" )[ 1 ],\n\t\t\t\t\t\tfilter = currEl ? currEl.data( "wbLbxFilter" ) : undef,\n\t\t\t\t\t\tselector = filter || ( urlHash ? "#" + urlHash : false ),\n\t\t\t\t\t\t$response;\n\n\t\t\t\t\t// Provide the ability to filter the AJAX response HTML\n\t\t\t\t\t// by the URL hash or a selector\n\t\t\t\t\t// TODO: Should be dealt with upstream by Magnific Popup\n\t\t\t\t\tif ( selector ) {\n\t\t\t\t\t\t$response = $( "<div>" + mfpResponse.data + "</div>" ).find( selector );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$response = $( mfpResponse.data );\n\t\t\t\t\t}\n\t\t\t\t\tcreateCloseButton( $response );\n\n\t\t\t\t\t$response\n\t\t\t\t\t\t.find( ".modal-title, h1" )\n\t\t\t\t\t\t\t.first()\n\t\t\t\t\t\t\t\t.attr( "id", "lbx-title" );\n\n\t\t\t\t\tmfpResponse.data = $response;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// Load Magnific Popup dependency and bind the init event handler\n\t\tModernizr.load( {\n\t\t\tload: "site!deps/jquery.magnific-popup" + wb.getMode() + ".js",\n\t\t\ttestReady: function() {\n\t\t\t\treturn $.magnificPopup;\n\t\t\t},\n\t\t\tcomplete: function() {\n\n\t\t\t\t// Set the dependency i18nText only once\n\t\t\t\t$.extend( true, $.magnificPopup.defaults, i18nText );\n\n\t\t\t\t$document.trigger( dependenciesLoadedEvent );\n\t\t\t}\n\t\t} );\n\t},\n\tcreateCloseButton = function( $modal ) {\n\t\tif ( $modal !== null && $modal.hasClass( "modal-dialog" ) ) {\n\t\t\tvar footer = $modal.find( ".modal-footer" ).first(),\n\t\t\t\thasFooter = footer.length,\n\t\t\t\thasButton = hasFooter && $( footer ).find( ".popup-modal-dismiss" ).length !== 0,\n\t\t\t\tcloseClassFtr = "popup-modal-dismiss",\n\t\t\t\tcloseTextFtr = i18nText.fClose,\n\t\t\t\tspanTextFtr, overlayCloseFtr;\n\n\t\t\tif ( !hasButton ) {\n\t\t\t\tif ( hasFooter ) {\n\t\t\t\t\tspanTextFtr = footer.innerHTML + i18nText.tClose;\n\t\t\t\t} else {\n\t\t\t\t\tfooter = document.createElement( "div" );\n\t\t\t\t\tfooter.setAttribute( "class", "modal-footer" );\n\t\t\t\t\tspanTextFtr = i18nText.tClose;\n\t\t\t\t}\n\t\t\t\tspanTextFtr = spanTextFtr.replace( "\'", "&#39;" );\n\n\t\t\t\toverlayCloseFtr = "<button type=\'button\' class=\'btn btn-sm btn-primary pull-left " + closeClassFtr +\n\t\t\t\t\t"\' title=\'" + closeTextFtr + " " + spanTextFtr + "\'>" +\n\t\t\t\t\tcloseTextFtr +\n\t\t\t\t\t"<span class=\'wb-inv\'>" + spanTextFtr + "</span></button>";\n\n\t\t\t\t$( footer ).append( overlayCloseFtr );\n\t\t\t\tif ( !hasFooter ) {\n\t\t\t\t\t$modal.append( footer );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n// Bind the init event of the plugin\n$document.on( "timerpoke.wb " + initEvent, selector, init );\n\n// Handler for clicking on a same page link within the overlay to outside the overlay\n$document.on( "click vclick", ".mfp-wrap a[href^=\'#\']", function( event ) {\n\tvar which = event.which,\n\t\teventTarget = event.target,\n\t\t$lightbox, linkTarget;\n\n\t// Ignore middle/right mouse buttons\n\tif ( !which || which === 1 ) {\n\t\t$lightbox = $( eventTarget ).closest( ".mfp-wrap" );\n\t\tlinkTarget = document.getElementById( eventTarget.getAttribute( "href" ).substring( 1 ) );\n\n\t\t// Ignore same page links to within the overlay\n\t\tif ( linkTarget && !$.contains( $lightbox[ 0 ], linkTarget ) ) {\n\n\t\t\t// Stop propagation of the click event\n\t\t\tif ( event.stopPropagation ) {\n\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t} else {\n\t\t\t\tevent.cancelBubble = true;\n\t\t\t}\n\n\t\t\t// Close the overlay and set focus to the same page link\n\t\t\t$.magnificPopup.close();\n\t\t\t$( linkTarget ).trigger( setFocusEvent );\n\t\t}\n\t}\n} );\n\n// Event handler for closing a modal popup\n$( document ).on( "click", ".popup-modal-dismiss", function( event ) {\n\tevent.preventDefault();\n\t$.magnificPopup.close();\n} );\n\n// Event handler for opening a popup without a link\n$( document ).on( "open" + selector, function( event, items, modal, title, ajax ) {\n\tif ( event.namespace === componentName ) {\n\t\tvar isGallery = items.length > 1,\n\t\t\tisModal = modal && !isGallery ? modal : false,\n\t\t\ttitleSrc = title ? function() {\n\t\t\t\treturn title[ $.magnificPopup.instance.index ];\n\t\t\t} : "title";\n\n\t\tevent.preventDefault();\n\n\t\t// Ensure the dependencies are loaded first\n\t\t$document.one( dependenciesLoadedEvent, function() {\n\t\t\t$.magnificPopup.open( {\n\t\t\t\titems: items,\n\t\t\t\tmodal: isModal,\n\t\t\t\tgallery: {\n\t\t\t\t\tenabled: isGallery\n\t\t\t\t},\n\t\t\t\timage: {\n\t\t\t\t\ttitleSrc: titleSrc\n\t\t\t\t},\n\t\t\t\tcallbacks: callbacks,\n\t\t\t\tajax: ajax\n\t\t\t} );\n\n\t\t\twb.ready( undef, componentName );\n\t\t} );\n\n\t\t// Load dependencies as needed\n\t\tsetup();\n\t}\n} );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, document, wb );\n\n/**\n * @title WET-BOEW Menu plugin\n * @overview A Menu plugin for WET\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author WET community\n */\n( function( $, window, document, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-menu",\n\tselector = "." + componentName,\n\tinitEvent = "wb-init" + selector,\n\tbreadcrumb = document.getElementById( "wb-bc" ),\n\tnavCurrentEvent = "navcurr.wb",\n\tfocusEvent = "setfocus.wb",\n\tdetailsInitEvent = "wb-init.wb-details",\n\tmenuItemSelector = "> a, > details > summary",\n\t$document = wb.doc,\n\n\t// Used for half second delay on showing/hiding menus because of mouse hover\n\thoverDelay = 500,\n\tmenuCount = 0,\n\tglobalTimeout,\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\t$elm, ajaxFetch;\n\n\t\tif ( elm ) {\n\t\t\t$elm = $( elm );\n\n\t\t\t// Ensure the container has an id attribute\n\t\t\tif ( !$elm.attr( "id" ) ) {\n\t\t\t\t$elm.attr( "id", componentName + "-" + menuCount );\n\t\t\t}\n\t\t\tmenuCount += 1;\n\n\t\t\t// Lets test to see if we have any menus to fetch\n\t\t\t// This is required for backwards compatibility. In previous versions, the menu was not integrated witht he data ajax plugin.\n\t\t\tajaxFetch = $elm.data( "ajax-fetch" );\n\t\t\tif ( ajaxFetch ) {\n\t\t\t\t$elm.trigger( {\n\t\t\t\t\ttype: "ajax-fetch.wb",\n\t\t\t\t\tfetch: {\n\t\t\t\t\t\turl: ajaxFetch\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} else {\n\n\t\t\t\t//Enhance menus that don\'t rely on the data-ajax plugin\n\t\t\t\tajaxFetch = $elm.data( "ajax-replace" ) || $elm.data( "ajax-append" ) || $elm.data( "ajax-prepend" );\n\t\t\t\tif ( !ajaxFetch ) {\n\t\t\t\t\tonAjaxLoaded( $elm, $elm );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Lets set some aria states and attributes\n\t * @method drizzleAria\n\t * @param {jQuery DOM elements} $elements The collection of elements\n\t */\n\tdrizzleAria = function( $elements ) {\n\t\tvar length = $elements.length,\n\t\t\t$elm, $subMenu, i;\n\n\t\t// Lets tweak for aria\n\t\tfor ( i = 0; i !== length; i += 1 ) {\n\t\t\t$elm = $elements.eq( i );\n\t\t\t$subMenu = $elm.siblings( "ul" );\n\n\t\t\t$elm.attr( {\n\t\t\t\t"aria-posinset": ( i + 1 ),\n\t\t\t\t"aria-setsize": length,\n\t\t\t\trole: "menuitem"\n\t\t\t} );\n\n\t\t\t// if there is a submenu lets put in the aria for it\n\t\t\tif ( $subMenu.length !== 0 ) {\n\n\t\t\t\t$elm.attr( "aria-haspopup", "true" );\n\n\t\t\t\t$subMenu.attr( {\n\t\t\t\t\t"aria-expanded": "false",\n\t\t\t\t\t"aria-hidden": "true"\n\t\t\t\t} );\n\n\t\t\t\t// recurse into submenu\n\t\t\t\tdrizzleAria( $subMenu.children( "li" ).find( menuItemSelector ) );\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * @method createCollapsibleSection\n\t * @return {string}\n\t */\n\tcreateCollapsibleSection = function( section, sectionIndex, sectionsLength, $items, itemsLength ) {\n\n\t\t// Use details/summary for the collapsible mechanism\n\t\tvar k, $elm, elm, $item, $subItems, subItemsLength,\n\t\t\t$section = $( section ),\n\t\t\tposinset = "\' aria-posinset=\'",\n\t\t\tmenuitem = " role=\'menuitem\' aria-setsize=\'",\n\t\t\tsectionHtml = "<li><details>" + "<summary class=\'mb-item" +\n\t\t\t\t( $section.hasClass( "wb-navcurr" ) || $section.children( ".wb-navcurr" ).length !== 0 ? " wb-navcurr\'" : "\'" ) +\n\t\t\t\tmenuitem + sectionsLength + posinset + ( sectionIndex + 1 ) +\n\t\t\t\t"\' aria-haspopup=\'true\'>" + $section.text() + "</summary>" +\n\t\t\t\t"<ul class=\'list-unstyled mb-sm\' role=\'menu\' aria-expanded=\'false\' aria-hidden=\'true\'>";\n\n\t\t// Convert each of the list items into WAI-ARIA menuitems\n\t\tfor ( k = 0; k !== itemsLength; k += 1 ) {\n\t\t\t$item = $items.eq( k );\n\t\t\t$elm = $item.find( menuItemSelector );\n\t\t\telm = $elm[ 0 ];\n\t\t\t$subItems = $elm.parent().find( "> ul > li" );\n\t\t\tsubItemsLength = $subItems.length;\n\n\t\t\tif ( elm && subItemsLength === 0 && elm.nodeName.toLowerCase() === "a" ) {\n\t\t\t\tsectionHtml += "<li>" + $item[ 0 ].innerHTML.replace(\n\t\t\t\t\t\t/(<a\\s)/,\n\t\t\t\t\t\t"$1" + menuitem + itemsLength +\n\t\t\t\t\t\t\tposinset + ( k + 1 ) +\n\t\t\t\t\t\t\t"\' tabindex=\'-1\' "\n\t\t\t\t\t) + "</li>";\n\t\t\t} else {\n\t\t\t\tsectionHtml += createCollapsibleSection( elm, k, itemsLength, $subItems, $subItems.length );\n\t\t\t}\n\t\t}\n\n\t\treturn sectionHtml + "</ul></details></li>";\n\t},\n\n\t/**\n\t * @method createMobilePanelMenu\n\t * @param {array} allProperties Properties used to build the menu system\n\t * @return {string}\n\t */\n\tcreateMobilePanelMenu = function( allProperties ) {\n\t\tvar panel = "",\n\t\t\tsectionHtml, properties, sections, section, parent, $items,\n\t\t\tlinkHtml, i, j, len, sectionsLength, itemsLength;\n\n\t\t// Process the secondary and site menus\n\t\tlen = allProperties.length;\n\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\tproperties = allProperties[ i ];\n\t\t\tsectionHtml = "";\n\t\t\tsections = properties[ 0 ];\n\t\t\tsectionsLength = sections.length;\n\t\t\tfor ( j = 0; j !== sectionsLength; j += 1 ) {\n\t\t\t\tsection = sections[ j ];\n\t\t\t\t$items = $( section.parentNode ).find( "> ul > li" );\n\t\t\t\titemsLength = $items.length;\n\n\t\t\t\t// Collapsible section\n\t\t\t\tif ( itemsLength !== 0 ) {\n\t\t\t\t\tsectionHtml += createCollapsibleSection( section, j, sectionsLength, $items, itemsLength );\n\t\t\t\t} else {\n\t\t\t\t\tparent = section.parentNode;\n\n\t\t\t\t\t// Menu item without a section\n\t\t\t\t\tif ( parent.nodeName.toLowerCase() === "li" ) {\n\t\t\t\t\t\tlinkHtml = parent.innerHTML;\n\n\t\t\t\t\t// Non-list menu items without a section and that contain their own link\n\t\t\t\t\t} else if ( parent.getElementsByTagName( "a" )[ 0 ] === section.getElementsByTagName( "a" )[ 0 ] ) {\n\t\t\t\t\t\tlinkHtml = section.innerHTML;\n\n\t\t\t\t\t// Non-list menu item without a section and whose siblings contain a link\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlinkHtml = "<a href=\'" +\n\t\t\t\t\t\t\tparent.getElementsByTagName( "a" )[ 0 ].href + "\'>" +\n\t\t\t\t\t\t\tsection.innerHTML + "</a>";\n\t\t\t\t\t}\n\n\t\t\t\t\t// Convert the list item to a WAI-ARIA menuitem\n\t\t\t\t\tsectionHtml += "<li class=\'no-sect\'>" +\n\t\t\t\t\t\tlinkHtml.replace(\n\t\t\t\t\t\t\t/(<a\\s)/,\n\t\t\t\t\t\t\t"$1 class=\'mb-item\' " + "role=\'menuitem\' aria-setsize=\'" +\n\t\t\t\t\t\t\t\tsectionsLength + "\' aria-posinset=\'" + ( j + 1 ) +\n\t\t\t\t\t\t\t\t"\' tabindex=\'-1\' "\n\t\t\t\t\t\t) + "</li>";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Create the panel section\n\t\t\tpanel += "<nav role=\'navigation\' typeof=\'SiteNavigationElement\' id=\'" +\n\t\t\t\tproperties[ 1 ] + "\' class=\'" + properties[ 1 ] + " wb-menu wb-menu-inited\'>" +\n\t\t\t\t"<h3>" + properties[ 2 ] + "</h3>" +\n\t\t\t\t"<ul class=\'list-unstyled mb-menu\' role=\'menu\'>" +\n\t\t\t\tsectionHtml + "</ul></nav>";\n\t\t}\n\n\t\treturn panel.replace( /[\'"]?list-group-item[\'"]?/gi, "\\"\\"" );\n\t},\n\n\t/**\n\t * @method onAjaxLoaded\n\t * @param {jQuery DOM element} $elm The plugin element\n\t * @param {jQuery DOM element} $ajaxResult The AJAXed in menu content to import\n\t */\n\tonAjaxLoaded = function( $elm, $ajaxResult ) {\n\t\tvar $info = $( "#wb-info" ),\n\t\t\tinner = function() {\n\t\t\t\tvar $ajaxed = $ajaxResult && $ajaxResult.attr( "data-type" ) === "string" ? $ajaxResult : $elm,\n\t\t\t\t\t$menubar = $ajaxed.find( ".menu" ),\n\t\t\t\t\t$menu = $menubar.find( "> li > a" ),\n\t\t\t\t\ttarget = $elm.data( "trgt" ),\n\t\t\t\t\t$secnav = $( "#wb-sec" ),\n\t\t\t\t\t$language = $( "#wb-lng" ),\n\t\t\t\t\tsearch = document.getElementById( "wb-srch" ),\n\t\t\t\t\tpanel = "",\n\t\t\t\t\tpanelDOM = document.getElementById( target ),\n\t\t\t\t\t$panel = $( panelDOM ),\n\t\t\t\t\tallProperties = [],\n\t\t\t\t\t$navCurr, $menuItem, $langItems, len, i;\n\n\t\t\t\t/*\n\t\t\t\t * Build the mobile panel\n\t\t\t\t */\n\n\t\t\t\t// Add search\n\t\t\t\tif ( search !== null ) {\n\t\t\t\t\tpanel += "<section class=\'srch-pnl\'>" +\n\t\t\t\t\t\tsearch.innerHTML\n\t\t\t\t\t\t\t.replace( /h2>/i, "h3>" )\n\t\t\t\t\t\t\t.replace( /(for|id)="([^"]+)"/gi, "$1=\'$2-imprt\'" ) +\n\t\t\t\t\t\t"</section>";\n\t\t\t\t}\n\n\t\t\t\t// Add active language offer\n\t\t\t\tif ( $language.length !== 0 ) {\n\t\t\t\t\t$langItems = $language.find( "li:not(.curr)" );\n\t\t\t\t\tlen = $langItems.length;\n\t\t\t\t\tpanel += "<section class=\'lng-ofr\'>" +\n\t\t\t\t\t\t"<h3>" + $language.children( "h2" ).html() + "</h3>" +\n\t\t\t\t\t\t"<ul class=\'list-inline\'>";\n\t\t\t\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\t\t\t\tpanel += $langItems[ i ].innerHTML\n\t\t\t\t\t\t\t.replace( /(<a\\s.*<\\/a>?)/, "<li>$1</li>" );\n\t\t\t\t\t}\n\t\t\t\t\tpanel += "</ul></section>";\n\t\t\t\t}\n\n\t\t\t\t// Create menu system\n\t\t\t\tif ( $secnav.length !== 0 || $menubar.length !== 0 || $info.length !== 0 ) {\n\n\t\t\t\t\t// Add the secondary menu\n\t\t\t\t\tif ( $secnav.length !== 0 ) {\n\t\t\t\t\t\tallProperties.push( [\n\t\t\t\t\t\t\t$secnav.find( "ul" ).filter( ":not(li > ul)" ).find( " > li > *:first-child" ).get(),\n\t\t\t\t\t\t\t"sec-pnl",\n\t\t\t\t\t\t\t$secnav.find( "h2" ).html()\n\t\t\t\t\t\t] );\n\n\t\t\t\t\t\tif ( $secnav.find( ".wb-navcurr" ).length === 0 ) {\n\n\t\t\t\t\t\t\t// Trigger the navcurrent plugin\n\t\t\t\t\t\t\t$secnav.trigger( navCurrentEvent, breadcrumb );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add the site menu\n\t\t\t\t\tif ( $menubar.length !== 0 ) {\n\n\t\t\t\t\t\t// Add the menubar role if it is missing\n\t\t\t\t\t\tif ( !$menubar.attr( "role" ) ) {\n\t\t\t\t\t\t\t$menubar.attr( "role", "menubar" );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tallProperties.push( [\n\t\t\t\t\t\t\t$menu.get(),\n\t\t\t\t\t\t\t"sm-pnl",\n\t\t\t\t\t\t\t$ajaxed.find( "h2" ).html()\n\t\t\t\t\t\t] );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add the site information\n\t\t\t\t\tif ( $info.length !== 0 ) {\n\t\t\t\t\t\tallProperties.push( [\n\t\t\t\t\t\t\t$info.find( "h3, a" ).not( "section a" ),\n\t\t\t\t\t\t\t"info-pnl",\n\t\t\t\t\t\t\t$info.find( "h2" ).html()\n\t\t\t\t\t\t] );\n\n\t\t\t\t\t\tif ( $info.find( ".wb-navcurr" ).length === 0 ) {\n\n\t\t\t\t\t\t\t// Trigger the navcurrent plugin\n\t\t\t\t\t\t\t$info.trigger( navCurrentEvent, breadcrumb );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tpanel += createMobilePanelMenu( allProperties );\n\t\t\t\t}\n\n\t\t\t\t// Let\'s now populate the DOM since we have done all the work in a documentFragment\n\t\t\t\tpanelDOM.innerHTML = "<header class=\'modal-header\'><div class=\'modal-title\'>" +\n\t\t\t\t\t\tdocument.getElementById( "wb-glb-mn" )\n\t\t\t\t\t\t\t.getElementsByTagName( "h2" )[ 0 ]\n\t\t\t\t\t\t\t\t.innerHTML +\n\t\t\t\t\t\t"</div></header><div class=\'modal-body\'>" + panel + "</div>";\n\t\t\t\tpanelDOM.className += " wb-overlay modal-content overlay-def wb-panel-r";\n\n\t\t\t\t// fix #8241\n\t\t\t\tif ( $.active > 0 ) {\n\t\t\t\t\t$( document ).ajaxStop( function() {\n\t\t\t\t\t\tinitOverlay( $panel );\n\t\t\t\t\t} );\n\t\t\t\t} else {\n\t\t\t\t\tinitOverlay( $panel );\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Build the regular mega menu\n\t\t\t\t */\n\t\t\t\t$ajaxed\n\t\t\t\t\t.find( ":discoverable" )\n\t\t\t\t\t\t.attr( "tabindex", "-1" );\n\n\t\t\t\tif ( $menu.length !== 0 ) {\n\t\t\t\t\t$menu[ 0 ].setAttribute( "tabindex", "0" );\n\t\t\t\t\tdrizzleAria( $menu );\n\t\t\t\t\t$menu\n\t\t\t\t\t\t.filter( "[aria-haspopup=true]" )\n\t\t\t\t\t\t\t.append( "<span class=\'expicon glyphicon glyphicon-chevron-down\'></span>" );\n\t\t\t\t}\n\n\t\t\t\t// Replace elements\n\t\t\t\t$elm.html( $ajaxed.html() );\n\n\t\t\t\t// Trigger the navcurrent plugin\n\t\t\t\tsetTimeout( function() {\n\t\t\t\t\t$elm.trigger( navCurrentEvent, breadcrumb );\n\t\t\t\t\t$panel.find( "#sm-pnl" ).trigger( navCurrentEvent, breadcrumb );\n\n\t\t\t\t\t// Ensure that wb-navcurr is reflected in the top level\n\t\t\t\t\t$navCurr = $panel.find( ".wb-navcurr" );\n\t\t\t\t\tlen = $navCurr.length;\n\t\t\t\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\t\t\t\t$menuItem = $navCurr.eq( i );\n\n\t\t\t\t\t\t// If not at the top level, then add wb-navcurr to the top level\n\t\t\t\t\t\tif ( !$menuItem.hasClass( ".mb-item" ) ) {\n\t\t\t\t\t\t\t$menuItem = $menuItem\n\t\t\t\t\t\t\t\t\t\t\t.closest( "details" )\n\t\t\t\t\t\t\t\t\t\t\t\t.children( "summary" )\n\t\t\t\t\t\t\t\t\t\t\t\t\t.addClass( "wb-navcurr" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Open up the secondary menu if it has wb-navcurr and has a submenu\n\t\t\t\t\t$menuItem = $panel.find( "#sec-pnl .wb-navcurr.mb-item" );\n\t\t\t\t\tif ( $menuItem.attr( "aria-haspopup" ) === "true" ) {\n\t\t\t\t\t\t$menuItem\n\t\t\t\t\t\t\t.trigger( "click" )\n\t\t\t\t\t\t\t.parent()\n\t\t\t\t\t\t\t\t.prop( "open", "open" );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Identify that initialization has completed\n\t\t\t\t\twb.ready( $elm, componentName );\n\t\t\t\t}, 1 );\n\t\t\t},\n\t\t\t$footerAjax  = $info.find( "[data-ajax-replace],[data-ajax-append],[data-ajax-prepend]" ),\n\t\t\tfooterAjaxLength = $footerAjax.length,\n\t\t\tajaxCount = 0;\n\n\t\t//Delay the execution the menu until any ajaxed footer content is in\n\t\tif ( footerAjaxLength === 0 ) {\n\t\t\tinner();\n\t\t} else {\n\t\t\t$info.on( "wb-contentupdated ajax-failed.wb", function() {\n\t\t\t\tajaxCount += 1;\n\t\t\t\tif ( ajaxCount === footerAjaxLength ) {\n\t\t\t\t\tinner();\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t},\n\n\t// fix #8517\n\t/**\n\t * @method initOverlay\n\t * @param {jQuery object} $panel Current panel\n\t */\n\tinitOverlay = function( $panel ) {\n\t\t$panel\n\t\t\t.trigger( "wb-init.wb-overlay" )\n\t\t\t.find( "summary" )\n\t\t\t.attr( "tabindex", "-1" )\n\t\t\t.trigger( detailsInitEvent );\n\t\t$panel\n\t\t\t.find( ".mb-menu > li:first-child" )\n\t\t\t.find( ".mb-item" )\n\t\t\t.attr( "tabindex", "0" );\n\t},\n\n\t/**\n\t * @method menuIncrement\n\t * @param {jQuery object} $menuItems Collection of of menu items to move between\n\t * @param {jQuery object} $current Current menu item\n\t * @param {integer} indexChange Requested relative change to the menu item index\n\t */\n\tmenuIncrement = function( $menuItems, $current, indexChange ) {\n\t\tvar menuItemsLength = $menuItems.length,\n\t\t\tindex = $menuItems.index( $current ) + indexChange;\n\n\t\t// Correct out-of-range indexes\n\t\tindex = index === menuItemsLength ? 0 : index === -1 ? menuItemsLength - 1 : index;\n\n\t\t// Move to the new menu item\n\t\t$menuItems.eq( index ).trigger( focusEvent );\n\t},\n\n\t/**\n\t * @method menuClose\n\t * @param {jQuery DOM element} $elm Parent of the element to close\n\t * @param {boolean} removeActive Whether or not to keep the active class\n\t */\n\tmenuClose = function( $elm, removeActive ) {\n\t\t$elm\n\t\t\t.removeClass( "sm-open" )\n\t\t\t.children( ".open" )\n\t\t\t\t.removeClass( "open" )\n\t\t\t\t.attr( {\n\t\t\t\t\t"aria-hidden": "true",\n\t\t\t\t\t"aria-expanded": "false"\n\t\t\t\t} )\n\n\t\t\t\t// Close nested submenus\n\t\t\t\t.find( "details" )\n\t\t\t\t\t.removeAttr( "open" )\n\t\t\t\t\t.children( "ul" )\n\t\t\t\t\t\t.attr( {\n\t\t\t\t\t\t\t"aria-hidden": "true",\n\t\t\t\t\t\t\t"aria-expanded": "false"\n\t\t\t\t\t\t} );\n\n\t\tif ( removeActive ) {\n\t\t\t$elm.removeClass( "active" );\n\t\t}\n\t},\n\n\t/**\n\t * @method menuDisplay\n\t * @param {jQuery DOM element} $elm The plugin element\n\t * @param {jQuery event} menu The menu to display\n\t */\n\tmenuDisplay = function( $elm, menu ) {\n\t\tvar menuLink = menu.children( "a" );\n\n\t\tmenuClose( $elm.find( ".active" ), true );\n\n\t\tmenu.addClass( "active" );\n\n\t\t// Ignore if doesn\'t have a submenu\n\t\tif ( menuLink.attr( "aria-haspopup" ) === "true" ) {\n\n\t\t\t// Add the open state classes\n\t\t\tmenu\n\t\t\t\t.addClass( "sm-open" )\n\t\t\t\t.children( ".sm" )\n\t\t\t\t\t.addClass( "open" )\n\t\t\t\t\t.attr( {\n\t\t\t\t\t\t"aria-hidden": "false",\n\t\t\t\t\t\t"aria-expanded": "true"\n\t\t\t\t\t} );\n\t\t}\n\t},\n\n\t/**\n\t * Searches for the next link that has link text starting with a specific letter\n\t * @method selectByLetter\n\t * @param {integer} charCode The charCode of the letter to search for\n\t * @param {DOM elements} links Collection of links to search\n\t */\n\tselectByLetter = function( charCode, links ) {\n\t\tvar len = links.length,\n\t\t\tkeyChar = String.fromCharCode( charCode ),\n\t\t\tlink, i;\n\n\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\tlink = links[ i ];\n\t\t\tif ( link.innerHTML.charAt( 0 ) === keyChar ) {\n\t\t\t\t$( link ).trigger( focusEvent );\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t};\n\n// Bind the events of the plugin\n$document.on( "timerpoke.wb " + initEvent + " ajax-fetched.wb ajax-failed.wb", selector, function( event ) {\n\n\tvar eventType = event.type,\n\t\telm, $elm;\n\n\tswitch ( eventType ) {\n\tcase "ajax-fetched":\n\tcase "ajax-failed":\n\t\telm = event.target;\n\n\t\t// Filter out any events triggered by descendants\n\t\tif ( event.currentTarget === elm ) {\n\t\t\t$elm = $( elm );\n\n\t\t\t// Only replace the menu if there isn\'t an error\n\t\t\tonAjaxLoaded(\n\t\t\t\t$elm,\n\t\t\t\teventType === "ajax-fetched" ? event.fetch.pointer : $elm\n\t\t\t);\n\t\t}\n\t\treturn false;\n\n\tcase "timerpoke":\n\tcase "wb-init":\n\t\tinit( event );\n\t\tbreak;\n\t}\n\n\t/*\n\t * Since we are working with events we want to ensure that we are being passive about our control,\n\t * so returning true allows for events to always continue\n\t */\n\treturn true;\n} );\n\n$document.on( "mouseleave", selector + " .menu", function( event ) {\n\tvar $currentTarget = $( event.currentTarget );\n\n\t// Clear the timeout for open/closing menus\n\tclearTimeout( globalTimeout );\n\n\tglobalTimeout = setTimeout( function() {\n\t\tmenuClose( $currentTarget.find( ".active" ), true );\n\t}, hoverDelay );\n} );\n\n// Prevent opening another menu if mouse re-enters already opened menu\n$document.on( "mouseenter", selector + " .sm", function() {\n\tif ( $( this ).attr( "aria-expanded" ) === "true" ) {\n\t\tclearTimeout( globalTimeout );\n\t}\n} );\n\n// Touchscreen "touches" on menubar items should close the submenu if it is open\n$document.on( "touchstart click", selector + " .item[aria-haspopup=true]", function( event ) {\n\tvar isTouchstart = event.type === "touchstart",\n\t\twhich = event.which,\n\t\t$this, $parent;\n\n\t// Ignore middle and right mouse buttons\n\tif ( isTouchstart || ( !which || which === 1 ) ) {\n\t\tevent.preventDefault();\n\t\t$this = $( this );\n\t\t$parent = $this.parent();\n\n\t\t// Open the submenu if it is closed\n\t\tif ( !$parent.hasClass( "sm-open" ) ) {\n\t\t\t$this.trigger( "focusin" );\n\n\t\t// Close the open submenu for a touch event\n\t\t} else if ( isTouchstart ) {\n\t\t\tmenuClose( $parent, true );\n\t\t}\n\t}\n} );\n\n// Click on menu items with submenus should open and close those submenus\n$document.on( "click", selector + " [role=menu] [aria-haspopup=true]", function( event ) {\n\tvar menuItem = event.currentTarget,\n\t\tparent = menuItem.parentNode,\n\t\tsubmenu = parent.getElementsByTagName( "ul" )[ 0 ],\n\t\tisOpen = submenu.getAttribute( "aria-hidden" ) === "false",\n\t\tmenuItemOffsetTop, menuContainer;\n\n\t// Close any other open menus\n\tif ( !isOpen ) {\n\t\t$( parent )\n\t\t\t.closest( "[role^=\'menu\']" )\n\t\t\t\t.find( "[aria-hidden=false]" )\n\t\t\t\t\t.parent()\n\t\t\t\t\t\t.find( "[aria-haspopup=true]" )\n\t\t\t\t\t\t\t.not( menuItem )\n\t\t\t\t\t\t\t\t.trigger( "click" );\n\n\t\t// Ensure the opened menu is in view if in a mobile panel\n\t\tmenuContainer = document.getElementById( "mb-pnl" );\n\t\tmenuItemOffsetTop = menuItem.offsetTop;\n\t\tif ( $.contains( menuContainer, menuItem ) &&\n\t\t\tmenuItemOffsetTop < menuContainer.scrollTop ) {\n\n\t\t\tmenuContainer.scrollTop = menuItemOffsetTop;\n\t\t}\n\t}\n\n\tsubmenu.setAttribute( "aria-expanded", !isOpen );\n\tsubmenu.setAttribute( "aria-hidden", isOpen );\n} );\n\n// Clicks and touches outside of menus should close any open menus\n$document.on( "click touchstart", function( event ) {\n\tvar $openMenus,\n\t\twhich = event.which;\n\n\t// Ignore middle and right mouse buttons\n\tif ( event.type === "touchstart" || ( !which || which === 1 ) ) {\n\t\t$openMenus = $( selector + " .sm-open" );\n\t\tif ( $openMenus.length !== 0 &&\n\t\t\t$( event.target ).closest( selector ).length === 0 ) {\n\n\t\t\tmenuClose( $openMenus, true );\n\t\t}\n\t}\n} );\n\n$document.on( "mouseover focusin", selector + " .item", function( event ) {\n\tvar $elm = $( event.currentTarget ),\n\t\t$parent = $elm.parent(),\n\t\t$container = $parent.closest( selector );\n\n\t// Clear the timeout for open/closing menus\n\tclearTimeout( globalTimeout );\n\n\tif ( event.type === "focusin" ) {\n\t\tmenuDisplay( $container, $parent );\n\t} else {\n\t\tglobalTimeout = setTimeout( function() {\n\t\t\tmenuDisplay( $container, $parent );\n\t\t}, hoverDelay );\n\t}\n} );\n\n/*\n * Keyboard bindings\n */\n$document.on( "keydown", selector + " [role=menuitem]", function( event ) {\n\tvar menuItem = event.currentTarget,\n\t\twhich = event.which,\n\t\t$menuItem = $( menuItem ),\n\t\thasPopup = $menuItem.attr( "aria-haspopup" ) === "true",\n\t\t$menu = $menuItem.parent().closest( "[role^=\'menu\']" ),\n\t\tinMenuBar = $menu.attr( "role" ) === "menubar",\n\t\t$menuLink, $parentMenu, $parent, $subMenu, result,\n\t\tmenuitemSelector, isOpen, menuItemOffsetTop, menuContainer;\n\n\t// Define keycodes. (Make const when WET supports ES6)\n\tvar TAB_KC = 9,\n\t\tENTER_KC = 13,\n\t\tESC_KC = 27,\n\t\tLEFT_KC = 37,\n\t\tUP_KC = 38,\n\t\tRIGHT_KC = 39,\n\t\tDOWN_KC = 40,\n\t\tSPACE_KC = 32;\n\n\tif ( !( event.ctrlKey || event.altKey || event.metaKey ) ) {\n\n\t\t// Tab key = Hide all sub-menus\n\t\tif ( which === TAB_KC ) {\n\t\t\tmenuClose( $( selector + " .active" ), true );\n\n\t\t//Enter or spacebar on a link = follow the link and close menus\n\t\t} else if ( menuItem.nodeName === "A" && menuItem.hasAttribute( "href" ) &&\n\t\t\t( which === ENTER_KC || which === SPACE_KC ) ) {\n\n\t\t\tevent.preventDefault();\n\t\t\tmenuItem.click();\n\t\t\tmenuClose( $( selector + " .active" ), true );\n\n\t\t// Menu item is within a menu bar\n\t\t} else if ( inMenuBar ) {\n\n\t\t\t// Left / right arrow = Previous / next menu item\n\t\t\tif ( which === LEFT_KC || which === RIGHT_KC ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tmenuIncrement(\n\t\t\t\t\t$menu.find( "> li > a" ),\n\t\t\t\t\t$menuItem,\n\t\t\t\t\twhich === LEFT_KC ? -1 : 1\n\t\t\t\t);\n\n\t\t\t// Enter sub-menu\n\t\t\t} else if ( hasPopup && ( which === ENTER_KC || which === SPACE_KC || which === UP_KC || which === DOWN_KC ) ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\t$parent = $menuItem.parent();\n\t\t\t\t$subMenu = $parent.find( ".sm" );\n\n\t\t\t\t// Open the submenu if it is not already open\n\t\t\t\tif ( !$subMenu.hasClass( "open" ) ) {\n\t\t\t\t\tmenuDisplay( $menu.closest( selector ), $parent );\n\t\t\t\t}\n\n\t\t\t\t// Set focus on the first submenu item\n\t\t\t\t$subMenu.children( "li" ).eq( 0 ).find( menuItemSelector ).trigger( focusEvent );\n\n\t\t\t// Hide sub-menus and set focus\n\t\t\t} else if ( which === ESC_KC ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tmenuClose( $menu.closest( selector ).find( ".active" ), false );\n\n\t\t\t// Letters only\n\t\t\t} else if ( which > 64 && which < 91 ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tselectByLetter(\n\t\t\t\t\twhich,\n\t\t\t\t\t$menuItem.parent().find( "> ul > li > a, > ul > li > details > summary" ).get()\n\t\t\t\t);\n\t\t\t}\n\n\t\t// Menu item is not within a menu bar\n\t\t} else {\n\t\t\tmenuitemSelector = menuItemSelector;\n\n\t\t\t// Up / down arrow = Previous / next menu item\n\t\t\tif ( which === UP_KC || which === DOWN_KC ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tmenuIncrement(\n\t\t\t\t\t$menu.children( "li" ).find( menuitemSelector ),\n\t\t\t\t\t$menuItem,\n\t\t\t\t\twhich === UP_KC ? -1 : 1\n\t\t\t\t);\n\n\t\t\t// Enter, space, or right arrow with a submenu\n\t\t\t} else if ( hasPopup && ( which === ENTER_KC || which === SPACE_KC || which === RIGHT_KC ) ) {\n\t\t\t\t$parent = $menuItem.parent();\n\n\t\t\t\t// Prevent handling by details.js polyfill\n\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\tevent.preventDefault();\n\n\t\t\t\t// If the menu item is a summary element\n\t\t\t\tif ( menuItem.nodeName.toLowerCase( "summary" ) ) {\n\t\t\t\t\tisOpen = !!$parent.attr( "open" );\n\n\t\t\t\t\t// Close any other open menus\n\t\t\t\t\tif ( !isOpen ) {\n\t\t\t\t\t\t$( parent )\n\t\t\t\t\t\t\t.closest( "[role^=\'menu\']" )\n\t\t\t\t\t\t\t\t.find( "[aria-hidden=false]" )\n\t\t\t\t\t\t\t\t\t.parent()\n\t\t\t\t\t\t\t\t\t\t.find( "[aria-haspopup=true]" )\n\t\t\t\t\t\t\t\t\t\t\t.not( menuItem )\n\t\t\t\t\t\t\t\t\t\t\t\t.trigger( "click" );\n\n\t\t\t\t\t\t// Ensure the opened menu is in view if in a mobile panel\n\t\t\t\t\t\tmenuContainer = document.getElementById( "mb-pnl" );\n\t\t\t\t\t\tmenuItemOffsetTop = menuItem.offsetTop;\n\t\t\t\t\t\tif ( $.contains( menuContainer, menuItem ) &&\n\t\t\t\t\t\t\tmenuItemOffsetTop < menuContainer.scrollTop ) {\n\n\t\t\t\t\t\t\tmenuContainer.scrollTop = menuItemOffsetTop;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Ensure the menu is opened or stays open\n\t\t\t\t\t\t$menuItem.trigger( "click" );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update the WAI-ARIA states and move focus to\n\t\t\t\t\t// the first submenu item\n\t\t\t\t\t$parent.children( "ul" )\n\t\t\t\t\t\t.attr( {\n\t\t\t\t\t\t\t"aria-expanded": "true",\n\t\t\t\t\t\t\t"aria-hidden": "false"\n\t\t\t\t\t\t} )\n\t\t\t\t\t\t.find( "[role=menuitem]:first" )\n\t\t\t\t\t\t\t.trigger( "setfocus.wb" );\n\t\t\t\t}\n\n\t\t\t// Escape, left / right arrow without a submenu\n\t\t\t} else if ( which === ESC_KC || which === LEFT_KC || which === RIGHT_KC ) {\n\t\t\t\t$parent = $menu.parent();\n\t\t\t\t$parentMenu = $parent.closest( "[role^=\'menu\']" );\n\t\t\t\tif ( which === LEFT_KC || which === RIGHT_KC ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\n\t\t\t\t// If the parent menu is a menubar\n\t\t\t\tif ( $parentMenu.attr( "role" ) === "menubar" ) {\n\t\t\t\t\t$menuLink = $menu.siblings( "a" );\n\n\t\t\t\t\t// Escape key = Close menu and return to menu bar item\n\t\t\t\t\tif ( which === ESC_KC ) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t$menuLink.trigger( focusEvent );\n\n\t\t\t\t\t\t// Close the menu but keep the referring link active\n\t\t\t\t\t\tsetTimeout( function() {\n\t\t\t\t\t\t\tmenuClose( $menuLink.parent(), false );\n\t\t\t\t\t\t}, 100 );\n\n\t\t\t\t\t// Left / right key = Next / previous menu bar item\n\t\t\t\t\t} else if ( $parentMenu.attr( "role" ) === "menubar" ) {\n\t\t\t\t\t\tmenuIncrement(\n\t\t\t\t\t\t\t$parentMenu.find( "> li > a" ),\n\t\t\t\t\t\t\t$menuLink,\n\t\t\t\t\t\t\twhich === LEFT_KC ? -1 : 1\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t// Escape or left arrow: Go up a level if there is a higher-level\n\t\t\t\t// menu or close the current submenu if there isn\'t\n\t\t\t\t} else if ( which !== RIGHT_KC ) {\n\t\t\t\t\t$subMenu = $parentMenu.length !== 0 ? $menu : $menuItem;\n\n\t\t\t\t\t// There is a higher-level menu\n\t\t\t\t\tif ( $parentMenu.length !== 0 ) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t$menu.closest( "li" )\n\t\t\t\t\t\t\t.find( menuitemSelector )\n\t\t\t\t\t\t\t\t.trigger( "click" )\n\t\t\t\t\t\t\t\t.trigger( "setfocus.wb" );\n\n\t\t\t\t\t// No higher-level menu but the current submenu is open\n\t\t\t\t\t} else if ( $menuItem.parent().children( "ul" ).attr( "aria-hidden" ) === "false" ) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t$menuItem\n\t\t\t\t\t\t\t.trigger( "click" )\n\t\t\t\t\t\t\t.trigger( "setfocus.wb" );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Select a menu item in the current menu by the first letter\n\t\t\t} else if ( which > 64 && which < 91 ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\t$parent = $menuItem.closest( "li" );\n\n\t\t\t\t// Try to find a match in the next siblings\n\t\t\t\tresult = selectByLetter(\n\t\t\t\t\twhich,\n\t\t\t\t\t$parent.nextAll().find( menuitemSelector ).get()\n\t\t\t\t);\n\n\t\t\t\t// If couldn\'t find a match, try the previous siblings\n\t\t\t\tif ( !result ) {\n\t\t\t\t\tresult = selectByLetter(\n\t\t\t\t\t\twhich,\n\t\t\t\t\t\t$parent.prevAll().find( menuitemSelector ).get()\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Prevent Firefox from double-triggering menu behaviour\n$document.on( "keyup", selector + " [role=menuitem]", function( event ) {\n\tevent.preventDefault();\n\treturn false;\n} );\n\n// Close the mobile panel if switching to medium, large or extra large view\n$document.on( "mediumview.wb largeview.wb xlargeview.wb", function() {\n\tvar mobilePanel = document.getElementById( "mb-pnl" );\n\tif ( mobilePanel && mobilePanel.getAttribute( "aria-hidden" ) === "false" ) {\n\t\t$( mobilePanel ).trigger( "close.wb-overlay" );\n\t}\n} );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, document, wb );\n\n/**\n * @title WET-BOEW Multimedia PLayer\n * @overview An accessible multimedia player for <audio> and <video> tags\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author WET Community\n */\n/* globals YT */\n( function( $, window, wb, undef ) {\n"use strict";\n\n/* Local scoped variables*/\nvar componentName = "wb-mltmd",\n\tselector = "." + componentName,\n\tinitEvent = "wb-init" + selector,\n\tctrls = selector + " .wb-mm-ctrls",\n\tdispCtrls = selector + " .display," + ctrls,\n\ttemplate,\n\ti18n, i18nText,\n\tyoutubeReadyEvent = "ready.youtube",\n\tcaptionsLoadedEvent = "ccloaded" + selector,\n\tcaptionsLoadFailedEvent = "ccloadfail" + selector,\n\tcaptionsVisibleChangeEvent = "ccvischange" + selector,\n\trenderUIEvent = "renderui" + selector,\n\tinitializedEvent = "inited" + selector,\n\tyoutubeEvent = "youtube" + selector,\n\tresizeEvent = "resize" + selector,\n\ttemplateLoadedEvent = "templateloaded" + selector,\n\tcuepointEvent = "cuepoint" + selector,\n\tcaptionClass = "cc_on",\n\tmultimediaEvents = [\n\t\t"durationchange",\n\t\t"playing",\n\t\t"pause",\n\t\t"ended",\n\t\t"volumechange",\n\t\t"timeupdate",\n\t\t"waiting",\n\t\t"canplay",\n\t\t"progress",\n\t\tcaptionsLoadedEvent,\n\t\tcaptionsLoadFailedEvent,\n\t\tcaptionsVisibleChangeEvent,\n\t\tcuepointEvent\n\t].join( " " ),\n\t$document = wb.doc,\n\t$window = wb.win,\n\n\t/**\n\t * @function init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar eventTarget = wb.init( event, componentName, selector );\n\n\t\tif ( eventTarget ) {\n\n\t\t\t// Only initialize the i18nText once\n\t\t\tif ( !i18nText ) {\n\t\t\t\ti18n = wb.i18n;\n\t\t\t\ti18nText = {\n\t\t\t\t\tplay: i18n( "mmp-play" ),\n\t\t\t\t\tpause: i18n( "pause" ),\n\t\t\t\t\tvolume: i18n( "volume" ),\n\t\t\t\t\tcc_on: i18n( "cc", "on" ),\n\t\t\t\t\tcc_off: i18n( "cc", "off" ),\n\t\t\t\t\tcc_error: i18n( "cc-err" ),\n\t\t\t\t\tmute_on: i18n( "mute", "on" ),\n\t\t\t\t\tmute_off: i18n( "mute", "off" ),\n\t\t\t\t\tduration: i18n( "dur" ),\n\t\t\t\t\tposition: i18n( "pos" )\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif ( template === undef ) {\n\t\t\t\ttemplate = "";\n\t\t\t\t$( eventTarget ).trigger( {\n\t\t\t\t\ttype: "ajax-fetch.wb",\n\t\t\t\t\tfetch: {\n\t\t\t\t\t\turl: wb.getPath( "/assets" ) + "/mediacontrols.html"\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} else if ( template !== "" ) {\n\t\t\t\t$( eventTarget ).trigger( templateLoadedEvent );\n\t\t\t}\n\t\t}\n\t},\n\n\t/* helper functions*/\n\n\t/**\n\t * @method formatTime\n\t * @description format a number of seconds to SMTPE Timecode format (HH:MM:SS.FF)\n\t * @param {Float} time The time to format\n\t * @returns {String} the formatted time\n\t */\n\tformatTime = function( time ) {\n\t\tvar index = 2,\n\t\t\ttimecode = "",\n\t\t\tsecondsIn, current, pad;\n\n\t\tpad = function( number, digits ) {\n\t\t\treturn new Array( Math.max( digits - String( number ).length + 1, 0 ) ).join( 0 ) + number;\n\t\t};\n\n\t\ttime = Math.floor( time );\n\n\t\t//Loop to extract hours, minutes and seconds\n\t\twhile ( index >= 0 ) {\n\n\t\t\t//Get the number of seconds for the current iteration (hour, minute or second)\n\t\t\tsecondsIn = Math.pow( 60, index );\n\t\t\tcurrent = Math.floor( time / secondsIn );\n\n\t\t\tif ( timecode !== "" ) {\n\t\t\t\ttimecode += ":";\n\t\t\t}\n\n\t\t\ttimecode += pad( current, 2 );\n\t\t\ttime -= secondsIn * current;\n\t\t\tindex -= 1;\n\t\t}\n\t\treturn timecode;\n\t},\n\n\t/**\n\t * @method parseTime\n\t * @description parse an SMTPE Timecode string (HH:MM:SS.FF) or duration (45s) and returns the number of seconds for the timecode\n\t * @param {String} time The timecode or duration string to parse\n\t * @returns {Float} the number of seconds in time\n\t */\n\tparseTime = function( time ) {\n\t\tvar i, parts, timeStringPortion, partLength, seconds;\n\n\t\tif ( time !== undef ) {\n\t\t\tif ( time.charAt( time.length - 1 ) === "s" ) {\n\n\t\t\t\t//Duration parsing\n\t\t\t\treturn parseFloat( time.substring( 0, time.length - 1 ) );\n\t\t\t} else {\n\n\t\t\t\t//SMTPE Timecode Parsing\n\t\t\t\tparts = time.split( ":" ).reverse();\n\t\t\t\tseconds = 0;\n\n\t\t\t\tfor ( i = 0, partLength = parts.length; i < partLength; i += 1 ) {\n\t\t\t\t\ttimeStringPortion = i === 0 ?\n\t\t\t\t\t\tparseFloat( parts[ i ] ) :\n\t\t\t\t\t\tparseInt( parts[ i ], 10 );\n\t\t\t\t\tseconds += timeStringPortion * Math.pow( 60, i );\n\t\t\t\t}\n\t\t\t\treturn seconds;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\t/*\n\t * Peformant micro templater\n\t * @credit: https://github.com/premasagar/tim/blob/master/tinytim.js\n\t * @todo: caching\n\t */\n\ttmpl = ( function() {\n\t\tvar start = "{{",\n\t\t\tend = "}}",\n\n\t\t\t// e.g. config.person.name\n\t\t\tpath = "[a-z0-9_$][\\\\.a-z0-9_]*",\n\t\t\tpattern = new RegExp( start + "\\\\s*(" + path + ")\\\\s*" + end, "gi" );\n\t\treturn function( template, data ) {\n\n\t\t\t// Merge data into the template string\n\t\t\treturn template.replace( pattern, function( tag, token ) {\n\t\t\t\tvar path = token.split( "." ),\n\t\t\t\t\tlen = path.length,\n\t\t\t\t\tlookup = data,\n\t\t\t\t\ti = 0;\n\t\t\t\tfor ( ; i < len; i += 1 ) {\n\t\t\t\t\tlookup = lookup[ path[ i ] ];\n\n\t\t\t\t\t// Property not found\n\t\t\t\t\tif ( lookup === undef ) {\n\t\t\t\t\t\tthrow "tim: \'" + path[ i ] + "\' not found in " + tag;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Return the required value\n\t\t\t\t\tif ( i === len - 1 ) {\n\t\t\t\t\t\treturn lookup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t};\n\t}() ),\n\n\t/**\n\t * @method parseHtml\n\t * @description parse an HTML fragment and extract embed captions\n\t * @param {String} content The HTML fragment containing the captions\n\t * @returns {Array} An array of captions objects (ex: {text: "Caption", begin: 0, end :10})\n\t */\n\tparseHtml = function( content ) {\n\t\tvar captions = [],\n\t\t\tcaptionSelector = ".wb-tmtxt",\n\t\t\tcaptionElements = content.find( captionSelector ),\n\t\t\tlen = captionElements.length,\n\t\t\ti, captionElement, json, begin, end;\n\n\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\tcaptionElement = $( captionElements[ i ] );\n\t\t\tbegin = -1;\n\t\t\tend = -1;\n\n\t\t\tif ( captionElement.attr( "data-begin" ) !== undef ) {\n\t\t\t\tbegin = parseTime( captionElement.attr( "data-begin" ) );\n\t\t\t\tend = captionElement.attr( "data-end" ) !== undef ?\n\t\t\t\t\tparseTime( captionElement.attr( "data-end" ) ) :\n\t\t\t\t\tparseTime( captionElement.attr( "data-dur" ) ) + begin;\n\t\t\t} else if ( captionElement.attr( "data" ) !== undef ) {\n\t\t\t\tjson = captionElement.attr( "data" )\n\t\t\t\t\t.replace( /(begin|dur|end)/g, "\\"$1\\"" )\n\t\t\t\t\t.replace( /\'/g, "\\"" );\n\t\t\t\tjson = $.parseJSON( json );\n\t\t\t\tbegin = parseTime( json.begin );\n\t\t\t\tend = json.end !== undef ?\n\t\t\t\t\tparseTime( json.end ) :\n\t\t\t\t\tparseTime( json.dur ) + begin;\n\t\t\t}\n\n\t\t\t//Removes nested captions if an\n\t\t\tcaptionElement = captionElement.clone();\n\t\t\tcaptionElement.find( captionSelector ).detach();\n\n\t\t\tcaptions[ captions.length ] = {\n\t\t\t\ttext: captionElement.html(),\n\t\t\t\tbegin: begin,\n\t\t\t\tend: end\n\t\t\t};\n\t\t}\n\t\treturn captions;\n\t},\n\n\t/**\n\t * @method parseXml\n\t * @description parse an TTML (Xml) document and extract captions\n\t * @param {String} content The TTML fragment containing the captions\n\t * @returns {Array} An array of captions objects (ex: {text: "Caption", begin: 0, end :10})\n\t */\n\tparseXml = function( content ) {\n\t\tvar captions = [],\n\t\t\tcaptionSelector = "[begin]",\n\t\t\tcaptionElements = content.find( captionSelector ),\n\t\t\tlen = captionElements.length,\n\t\t\ti, captionElement, begin, end;\n\n\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\tcaptionElement = $( captionElements[ i ] );\n\t\t\tbegin = parseTime( captionElement.attr( "begin" ) );\n\t\t\tend = captionElement.attr( "end" ) !== undef ?\n\t\t\t\tparseTime( captionElement.attr( "end" ) ) :\n\t\t\t\tparseTime( captionElement.attr( "dur" ) ) + begin;\n\n\t\t\tcaptionElement = captionElement.clone();\n\t\t\tcaptionElement.find( captionSelector ).detach();\n\n\t\t\tcaptions[ captions.length ] = {\n\t\t\t\ttext: captionElement.html(),\n\t\t\t\tbegin: begin,\n\t\t\t\tend: end\n\t\t\t};\n\t\t}\n\t\treturn captions;\n\t},\n\n\t/**\n\t * @method loadCaptionsExternal\n\t * @description Loads captions from an external source (HTML embed or TTML)\n\t * @param {Object} elm The jQuery object for the multimedia player loading the captions\n\t * @param {String} url The url for the captions resource to load\n\t * @fires ccloaded.wb-mltmd\n\t * @fires ccloadfail.wb-mltmd\n\t */\n\tloadCaptionsExternal = function( elm, url ) {\n\t\t$.ajax( {\n\t\t\turl: url,\n\t\t\tdataType: "html",\n\n\t\t\t//Filters out images and objects from the content to avoid loading them\n\t\t\tdataFilter: function( data ) {\n\t\t\t\treturn data.replace( /<img|object [^>]*>/g, "" );\n\t\t\t},\n\t\t\tsuccess: function( data ) {\n\t\t\t\telm.trigger( {\n\t\t\t\t\ttype: captionsLoadedEvent,\n\t\t\t\t\tcaptions: data.indexOf( "<html" ) !== -1 ?\n\t\t\t\t\t\tparseHtml( $( data ) ) :\n\t\t\t\t\t\tparseXml( $( data ) )\n\t\t\t\t} );\n\t\t\t},\n\t\t\terror: function( response, textStatus, errorThrown ) {\n\t\t\t\telm.trigger( {\n\t\t\t\t\ttype: captionsLoadFailedEvent,\n\t\t\t\t\terror: errorThrown\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\t/**\n\t * @method loadCaptionsInternal\n\t * @description Loads same page captions emebed in HTML\n\t * @param {Object} elm The jQuery object for the multimedia player loading the captions\n\t * @param {Object} obj The jQUery object containing the captions\n\t * @fires ccloaded.wb-mltmd\n\t */\n\tloadCaptionsInternal = function( elm, obj ) {\n\t\telm.trigger( {\n\t\t\ttype: captionsLoadedEvent,\n\t\t\tcaptions: parseHtml( obj )\n\t\t} );\n\t},\n\n\t/**\n\t * @method updateCaptions\n\t * @description Update the captions for a multimedia player (called from the timeupdate event of the HTML5 media API)\n\t * @param {Object} area The jQuery object for the element where captions are displayed\n\t * @param {Float} seconds The current time of the media (use to sync the captions)\n\t * @param {Object} captions The JavaScript object containing the captions\n\t */\n\tupdateCaptions = function( area, seconds, captions ) {\n\t\tvar caption, i,\n\t\t\tcaptionsLength = captions.length;\n\n\t\t// added &#160; (non-breaking space) to prevent caption space from collapsing\n\t\t// Used .html() instead of .append for performance purposes\n\t\t// http://jsperf.com/jquery-append-vs-html-list-performance/2\n\t\tarea.html( "&#160;" );\n\n\t\tfor ( i = 0; i < captionsLength; i += 1 ) {\n\t\t\tcaption = captions[ i ];\n\t\t\tif ( seconds >= caption.begin && seconds <= caption.end ) {\n\t\t\t\tarea.html( $( "<div>" + caption.text + "</div>" ) );\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * @method playerApi\n\t * @description Normalizes the calls to the HTML5 media API\n\t * @param {String} fn The function to call\n\t * @param {object} args The arguments to send to the function call\n\t */\n\tplayerApi = function( fn, args ) {\n\t\tvar $this, method;\n\n\t\tswitch ( fn ) {\n\t\tcase "play":\n\t\t\ttry {\n\t\t\t\tthis.object.play();\n\t\t\t} catch ( ex ) {\n\t\t\t\tthis.object.doPlay();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase "pause":\n\t\t\ttry {\n\t\t\t\tthis.object.pause();\n\t\t\t} catch ( ex ) {\n\t\t\t\tthis.object.doPause();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase "getCaptionsVisible":\n\t\t\treturn $( this ).hasClass( captionClass );\n\t\tcase "setCaptionsVisible":\n\t\t\t$this = $( this );\n\t\t\tif ( args ) {\n\t\t\t\t$this.addClass( captionClass );\n\t\t\t} else {\n\t\t\t\t$this.removeClass( captionClass );\n\t\t\t}\n\t\t\t$this.trigger( captionsVisibleChangeEvent );\n\t\t\tbreak;\n\t\tcase "getBuffering":\n\t\t\treturn this.object.buffering || false;\n\t\tcase "setBuffering":\n\t\t\tthis.object.buffering = args;\n\t\t\tbreak;\n\t\tcase "getPreviousTime":\n\t\t\treturn this.object.previousTime;\n\t\tcase "setPreviousTime":\n\t\t\tthis.object.previousTime = args;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmethod = fn.charAt( 3 ).toLowerCase() + fn.substr( 4 );\n\t\t\tswitch ( fn.substr( 0, 3 ) ) {\n\t\t\tcase "get":\n\t\t\t\treturn typeof this.object[ method ] !== "function" ?\n\t\t\t\t\tthis.object[ method ] :\n\t\t\t\t\tthis.object[ method ]();\n\t\t\tcase "set":\n\t\t\t\ttypeof this.object[ method ] !== "function" ?\n\t\t\t\t\tthis.object[ method ] = args :\n\t\t\t\t\tthis.object[ fn ]( args );\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * @method youTubeApi\n\t * @description Normalizes the calls to the YouTube API\n\t * @param {String} fn The function to call\n\t * @param {object} args The arguments to send to the function call\n\t */\n\tyouTubeApi = function( fn, args ) {\n\t\tvar $media = $( this.object.getIframe() ),\n\t\t\tstate;\n\n\t\tswitch ( fn ) {\n\t\tcase "play":\n\t\t\treturn this.object.playVideo();\n\t\tcase "pause":\n\t\t\treturn this.object.pauseVideo();\n\t\tcase "getPaused":\n\t\t\tstate = this.object.getPlayerState();\n\t\t\treturn state === -1 || state === 0 || state === 2 || state === 5;\n\t\tcase "getPlayed":\n\t\t\treturn this.object.getPlayerState() > -1;\n\t\tcase "getEnded":\n\t\t\treturn this.object.getPlayerState() === 0;\n\t\tcase "getDuration":\n\t\t\treturn this.object.getDuration();\n\t\tcase "getCurrentTime":\n\t\t\treturn this.object.getCurrentTime();\n\t\tcase "setCurrentTime":\n\t\t\treturn this.object.seekTo( args, true );\n\t\tcase "getMuted":\n\t\t\treturn this.object.isMuted();\n\t\tcase "setMuted":\n\t\t\tif ( args ) {\n\t\t\t\tthis.object.mute();\n\t\t\t} else {\n\t\t\t\tthis.object.unMute();\n\t\t\t}\n\t\t\tsetTimeout( function() {\n\t\t\t\t$media.trigger( "volumechange" );\n\t\t\t}, 50 );\n\t\t\tbreak;\n\t\tcase "getVolume":\n\t\t\treturn this.object.getVolume() / 100;\n\t\tcase "setVolume":\n\t\t\tthis.object.setVolume( args * 100 );\n\t\t\tsetTimeout( function() {\n\t\t\t\t$media.trigger( "volumechange" );\n\t\t\t}, 50 );\n\t\t\tbreak;\n\t\tcase "getCaptionsVisible":\n\t\t\treturn $( this ).hasClass( captionClass );\n\t\tcase "setCaptionsVisible":\n\t\t\tif ( args ) {\n\t\t\t\t$( this ).addClass( captionClass );\n\t\t\t\ttry {\n\t\t\t\t\tthis.object.loadModule( "cc" );\n\t\t\t\t\tthis.object.setOption( "cc", "track", { languageCode: this.object.getOption( "cc", "tracklist" )[ 0 ].languageCode } );\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\tthis.object.loadModule( "captions" );\n\t\t\t\t\tthis.object.setOption( "captions", "track", { languageCode: this.object.getOption( "captions", "tracklist" )[ 0 ].languageCode } );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$( this ).removeClass( captionClass );\n\t\t\t\tthis.object.unloadModule( "cc" );\n\t\t\t\tthis.object.unloadModule( "captions" );\n\t\t\t}\n\t\t\t$media.trigger( "ccvischange" );\n\t\t}\n\t},\n\n\t/**\n\t * @method youTubeEvents\n\t * @description Youtube API event manager\n\t * @param {object} event The event object fior the triggered event\n\t */\n\tyouTubeEvents = function( event ) {\n\t\tvar media = event.target.getIframe(),\n\t\t\t$media = $( media ),\n\t\t\ttimeline = function() {\n\t\t\t\t$media.trigger( "timeupdate" );\n\t\t\t};\n\n\t\tswitch ( event.data ) {\n\t\tcase null:\n\t\t\t$media\n\t\t\t\t.trigger( "canplay" )\n\t\t\t\t.trigger( "durationchange" );\n\t\t\tbreak;\n\t\tcase -1:\n\t\t\tevent.target.unMute();\n\t\t\t$media.trigger( "durationchange" );\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\t$media.trigger( "ended" );\n\t\t\tmedia.timeline = clearInterval( media.timeline );\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t$media\n\t\t\t\t.trigger( "canplay" )\n\t\t\t\t.trigger( "play" )\n\t\t\t\t.trigger( "playing" );\n\t\t\tmedia.timeline = setInterval( timeline, 250 );\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t$media.trigger( "pause" );\n\t\t\tmedia.timeline = clearInterval( media.timeline );\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmedia.timeline = clearInterval( media.timeline );\n\t\t\tbreak;\n\t\t}\n\t},\n\n\tyouTubeAPIReady = function() {\n\t\tvar youTube = window.youTube;\n\t\tyouTube.ready = true;\n\t\t$document.trigger( youtubeReadyEvent );\n\t},\n\n\tonResize = function() {\n\t\t$( selector + " object, " + selector + " iframe, " +  selector + " video" ).trigger( resizeEvent );\n\t};\n\n$document.on( "timerpoke.wb " + initEvent, selector, init );\n\n$window.on( "resize", onResize );\n\n$document.on( "ready", onResize );\n\n$document.on( "ajax-fetched.wb " + templateLoadedEvent, selector, function( event ) {\n\tvar $this = $( this );\n\n\tif ( event.type === "ajax-fetched" ) {\n\t\ttemplate = event.fetch.pointer.html();\n\n\t\t//Notify all player waiting for the controls to load\n\t\t$this = $( selector );\n\t}\n\n\t$this.trigger( {\n\t\ttype: initializedEvent\n\t} );\n} );\n\n$document.on( initializedEvent, selector, function( event ) {\n\tif ( event.namespace === componentName ) {\n\t\tvar $this = $( this ),\n\t\t\t$media = $this.children( "audio, video" ).eq( 0 ),\n\t\t\tcaptions = $media.children( "track[kind=\'captions\']" ).attr( "src" ) || undef,\n\t\t\tid = $this.attr( "id" ),\n\t\t\tmId = $media.attr( "id" ) || id + "-md",\n\t\t\ttype = $media.is( "audio" ) ? "audio" : "video",\n\t\t\ttitle = $media.attr( "title" ) || "",\n\t\t\twidth = type === "video" ? $media.attr( "width" ) || $media.width() : 0,\n\t\t\theight = type === "video" ? $media.attr( "height" ) || $media.height() : 0,\n\t\t\tsettings = wb.getData( $this, componentName ),\n\t\t\tdata = $.extend( {\n\t\t\t\tmedia: $media,\n\t\t\t\tcaptions: captions,\n\t\t\t\tid: id,\n\t\t\t\tmId: mId,\n\t\t\t\ttype: type,\n\t\t\t\ttitle: title,\n\t\t\t\theight: height,\n\t\t\t\twidth: width\n\t\t\t}, i18nText ),\n\t\t\tmedia = $media.get( 0 ),\n\t\t\tyouTube = window.youTube,\n\t\t\turl;\n\n\t\tif ( $media.attr( "id" ) === undef ) {\n\t\t\t$media.attr( "id", mId );\n\t\t}\n\n\t\tif ( settings !== undef ) {\n\t\t\tdata.shareUrl = settings.shareUrl;\n\t\t}\n\n\t\t$this.addClass( type );\n\n\t\tif ( $media.find( "[type=\'video/youtube\']" ).length > 0 ) {\n\n\t\t\t// lets tweak some variables and start the load sequence\n\t\t\turl = wb.getUrlParts( $this.find( "[type=\'video/youtube\']" ).attr( "src" ) );\n\n\t\t\t// lets set the flag for the call back\n\t\t\tdata.youTubeId = url.params.v ? url.params.v : url.pathname.substr( 1 );\n\n\t\t\tif ( youTube.ready === false ) {\n\t\t\t\t$document.one( youtubeReadyEvent, function() {\n\t\t\t\t\t$this.trigger( youtubeEvent, data );\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\t$this.trigger( youtubeEvent, data );\n\t\t\t}\n\n\t\t\t// finally lets load safely\n\t\t\treturn Modernizr.load( {\n\t\t\t\tload: "https://www.youtube.com/iframe_api"\n\t\t\t} );\n\n\t\t} else if ( media.error === null && media.currentSrc !== "" && media.currentSrc !== undef ) {\n\t\t\t$this.trigger( renderUIEvent, [ type, data ] );\n\t\t} else {\n\n\t\t\t// Do nothing since IE8 support is no longer required\n\t\t\treturn;\n\t\t}\n\n\t\t// Identify that initialization has completed\n\t\twb.ready( $this, componentName );\n\t}\n} );\n\n/*\n *  Youtube Video mode Event\n */\n$document.on( youtubeEvent, selector, function( event, data ) {\n\tif ( event.namespace === componentName ) {\n\t\tvar mId = data.mId,\n\t\t\t$this = $( event.currentTarget ),\n\t\t\t$media, ytPlayer;\n\n\t\tytPlayer = new YT.Player( mId, {\n\t\t\tvideoId: data.youTubeId,\n\t\t\tplayerVars: {\n\t\t\t\tautoplay: 0,\n\t\t\t\tcontrols: 0,\n\t\t\t\torigin: wb.pageUrlParts.host,\n\t\t\t\tmodestbranding: 1,\n\t\t\t\trel: 0,\n\t\t\t\tshowinfo: 0,\n\t\t\t\thtml5: 1,\n\t\t\t\tcc_load_policy: 1\n\t\t\t},\n\t\t\tevents: {\n\t\t\t\tonReady: function( event ) {\n\t\t\t\t\tonResize();\n\t\t\t\t\tyouTubeEvents( event );\n\t\t\t\t},\n\t\t\t\tonStateChange: youTubeEvents,\n\t\t\t\tonApiChange: function() {\n\n\t\t\t\t\t//If captions were enabled before the module was ready, re-enable them\n\t\t\t\t\tvar t = $this.get( 0 );\n\t\t\t\t\tt.player( "setCaptionsVisible", t.player( "getCaptionsVisible" ) );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t\t$this.addClass( "youtube" );\n\n\t\t$media = $this.find( "#" + mId ).attr( "tabindex", -1 );\n\n\t\tdata.media = $media;\n\t\tdata.ytPlayer = ytPlayer;\n\n\t\t$this.trigger( renderUIEvent, [ "youtube", data ] );\n\t}\n} );\n\n$document.on( renderUIEvent, selector, function( event, type, data ) {\n\tif ( event.namespace === componentName ) {\n\t\tvar $this = $( event.currentTarget ),\n\t\t\tcaptionsUrl = wb.getUrlParts( data.captions ),\n\t\t\tcurrentUrl = wb.getUrlParts( window.location.href ),\n\t\t\t$media = data.media,\n\t\t\t$eventReceiver;\n\n\t\t$media\n\t\t\t.after( tmpl( template, data ) )\n\t\t\t.wrap( "<div class=\\"display\\"></div>" );\n\n\t\t$eventReceiver = $media.is( "object" ) ? $media.children( ":first-child" ) : $media;\n\n\t\t// Create an adapter for the event management\n\t\t$eventReceiver.on( multimediaEvents, function( event ) {\n\t\t\t$this.trigger( event );\n\t\t} );\n\n\t\tthis.object = data.ytPlayer || $media.get( 0 );\n\t\tthis.player = ( data.ytPlayer ) ? youTubeApi : playerApi;\n\n\t\t// Trigger the duration change for cases where the event was called before the event binding\n\t\tif ( type !== "youtube" && !isNaN( this.player( "getDuration" ) ) ) {\n\t\t\t$eventReceiver.trigger( "durationchange" );\n\t\t}\n\n\t\t// Load the progress polyfill if needed\n\t\t$this.find( "progress" ).trigger( "wb-init.wb-progress" );\n\n\t\t// Load the slider polyfill if needed\n\t\t$this.find( "input[type=\'range\']" ).trigger( "wb-init.wb-slider" );\n\n\t\t// Create the share widgets if needed\n\t\tif ( data.shareUrl !== undef ) {\n\t\t\t$( "<div class=\'wb-share\' data-wb-share=\\\'{\\"type\\": \\"" +\n\t\t\t\t( type === "audio" ? type : "video" ) + "\\", \\"title\\": \\"" +\n\t\t\t\tdata.title.replace( /\'/g, "&apos;" ) + "\\", \\"url\\": \\"" + data.shareUrl +\n\t\t\t\t"\\", \\"pnlId\\": \\"" + data.id + "-shr\\"}\\\'></div>" )\n\t\t\t\t.insertBefore( $media.parent() )\n\t\t\t\t.trigger( "wb-init.wb-share" );\n\t\t}\n\n\t\tif ( data.captions === undef ) {\n\t\t\treturn 1;\n\t\t}\n\n\t\t// Load the captions\n\t\tif ( currentUrl.absolute.replace( currentUrl.hash || "#", "" ) !== captionsUrl.absolute.replace( captionsUrl.hash || "#", "" ) ) {\n\t\t\tloadCaptionsExternal( $media, captionsUrl.absolute );\n\t\t} else {\n\t\t\tloadCaptionsInternal( $media, $( "#" + wb.jqEscape( captionsUrl.hash.substring( 1 ) ) ) );\n\t\t}\n\t}\n} );\n\n/*\n * UI Bindings\n */\n\n$document.on( "click", selector, function( event ) {\n\tvar $target = $( event.target ),\n\t\tclassName = $target.attr( "class" ) || "";\n\n\t// Ignore middle and right mouse buttons\n\tif ( event.which === 2 || event.which === 3 ) {\n\t\treturn true;\n\t}\n\n\t// Optimized multiple class tests to include child glyphicon because Safari was reporting the click event\n\t// from the child span not the parent button, forcing us to have to check for both elements\n\t// JSPerf for multiple class matching http://jsperf.com/hasclass-vs-is-stackoverflow/7\n\tif ( className.match( /playpause|-play|-pause|display/ ) || $target.is( "object" ) || $target.is( "video" ) ) {\n\t\tthis.player( "getPaused" ) || this.player( "getEnded" ) ? this.player( "play" ) : this.player( "pause" );\n\t} else if ( className.match( /\\bcc\\b|-subtitles/ )  ) {\n\t\tthis.player( "setCaptionsVisible", !this.player( "getCaptionsVisible" ) );\n\t} else if ( className.match( /\\bmute\\b|-volume-(up|off)/ ) ) {\n\t\tthis.player( "setMuted", !this.player( "getMuted" ) );\n\t} else if ( $target.is( "progress" ) || $target.hasClass( "progress" ) || $target.hasClass( "progress-bar" ) ) {\n\t\tthis.player( "setCurrentTime", this.player( "getDuration" ) * ( ( event.pageX - $target.offset().left ) / $target.width() ) );\n\t} else if ( className.match( /\\brewind\\b|-backward/ ) ) {\n\t\tthis.player( "setCurrentTime", this.player( "getCurrentTime" ) - this.player( "getDuration" ) * 0.05 );\n\t} else if ( className.match( /\\bfastforward\\b|-forward/ ) ) {\n\t\tthis.player( "setCurrentTime", this.player( "getCurrentTime" ) + this.player( "getDuration" ) * 0.05 );\n\t} else if ( className.match( /cuepoint/ ) ) {\n\t\t$( this ).trigger( { type: "cuepoint", cuepoint: $target.data( "cuepoint" ) } );\n\t}\n} );\n\n$document.on( "input change", selector, function( event ) {\n\tvar target = event.target;\n\n\tif ( $( target ).hasClass( "volume" ) ) {\n\t\tevent.currentTarget.player( "setMuted", false );\n\t\tevent.currentTarget.player( "setVolume", target.value / 100 );\n\t}\n} );\n\n$document.on( "keydown", dispCtrls, function( event ) {\n\tvar playerTarget = event.currentTarget.parentNode,\n\t\twhich = event.which,\n\t\tvolume = 0,\n\t\tstep = 0.05,\n\t\t$playerTarget = $( playerTarget );\n\n\tif ( !( event.ctrlKey || event.altKey || event.metaKey ) ) {\n\t\tswitch ( which ) {\n\t\tcase 32:\n\n\t\t\t// Mute/unmute if focused on the mute/unmute button or volume input.\n\t\t\tif ( $( event.target ).hasClass( "mute" ) || event.target.nodeName === "INPUT" ) {\n\t\t\t\t$playerTarget.find( ".mute" ).trigger( "click" );\n\t\t\t} else if ( $( event.target ).hasClass( "cc" ) ) {\n\n\t\t\t\t// Show/hide captions if focused on the closed captions button.\n\t\t\t\t$playerTarget.find( ".cc" ).trigger( "click" );\n\t\t\t} else {\n\n\t\t\t\t// Play/pause if focused on anything else (i.e. the video itself, play/pause button or progress bar).\n\t\t\t\t$playerTarget.find( ".playpause" ).trigger( "click" );\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 37:\n\t\t\tplayerTarget.player( "setCurrentTime", this.parentNode.player( "getCurrentTime" ) - this.parentNode.player( "getDuration" ) * 0.05 );\n\t\t\tbreak;\n\n\t\tcase 39:\n\t\t\tplayerTarget.player( "setCurrentTime", this.parentNode.player( "getCurrentTime" ) + this.parentNode.player( "getDuration" ) * 0.05 );\n\t\t\tbreak;\n\n\t\tcase 38:\n\t\t\tvolume = Math.round( playerTarget.player( "getVolume" ) * 100 ) / 100 + step;\n\t\t\tplayerTarget.player( "setVolume", volume < 1 ? volume : 1 );\n\t\t\tbreak;\n\n\t\tcase 40:\n\t\t\tvolume = Math.round( playerTarget.player( "getVolume" ) * 100 ) / 100 - step;\n\t\t\tplayerTarget.player( "setVolume", volume > 0 ? volume : 0 );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n} );\n\n$document.on( "keyup", ctrls, function( event ) {\n\tif ( event.which === 32 && !( event.ctrlKey || event.altKey || event.metaKey ) ) {\n\n\t\t// Allows the spacebar to be used for play/pause without double triggering\n\t\treturn false;\n\t}\n} );\n\n$document.on( "wb-activate", selector, function() {\n\tthis.player( "play" );\n} );\n\n$document.on( multimediaEvents, selector, function( event, simulated ) {\n\tvar eventTarget = event.currentTarget,\n\t\teventType = event.type,\n\t\teventNamespace = event.namespace,\n\t\t$this = $( eventTarget ),\n\t\tinvStart = "<span class=\'wb-inv\'>",\n\t\tinvEnd = "</span>",\n\t\tcurrentTime, $button, $slider, buttonData, isPlay, isMuted, isCCVisible, skipTo, volume;\n\tswitch ( eventType ) {\n\tcase "playing":\n\tcase "pause":\n\tcase "ended":\n\t\tisPlay = eventType === "playing";\n\t\t$button = $this.find( ".playpause" );\n\t\tbuttonData = $button.data( "state-" + ( isPlay ? "off" : "on" ) );\n\t\tif ( isPlay ) {\n\t\t\t$this.addClass( "playing" );\n\t\t\t$this.find( ".progress" ).addClass( "active" );\n\t\t} else {\n\t\t\tif ( eventType === "ended" ) {\n\t\t\t\tthis.loading = clearTimeout( this.loading );\n\t\t\t}\n\t\t\t$this.removeClass( "playing" );\n\t\t}\n\t\t$button\n\t\t\t.attr( "title", buttonData )\n\t\t\t.children( "span" )\n\t\t\t\t.toggleClass( "glyphicon-play", !isPlay )\n\t\t\t\t.toggleClass( "glyphicon-pause", isPlay )\n\t\t\t\t.html( invStart + buttonData + invEnd );\n\t\tbreak;\n\n\tcase "volumechange":\n\t\tisMuted = eventTarget.player( "getMuted" );\n\t\t$button = $this.find( ".mute" );\n\t\tbuttonData = $button.data( "state-" + ( isMuted ? "off" : "on" ) );\n\t\tvolume = eventTarget.player( "getVolume" ) * 100;\n\t\t$button\n\t\t\t.attr( {\n\t\t\t\ttitle: buttonData,\n\t\t\t\t"aria-pressed": isMuted\n\t\t\t} )\n\t\t\t.children( "span" )\n\t\t\t\t.toggleClass( "glyphicon-volume-up", !isMuted )\n\t\t\t\t.toggleClass( "glyphicon-volume-off", isMuted )\n\t\t\t\t.html( invStart + buttonData + invEnd );\n\t\t$slider = $this.find( "input[type=\'range\']" );\n\t\t$slider[ 0 ].value = isMuted ? 0 : volume;\n\t\t$slider.trigger( "wb-update.wb-slider" );\n\t\tbreak;\n\n\tcase "timeupdate":\n\t\tcurrentTime = eventTarget.player( "getCurrentTime" );\n\t\t$this.find( "progress" )\n\t\t\t.attr(\n\t\t\t\t"value",\n\t\t\t\tMath.round( currentTime / eventTarget.player( "getDuration" ) * 1000 ) / 10\n\t\t\t).trigger( "wb-update.wb-progress" );\n\n\t\t$this.find( ".wb-mm-tmln-crrnt span:nth-child(2)" )\n\t\t\t.text( formatTime( currentTime ) );\n\n\t\tif ( $this.hasClass( captionClass ) && $.data( eventTarget, "captions" ) !== undef ) {\n\t\t\tupdateCaptions(\n\t\t\t\t$this.find( ".wb-mm-cc" ),\n\t\t\t\tcurrentTime,\n\t\t\t\t$.data( eventTarget, "captions" )\n\t\t\t);\n\t\t}\n\t\tbreak;\n\n\tcase "durationchange":\n\t\t$this.find( ".wb-mm-tmln-ttl span:nth-child(2)" )\n\t\t\t.text( formatTime( eventTarget.player( "getDuration" ) ) );\n\n\t\t// Skip to pointer from the querystring\n\t\tskipTo = wb.pageUrlParts.params[ event.target.id ];\n\t\tif ( skipTo ) {\n\t\t\tskipTo = parseTime( skipTo );\n\t\t\teventTarget.player( "setCurrentTime", skipTo );\n\t\t}\n\t\tbreak;\n\n\tcase "ccloaded":\n\t\tif ( eventNamespace === componentName ) {\n\t\t\t$.data( eventTarget, "captions", event.captions );\n\t\t}\n\t\tbreak;\n\n\tcase "ccloadfail":\n\t\tif ( eventNamespace === componentName ) {\n\t\t\t$this.find( ".wb-mm-cc" )\n\t\t\t\t.append( "<p class=\'errmsg\'><span>" + i18nText.cc_error + "</span></p>" )\n\t\t\t\t.end()\n\t\t\t\t.find( ".cc" )\n\t\t\t\t.attr( "disabled", "" );\n\t\t}\n\t\tbreak;\n\n\tcase "ccvischange":\n\t\tif ( eventNamespace === componentName ) {\n\t\t\tisCCVisible = eventTarget.player( "getCaptionsVisible" );\n\t\t\t$button = $this.find( ".cc" );\n\t\t\tbuttonData = $button.data( "state-" + ( isCCVisible ? "off" : "on" ) );\n\t\t\t$button.attr( {\n\t\t\t\ttitle: buttonData,\n\t\t\t\t"aria-pressed": isCCVisible\n\t\t\t} ).children( "span" ).html( invStart + buttonData + invEnd );\n\t\t}\n\t\tbreak;\n\n\tcase "waiting":\n\t\tif ( !simulated ) {\n\t\t\t$document.off( "progress", selector );\n\t\t}\n\t\tthis.loading = setTimeout( function() {\n\t\t\t$this.addClass( "waiting" );\n\t\t}, 500 );\n\t\tbreak;\n\n\tcase "canplay":\n\t\tthis.loading = clearTimeout( this.loading );\n\t\t$this.removeClass( "waiting" );\n\t\tbreak;\n\tcase "cuepoint":\n\t\teventTarget.player( "setCurrentTime", parseTime( event.cuepoint ) );\n\t\tbreak;\n\t}\n} );\n\n// Fallback for browsers that don\'t implement the waiting events\n$document.on( "progress", selector, function( event ) {\n\tvar eventTarget = event.currentTarget,\n\t\t$this = $( eventTarget );\n\n\t// Waiting detected\n\tif ( this.player( "getPaused" ) === false && this.player( "getCurrentTime" ) === this.player( "getPreviousTime" ) ) {\n\t\tif ( eventTarget.player( "getBuffering" ) === false ) {\n\t\t\teventTarget.player( "setBuffering", true );\n\t\t\t$this.trigger( "waiting", true );\n\t\t}\n\n\t// Waiting has ended\n\t} else if ( eventTarget.player( "getBuffering" ) === true ) {\n\t\teventTarget.player( "setBuffering", false );\n\t\t$this.trigger( "canplay", true );\n\t}\n\teventTarget.player( "setPreviousTime", eventTarget.player( "getCurrentTime" ) );\n} );\n\n$document.on( resizeEvent, selector, function( event ) {\n\tif ( event.namespace === componentName ) {\n\t\tvar media = event.target,\n\t\t\t$media = $( media ),\n\t\t\tratio, newHeight;\n\n\t\tif ( $( event.currentTarget ).hasClass( "video" ) ) {\n\t\t\tif ( media.videoWidth === 0 || media.videoWidth === undef ) {\n\t\t\t\tratio = $media.attr( "height" ) / $media.attr( "width" );\n\n\t\t\t\t// Calculate the new height based on the specified ratio or assume a default 16:9 ratio\n\t\t\t\tnewHeight = Math.round( $media.width() * ( !isNaN( ratio ) ? ratio : 0.5625 ) );\n\n\t\t\t\t$media.css( "height", newHeight + "px" );\n\t\t\t} else {\n\t\t\t\t$media.css( "height", "" );\n\t\t\t}\n\t\t}\n\t}\n} );\n\nwindow.onYouTubeIframeAPIReady = youTubeAPIReady;\n\nwindow.youTube = {\n\tready: false\n};\n\nwb.add( selector );\n\n} )( jQuery, window, wb );\n\n/**\n * @title WET-BOEW NavCurrent\n * @overview Identify URL in a navigation system that matches current page URL or a URL in the breadcrumb trail. Call by applying .trigger( "navcurr.wb", breadcrumb ) where the breadcrumb parameter is an optional object (DOM or jQuery)\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @pjackson28\n */\n( function( $, window, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-navcurr",\n\tselector = "." + componentName,\n\t$document = wb.doc,\n\tbreadcrumbLinksArray, breadcrumbLinksUrlArray,\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t * @param {jQuery DOM element | DOM element} breadcrumb Optional breadcrumb element\n\t * @param {string} classNameOverride Optional class name override (default is wb-navcurr)\n\t */\n\tinit = function( event, breadcrumb, classNameOverride ) {\n\t\tif ( event.namespace === "wb" ) {\n\n\t\t\t// Start initialization\n\t\t\t// returns DOM object = proceed with init\n\t\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\t\tvar menu = wb.init( event.target, componentName, selector ),\n\t\t\t\tmenuLinks = menu.getElementsByTagName( "a" ),\n\t\t\t\tmenuLinksArray = [],\n\t\t\t\tmenuLinksUrlArray = [],\n\t\t\t\twindowLocation = window.location,\n\t\t\t\tpageUrl = windowLocation.hostname + windowLocation.pathname.replace( /^([^\\/])/, "/$1" ),\n\t\t\t\tpageUrlQuery = windowLocation.search,\n\t\t\t\tmatch = false,\n\t\t\t\tclassName = classNameOverride ? classNameOverride : componentName,\n\t\t\t\tchild, len, i, j, link, linkHref, linkUrl, linkQuery, linkQueryLen,\n\t\t\t\tlocalBreadcrumbLinks, localBreadcrumbLinksArray, localBreadcrumbLinksUrlArray,\n\t\t\t\tlocalBreadcrumbQuery, localBreadcrumbLinkUrl;\n\n\t\t\tif ( menu ) {\n\n\t\t\t\t// Try to find a match with the page Url and cache link + Url for later if no match found\n\t\t\t\t// Perform the check and caching in reverse to go from more specific links to more general links\n\t\t\t\tfor ( i = menuLinks.length - 1; i !== -1; i -= 1 ) {\n\t\t\t\t\tlink = menuLinks[ i ];\n\t\t\t\t\tlinkHref = link.getAttribute( "href" );\n\t\t\t\t\tif ( linkHref !== null ) {\n\t\t\t\t\t\tif ( linkHref.length !== 0 && linkHref.charAt( 0 ) !== "#" ) {\n\t\t\t\t\t\t\tlinkUrl = link.hostname + link.pathname.replace( /^([^\\/])/, "/$1" );\n\t\t\t\t\t\t\tlinkQuery = link.search;\n\t\t\t\t\t\t\tlinkQueryLen = linkQuery.length;\n\t\t\t\t\t\t\tif ( pageUrl.slice( -linkUrl.length ) === linkUrl && ( linkQueryLen === 0 || pageUrlQuery.slice( -linkQueryLen ) === linkQuery ) ) {\n\t\t\t\t\t\t\t\tmatch = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmenuLinksArray.push( link );\n\t\t\t\t\t\t\tmenuLinksUrlArray.push( linkUrl );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// No page Url match found, try a breadcrumb link match instead\n\t\t\t\tif ( !match && breadcrumb ) {\n\n\t\t\t\t\t// Check to see if the data has been cached already\n\t\t\t\t\tif ( !breadcrumbLinksArray ) {\n\n\t\t\t\t\t\t// Pre-process the breadcrumb links\n\t\t\t\t\t\tlocalBreadcrumbLinksArray = [];\n\t\t\t\t\t\tlocalBreadcrumbLinksUrlArray = [];\n\t\t\t\t\t\tlocalBreadcrumbLinks = ( breadcrumb.jquery ? breadcrumb[ 0 ] : breadcrumb ).getElementsByTagName( "li" );\n\t\t\t\t\t\tlen = localBreadcrumbLinks.length;\n\t\t\t\t\t\tif ( len ) {\n\t\t\t\t\t\t\tlink = localBreadcrumbLinks[ len - 1 ];\n\t\t\t\t\t\t\tchild = link.firstChild;\n\t\t\t\t\t\t\tlinkHref = ( child && child.nodeName === "A" ) ? child.getAttribute( "href" ) : "";\n\t\t\t\t\t\t\tif ( linkHref && linkHref.charAt( 0 ) !== "#" ) {\n\t\t\t\t\t\t\t\tlocalBreadcrumbLinksArray.push( child );\n\t\t\t\t\t\t\t\tlocalBreadcrumbLinksUrlArray.push( child.hostname + child.pathname.replace( /^([^\\/])/, "/$1" ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Cache the data in case of more than one execution (e.g., site menu + secondary navigation)\n\t\t\t\t\t\tbreadcrumbLinksArray = localBreadcrumbLinksArray;\n\t\t\t\t\t\tbreadcrumbLinksUrlArray = localBreadcrumbLinksUrlArray;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Retrieve the cached data\n\t\t\t\t\t\tlocalBreadcrumbLinksArray = breadcrumbLinksArray;\n\t\t\t\t\t\tlocalBreadcrumbLinksUrlArray = breadcrumbLinksUrlArray;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Try to match each breadcrumb link\n\t\t\t\t\tlen = menuLinksArray.length;\n\t\t\t\t\tfor ( j = localBreadcrumbLinksArray.length - 1; j !== -1; j -= 1 ) {\n\t\t\t\t\t\tlocalBreadcrumbLinkUrl = localBreadcrumbLinksUrlArray[ j ];\n\t\t\t\t\t\tlocalBreadcrumbQuery = localBreadcrumbLinksArray[ j ].search;\n\n\t\t\t\t\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\t\t\t\t\tlink = menuLinksArray[ i ];\n\t\t\t\t\t\t\tlinkUrl = menuLinksUrlArray[ i ];\n\t\t\t\t\t\t\tlinkQuery = link.search;\n\t\t\t\t\t\t\tlinkQueryLen = linkQuery.length;\n\n\t\t\t\t\t\t\tif ( localBreadcrumbLinkUrl.slice( -linkUrl.length ) === linkUrl && ( linkQueryLen === 0 || localBreadcrumbQuery.slice( -linkQueryLen ) === linkQuery ) ) {\n\t\t\t\t\t\t\t\tmatch = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( match ) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( match ) {\n\t\t\t\t\tlink.className += " " + className;\n\t\t\t\t\tif ( menu.className.indexOf( "wb-menu" ) !== -1 && link.className.indexOf( "item" ) === -1 ) {\n\t\t\t\t\t\t$( link ).closest( ".sm" ).parent().children( "a" ).addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Identify that initialization has completed\n\t\t\t\twb.ready( $( menu ), componentName );\n\t\t\t}\n\t\t}\n\t};\n\n// Bind the navcurrent event of the plugin\n$document.on( "navcurr.wb", init );\n\n} )( jQuery, window, wb );\n\n/**\n * @title WET-BOEW Overlay\n * @overview Provides multiple styles of overlays such as panels and pop-ups\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @thomasgohard, @pjackson28\n */\n( function( $, window, document, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-overlay",\n\tselector = "." + componentName,\n\tinitEvent = "wb-init" + selector,\n\tcloseClass = "overlay-close",\n\tlinkClass = "overlay-lnk",\n\tignoreOutsideClass = "outside-off",\n\tOverlayOpenFlag = "wb-overlay-dlg",\n\tinitialized = false,\n\tsourceLinks = {},\n\tsetFocusEvent = "setfocus.wb",\n\t$document = wb.doc,\n\ti18n, i18nText,\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\t$elm, footer, closeTextFtr, overlayCloseFtr, $header, closeText, overlayClose;\n\n\t\tif ( elm ) {\n\t\t\t$elm = $( elm );\n\n\t\t\t// Only initialize the i18nText once\n\t\t\tif ( !i18nText ) {\n\t\t\t\ti18n = wb.i18n;\n\t\t\t\ti18nText = {\n\t\t\t\t\tclose: i18n( "close" ),\n\t\t\t\t\tcolon: i18n( "colon" ),\n\t\t\t\t\tspace: i18n( "space" ),\n\t\t\t\t\tesc: i18n( "esc-key" ),\n\t\t\t\t\tcloseOverlay: i18n( closeClass )\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// One left and right panels add close button\n\t\t\tvar isPanel = ( $elm.attr( "class" ).indexOf( "wb-panel" ) > -1 ) ? true : false,\n\t\t\t\tisPopup = ( $elm.attr( "class" ).indexOf( "wb-popup" ) > -1 ) ? true : false;\n\t\t\tif ( isPanel || isPopup ) {\n\t\t\t\tvar hasFooter, closeClassFtr, spanTextFtr, buttonStyle = "";\n\n\t\t\t\tfooter = $elm.find( ".modal-footer" )[ 0 ];\n\t\t\t\thasFooter = ( footer && footer.length !== 0 ) ? true : false;\n\t\t\t\tcloseClassFtr = ( $elm.hasClass( "wb-panel-l" ) ? "pull-right " : "pull-left " )  + closeClass;\n\n\t\t\t\tif ( hasFooter ) {\n\t\t\t\t\tspanTextFtr = footer.innerHTML + i18nText.space + i18nText.esc;\n\t\t\t\t} else {\n\t\t\t\t\tfooter = document.createElement( "div" );\n\t\t\t\t\tfooter.setAttribute( "class", "modal-footer" );\n\t\t\t\t\tspanTextFtr = i18nText.esc;\n\t\t\t\t}\n\n\t\t\t\tcloseTextFtr = i18nText.close;\n\t\t\t\tspanTextFtr = spanTextFtr.replace( "\'", "&#39;" );\n\n\t\t\t\tif ( isPopup ) {\n\t\t\t\t\tfooter.style.border = "0";\n\t\t\t\t}\n\n\t\t\t\toverlayCloseFtr = "<button type=\'button\' class=\'btn btn-sm btn-primary " + closeClassFtr +\n\t\t\t\t\t"\' style=\'" + buttonStyle +\n\t\t\t\t\t"\' title=\'" + closeTextFtr + " " + spanTextFtr + "\'>" +\n\t\t\t\t\tcloseTextFtr +\n\t\t\t\t\t"<span class=\'wb-inv\'>" + spanTextFtr + "</span></button>";\n\n\t\t\t\t$( footer ).append( overlayCloseFtr );\n\t\t\t\tif ( !hasFooter ) {\n\t\t\t\t\t$elm.append( footer );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add close button\n\t\t\t$header = $elm.find( ".modal-title" );\n\t\t\tif ( $header.length !== 0 ) {\n\t\t\t\tcloseText = i18nText.close + i18nText.colon + i18nText.space +\n\t\t\t\t\t$header.text() + i18nText.space + i18nText.esc;\n\t\t\t} else {\n\t\t\t\tcloseText = i18nText.closeOverlay;\n\t\t\t}\n\t\t\tcloseText = closeText.replace( "\'", "&#39;" );\n\t\t\toverlayClose = "<button type=\'button\' class=\'mfp-close " + closeClass +\n\t\t\t\t"\' title=\'" + closeText + "\'>&#xd7;<span class=\'wb-inv\'> " +\n\t\t\t\tcloseText + "</span></button>";\n\n\t\t\t$elm.append( overlayClose );\n\t\t\telm.setAttribute( "aria-hidden", "true" );\n\n\t\t\t// Identify that initialization has completed\n\t\t\tinitialized = true;\n\t\t\twb.ready( $elm, componentName );\n\t\t}\n\t},\n\n\topenOverlay = function( overlayId, noFocus ) {\n\t\tvar $overlay = $( "#" + wb.jqEscape( overlayId ) );\n\n\t\t$overlay\n\t\t\t.addClass( "open" )\n\t\t\t.attr( "aria-hidden", "false" );\n\n\t\tif ( $overlay.hasClass( "wb-popup-full" ) || $overlay.hasClass( "wb-popup-mid" ) ) {\n\t\t\t$overlay.attr( "data-pgtitle", document.getElementsByTagName( "H1" )[ 0 ].textContent );\n\t\t\t$document.find( "body" ).addClass( OverlayOpenFlag );\n\t\t}\n\n\t\tif ( !noFocus ) {\n\t\t\t$overlay\n\t\t\t\t.scrollTop( 0 )\n\t\t\t\t.trigger( setFocusEvent );\n\t\t}\n\n\t\t// Register the overlay if it wasn\'t previously registered\n\t\t// (only required when opening through an event)\n\t\tif ( !sourceLinks[ overlayId ] ) {\n\t\t\tsetTimeout( function() {\n\t\t\t\tsourceLinks[ overlayId ] = null;\n\t\t\t}, 1 );\n\t\t}\n\t},\n\n\tcloseOverlay = function( overlayId, noFocus, userClosed ) {\n\t\tvar $overlay = $( "#" + overlayId ),\n\t\t\tsourceLink = sourceLinks[ overlayId ];\n\n\t\t$overlay\n\t\t\t.removeClass( "open" )\n\t\t\t.attr( "aria-hidden", "true" );\n\n\t\tif ( $overlay.hasClass( "wb-popup-full" ) || $overlay.hasClass( "wb-popup-mid" ) ) {\n\t\t\t$document.find( "body" ).removeClass( OverlayOpenFlag );\n\t\t}\n\n\t\tif ( userClosed ) {\n\t\t\t$overlay.addClass( "user-closed" );\n\t\t}\n\n\t\tif ( !noFocus && sourceLink ) {\n\n\t\t\t// Returns focus to the source link for the overlay\n\t\t\t$( sourceLink ).trigger( setFocusEvent );\n\t\t}\n\n\t\t// Delete the source link reference\n\t\tdelete sourceLinks[ overlayId ];\n\t};\n\n$document.on( "timerpoke.wb " + initEvent + " keydown open" + selector +\n" close" + selector, selector, function( event ) {\n\n\tvar eventType = event.type,\n\t\twhich = event.which,\n\t\teventTarget = event.target,\n\t\teventTurrentTarget = event.currentTarget,\n\t\toverlayId = eventTurrentTarget.id,\n\t\toverlay, $focusable, index, length;\n\n\tswitch ( eventType ) {\n\tcase "timerpoke":\n\tcase "wb-init":\n\t\tinit( event );\n\t\tbreak;\n\n\tcase "open":\n\t\tif ( eventTurrentTarget === eventTarget ) {\n\t\t\topenOverlay( overlayId, event.noFocus );\n\t\t}\n\t\tbreak;\n\n\tcase "close":\n\t\tif ( eventTurrentTarget === eventTarget ) {\n\t\t\tcloseOverlay( overlayId, event.noFocus );\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\toverlay = document.getElementById( overlayId );\n\n\t\tswitch ( which ) {\n\n\t\t// Tab key\n\t\tcase 9:\n\n\t\t\t// No special tab handling when ignoring outside activity\n\t\t\tif ( overlay.className.indexOf( ignoreOutsideClass ) === -1 ) {\n\t\t\t\t$focusable = $( overlay ).find( ":focusable:not([tabindex=\'-1\'])" );\n\t\t\t\tlength = $focusable.length;\n\t\t\t\tindex = $focusable.index( event.target ) + ( event.shiftKey ? -1 : 1 );\n\n\t\t\t\tif ( index === -1 || index === length ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t$focusable.eq( index === -1 ? length - 1 : 0 )\n\t\t\t\t\t\t.trigger( setFocusEvent );\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Escape key\n\t\tcase 27:\n\t\t\tif ( !event.isDefaultPrevented() ) {\n\t\t\t\tcloseOverlay( overlayId, false, true );\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n} );\n\n// Handler for clicking on the close button of the overlay\n$document.on( "click vclick", "." + closeClass, function( event ) {\n\tvar which = event.which;\n\n\t// Ignore if not initialized and middle/right mouse buttons\n\tif ( initialized && ( !which || which === 1 ) ) {\n\t\tcloseOverlay(\n\t\t\t$( event.currentTarget ).closest( selector ).attr( "id" ),\n\t\t\tfalse,\n\t\t\ttrue\n\t\t);\n\t}\n} );\n\n// Handler for clicking on a source link for the overlay\n$document.on( "click vclick keydown", "." + linkClass, function( event ) {\n\tvar which = event.which,\n\t\tsourceLink = event.currentTarget,\n\t\toverlayId = sourceLink.hash.substring( 1 );\n\n\t// Ignore if not initialized and middle/right mouse buttons\n\tif ( initialized && ( !which || which === 1 || which === 32 ) ) {\n\t\tevent.preventDefault();\n\n\t\t// Introduce a delay to prevent outside activity detection\n\t\tsetTimeout( function() {\n\n\t\t\t// Stores the source link for the overlay\n\t\t\tsourceLinks[ overlayId ] = sourceLink;\n\n\t\t\t// Opens the overlay\n\t\t\topenOverlay( overlayId );\n\t\t}, 1 );\n\t}\n} );\n\n// Handler for clicking on a same page link within the overlay to outside the overlay\n$document.on( "click vclick", selector + " a[href^=\'#\']", function( event ) {\n\tvar which = event.which,\n\t\teventTarget = event.target,\n\t\thref, overlay, linkTarget;\n\n\t// Ignore if not initialized and middle/right mouse buttons\n\tif ( initialized && ( !which || which === 1 ) ) {\n\t\toverlay = $( eventTarget ).closest( selector )[ 0 ];\n\t\thref = eventTarget.getAttribute( "href" );\n\t\tlinkTarget = document.getElementById( href.substring( 1 ) );\n\n\t\t// Ignore same page links to within the overlay\n\t\tif ( href.length > 1 && !$.contains( overlay, linkTarget ) ) {\n\n\t\t\t// Stop propagation of the click event\n\t\t\tif ( event.stopPropagation ) {\n\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t} else {\n\t\t\t\tevent.cancelBubble = true;\n\t\t\t}\n\n\t\t\t// Close the overlay and set focus to the same page link\n\t\t\tcloseOverlay( overlay.id, true );\n\t\t\t$( linkTarget ).trigger( setFocusEvent );\n\t\t}\n\t}\n} );\n\n// Outside activity detection\n$document.on( "click vclick touchstart focusin", "body", function( event ) {\n\tvar eventTarget = event.target,\n\t\twhich = event.which,\n\t\toverlayId, overlay;\n\n\t// Ignore if not initialized and middle/right mouse buttons\n\tif ( initialized && ( !which || which === 1 ) ) {\n\n\t\t// Close any overlays with outside activity\n\t\tfor ( overlayId in sourceLinks ) {\n\t\t\toverlay = document.getElementById( overlayId );\n\t\t\tif ( overlay && overlay.getAttribute( "aria-hidden" ) === "false" &&\n\t\t\t\teventTarget.id !== overlayId &&\n\t\t\t\toverlay.className.indexOf( ignoreOutsideClass ) === -1 &&\n\t\t\t\t!$.contains( overlay, eventTarget ) ) {\n\n\t\t\t\t// Close the overlay\n\t\t\t\tcloseOverlay( overlayId );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Ensure any element in focus outside an overlay is visible\n$document.on( "keyup", function( ) {\n\tvar elmInFocus, elmInFocusRect, focusAreaBelow, focusAreaAbove,\n\t\toverlayId, overlay, overlayRect;\n\n\t// Ignore if not initialized\n\tif ( initialized ) {\n\t\telmInFocus = document.activeElement;\n\t\telmInFocusRect = elmInFocus.getBoundingClientRect();\n\t\tfocusAreaBelow = 0;\n\t\tfocusAreaAbove = window.innerHeight;\n\n\t\t// Ensure that at least one overlay is visible, and that the element in focus is not an overlay,\n\t\t// a child of an overlay, or the body element\n\t\tif ( $.isEmptyObject( sourceLinks ) || elmInFocus.className.indexOf( componentName ) !== -1 ||\n\t\t\t$( elmInFocus ).parents( selector ).length !== 0 || elmInFocus === document.body ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine the vertical portion of the viewport that is not obscured by an overlay\n\t\tfor ( overlayId in sourceLinks ) {\n\t\t\toverlay = document.getElementById( overlayId );\n\t\t\tif ( overlay && overlay.getAttribute( "aria-hidden" ) === "false" ) {\n\t\t\t\toverlayRect = overlay.getBoundingClientRect();\n\t\t\t\tif ( overlay.className.indexOf( "wb-bar-t" ) !== -1 ) {\n\t\t\t\t\tfocusAreaBelow = Math.max( overlayRect.bottom, focusAreaBelow );\n\t\t\t\t} else if ( overlay.className.indexOf( "wb-bar-b" ) !== -1 ) {\n\t\t\t\t\tfocusAreaAbove = Math.min( overlayRect.top, focusAreaAbove );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Ensure the element in focus is visible\n\t\t// TODO: Find a solution for when there isn\'t enough page to scoll up or down\n\t\tif ( elmInFocusRect.top < focusAreaBelow ) {\n\n\t\t\t// Scroll down till the top of the element is visible\n\t\t\twindow.scrollBy( 0, focusAreaBelow - elmInFocusRect.top );\n\t\t} else if ( elmInFocusRect.bottom > focusAreaAbove ) {\n\n\t\t\t// Scroll up till the bottom of the element is visible\n\t\t\twindow.scrollBy( 0, elmInFocusRect.bottom - focusAreaAbove );\n\t\t}\n\t}\n} );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, document, wb );\n\n/**\n * @title WET-BOEW Prettify Plugin\n * @overview Wrapper for Google Code Prettify library: https://github.com/google/code-prettify\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @patheard\n */\n/*\n * Syntax highlighting of source code snippets in an html page using [google-code-prettify](https://github.com/google/code-prettify).\n *\n * 1. Apply `class="prettyprint"` to a `pre` or `code` element to apply syntax highlighting. Alternatively use `class="all-pre"` to apply syntax highlighting to all `pre` elements on the page.\n * 2. Apply `class="linenums"` to a `pre` or `code` element to add line numbers. Alternatively use `class="all-linenums"` to all applicable `pre` elements. Specify the starting number by adding `linenums:#` before `linenums`.\n * 3. Add extra language support by applying `class="lang-*"` to each applicable `pre` or `code` element. Supported language syntax CSS classes are as follows:\n *    - lang-apollo\n *    - lang-clj\n *    - lang-css\n *    - lang-dart\n *    - lang-go\n *    - lang-hs\n *    - lang-lisp\n *    - lang-lua\n *    - lang-ml\n *    - lang-n\n *    - lang-proto\n *    - lang-scala\n *    - lang-sql\n *    - lang-tex\n *    - lang-vb\n *    - lang-vhdl\n *    - lang-wiki\n *    - lang-xq\n *    - lang-yaml\n */\n( function( $, window, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-prettify",\n\tselector = "." + componentName,\n\tinitEvent = "wb-init" + selector,\n\tprettyPrintEvent = "prettyprint" + selector,\n\t$document = wb.doc,\n\n\t/*\n\t * Plugin users can override these defaults by setting attributes on the html elements that the\n\t * selector matches.\n\t */\n\tdefaults = {\n\t\tlinenums: false,\n\t\tallpre: false\n\t},\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\tmodeJS = wb.getMode() + ".js",\n\t\t\tdeps = [ "site!deps/prettify" + modeJS ],\n\t\t\t$elm, classes, settings, i, len, $pre;\n\n\t\tif ( elm ) {\n\t\t\t$elm = $( elm );\n\t\t\tclasses = elm.className.split( " " );\n\n\t\t\t// Merge default settings with overrides from the selected plugin element. There may be more than one, so don\'t override defaults globally!\n\t\t\tsettings = $.extend( {}, defaults, $elm.data() );\n\n\t\t\t// Check the element for `lang-*` syntax CSS classes\n\t\t\tfor ( i = 0, len = classes.length; i !== len; i += 1 ) {\n\t\t\t\tif ( classes[ i ].indexOf( "lang-" ) === 0 ) {\n\t\t\t\t\tdeps.push( "site!deps/" + classes[ i ] + modeJS );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// CSS class overides of settings\n\t\t\tsettings.allpre = settings.allpre || $elm.hasClass( "all-pre" );\n\t\t\tsettings.linenums = settings.linenums || $elm.hasClass( "linenums" );\n\n\t\t\t// Apply global settings\n\t\t\tif ( settings.allpre || settings.linenums ) {\n\t\t\t\t$pre = $document.find( "pre" );\n\t\t\t\tif ( settings.allpre ) {\n\t\t\t\t\t$pre.addClass( "prettyprint" );\n\t\t\t\t}\n\t\t\t\tif ( settings.linenums ) {\n\t\t\t\t\t$pre.filter( ".prettyprint" ).addClass( "linenums" );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Load the required dependencies and prettify the code once finished\n\t\t\tModernizr.load( {\n\t\t\t\tload: deps,\n\t\t\t\tcomplete: function() {\n\t\t\t\t\t$document.trigger( prettyPrintEvent );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t},\n\n\tprettifyDone = function() {\n\n\t\t// Identify that initialization has completed\n\t\twb.ready( $document, componentName );\n\t},\n\n\t/*\n\t * Invoke the Google pretty print library if it has been initialized\n\t * @method prettyprint\n\t */\n\tprettyprint = function( event ) {\n\t\tif ( event.namespace === componentName &&\n\t\t\ttypeof window.prettyPrint === "function" ) {\n\n\t\t\twindow.prettyPrint( prettifyDone );\n\t\t}\n\t};\n\n// Bind the plugin events\n$document\n\t.on( "timerpoke.wb " + initEvent, selector, init )\n\t.on( prettyPrintEvent, prettyprint );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, wb );\n\n/**\n * @title WET-BOEW Resize\n * @overview Text and window resizing event handler\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @pjackson28\n */\n( function( $, window, document, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-rsz",\n\tselector = "#" + componentName,\n\tinitEvent = "wb-init" + selector,\n\t$document = wb.doc,\n\tsizes = [],\n\tevents = [\n\t\t"txt-rsz.wb",\n\t\t"win-rsz-width.wb",\n\t\t"win-rsz-height.wb"\n\t],\n\n\t// Breakpoint names and lower pixel limits\n\tbreakpoints = {\n\t\txxsmallview: 0,\n\t\txsmallview: 480,\n\t\tsmallview: 768,\n\t\tmediumview: 992,\n\t\tlargeview: 1200,\n\t\txlargeview: 1600\n\t},\n\tresizeTest, currentView,\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\tlocalResizeTest;\n\n\t\tif ( elm ) {\n\n\t\t\t// Set up the DOM element used for resize testing\n\t\t\tlocalResizeTest = document.createElement( "span" );\n\t\t\tlocalResizeTest.innerHTML = "&#160;";\n\t\t\tlocalResizeTest.setAttribute( "id", componentName );\n\t\t\tdocument.body.appendChild( localResizeTest );\n\t\t\tresizeTest = localResizeTest;\n\n\t\t\t// Get a snapshot of the current sizes\n\t\t\tsizes = [\n\t\t\t\tlocalResizeTest.offsetHeight,\n\t\t\t\twindow.innerWidth || $document.width(),\n\t\t\t\twindow.innerHeight || $document.height()\n\t\t\t];\n\n\t\t\t// Determine the current view\n\t\t\tviewChange( sizes[ 1 ] );\n\n\t\t\t// Identify that initialization has completed\n\t\t\twb.ready( $document, componentName );\n\t\t}\n\t},\n\n\tviewChange = function( viewportWidth ) {\n\t\tvar breakpoint, viewName;\n\n\t\t// Check for a change between views\n\t\tfor ( breakpoint in breakpoints ) {\n\n\t\t\t// Determine the current view\n\t\t\tif ( viewportWidth < breakpoints[ breakpoint ] ) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tviewName = breakpoint;\n\t\t\t}\n\t\t}\n\n\t\t// Determine if the current view is different than the previous view\n\t\tif ( viewName !== currentView ) {\n\n\t\t\t// Change the breakpoint class on the html element\n\t\t\twb.html\n\t\t\t\t.removeClass( currentView || "" )\n\t\t\t\t.addClass( viewName );\n\n\t\t\t// Update the current view\n\t\t\tcurrentView = viewName;\n\n\t\t\t// Trigger the view event\n\t\t\t$document.trigger( viewName + ".wb" );\n\t\t}\n\t},\n\n\t/**\n\t * Tests for text size, window width and window height changes and triggers an event when a change is found\n\t * @method test\n\t */\n\ttest = function() {\n\t\tvar currentSizes = [\n\t\t\t\tresizeTest.offsetHeight,\n\t\t\t\twindow.innerWidth || $document.width(),\n\t\t\t\twindow.innerHeight || $document.height()\n\t\t\t],\n\t\t\tlen = currentSizes.length,\n\t\t\ti;\n\n\t\t// Check for a viewport or text size change\n\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\tif ( currentSizes[ i ] !== sizes[ i ] ) {\n\n\t\t\t\t// Change detected so trigger related event\n\t\t\t\t$document.trigger( events[ i ], currentSizes );\n\n\t\t\t\t// Check for a view change\n\t\t\t\tviewChange( currentSizes[ 1 ] );\n\t\t\t}\n\t\t}\n\t\tsizes = currentSizes;\n\n\t\treturn;\n\t};\n\n// Bind the init event to the plugin\n$document.on( initEvent, init );\n\n// Re-test on each timerpoke\n$document.on( "timerpoke.wb", selector, test );\n\n// Initialize the resources\n$document.trigger( initEvent );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, document, wb );\n\n/**\n * @title WET-BOEW Session Timeout\n * @overview Helps Web asset owners to provide session timeout and inactivity timeout functionality.\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @patheard\n */\n( function( $, window, document, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar $modal, $modalLink, countdownInterval, i18n, i18nText,\n\t$document = wb.doc,\n\tcomponentName = "wb-sessto",\n\tselector = "." + componentName,\n\tconfirmClass = componentName + "-confirm",\n\tinitEvent = "wb-init" + selector,\n\tresetEvent = "reset" + selector,\n\tkeepaliveEvent = "keepalive" + selector,\n\tinactivityEvent = "inactivity" + selector,\n\tdataAttr = componentName,\n\n\t/*\n\t * Plugin users can override these defaults by setting attributes on the html elements that the\n\t * selector matches.\n\t * For example, adding the attribute data-option1="false", will override option1 for that plugin instance.\n\t */\n\tdefaults = {\n\t\tinactivity: 1200000,\t\t/* default inactivity period 20 minutes */\n\t\treactionTime: 180000,\t\t/* default confirmation period of 3 minutes */\n\t\tsessionalive: 1200000,\t\t/* default keepalive period of 20 minutes */\n\t\trefreshCallbackUrl: null,\t/* refresh callback if using AJAX keepalive (no default) */\n\t\tlogouturl: "./",\t\t\t/* logout URL once the session has expired */\n\t\trefreshOnClick: true,\t\t/* refresh session if user clicks on the page */\n\t\trefreshLimit: 120000,\t\t/* default period of 2 minutes (ajax calls happen only once during this period) */\n\t\tmethod: "POST",\t\t\t\t/* the request method to use */\n\t\tadditionalData: null,\t\t/* additional data to send with the request */\n\t\trefreshCallback: function( response ) {\t/* callback function used to check the server response */\n\t\t\treturn response.replace( /\\s/g, "" ) === "true";\n\t\t}\n\t},\n\n\t/**\n\t * @function init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\t$elm, settings, onReady;\n\n\t\tif ( elm ) {\n\t\t\t$elm = $( elm );\n\n\t\t\t// For backwards compatibility where data-wet-boew was used instead of data-wb-sessto\n\t\t\tif ( !$elm.attr( "data-" + componentName ) ) {\n\t\t\t\tdataAttr = "wet-boew";\n\t\t\t}\n\n\t\t\t// Merge default settings with overrides from the plugin element\n\t\t\t// and save back to the element for future reference\n\t\t\tsettings = $.extend( {}, defaults, window[ componentName ], $elm.data( dataAttr ) );\n\t\t\t$elm.data( dataAttr, settings );\n\n\t\t\t// Only initialize the i18nText once\n\t\t\tif ( !i18nText ) {\n\t\t\t\ti18n = wb.i18n;\n\t\t\t\ti18nText = {\n\t\t\t\t\tbuttonContinue: i18n( "st-btn-cont" ),\n\t\t\t\t\tbuttonEnd: i18n( "st-btn-end" ),\n\t\t\t\t\tbuttonSignin: i18n( "tmpl-signin" ),\n\t\t\t\t\ttimeoutBegin: i18n( "st-to-msg-bgn" ),\n\t\t\t\t\ttimeoutEnd: i18n( "st-to-msg-end" ),\n\t\t\t\t\ttimeoutTitle: i18n( "st-msgbx-ttl" ),\n\t\t\t\t\ttimeoutAlready: i18n( "st-alrdy-to-msg" )\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tonReady = function() {\n\n\t\t\t\t// Setup the refresh on click behaviour\n\t\t\t\tinitRefreshOnClick( $elm, settings );\n\n\t\t\t\t// Initialize the keepalive and inactive timeouts of the plugin\n\t\t\t\t$elm.trigger( resetEvent, settings );\n\n\t\t\t\t// Identify that initialization has completed\n\t\t\t\twb.ready( $elm, componentName );\n\t\t\t};\n\n\t\t\t// Create the modal dialog\n\t\t\tinitModalDialog( onReady );\n\t\t}\n\t},\n\n\t/**\n\t * Initializes a timeout that triggers an event\n\t * @function initEventTimeout\n\t * @param {jQuery DOM Element} $elm Element to trigger the event on\n\t * @param {string} eventName Name of the event to trigger on setTimeout\n\t * @param {mixed} time Time to wait before triggering the event\n\t * @param {Object} settings Key-value object\n\t */\n\tinitEventTimeout = function( $elm, eventName, time, settings ) {\n\n\t\t// Clear any existing timeout for the event\n\t\tclearTimeout( $elm.data( eventName ) );\n\n\t\t// Create the new timeout that will trigger the event\n\t\t$elm.data( eventName, setTimeout( function() {\n\t\t\t$elm.trigger( eventName, settings );\n\t\t}, parseTime( time ) ) );\n\t},\n\n\t/**\n\t * Creates the modal dialog element, appends to the <body> and initializes the lightbox plugin\n\t * that is used to create the dialog behaviour.\n\t * @function initModalDialog\n\t */\n\tinitModalDialog = function( callback ) {\n\t\tvar modalID = "#" + componentName + "-modal",\n\t\t\tchild, modal, temp;\n\n\t\tif ( $document.find( modalID ).length === 0 ) {\n\t\t\tmodal = document.createDocumentFragment();\n\t\t\ttemp = document.createElement( "div" );\n\n\t\t\t// Create the modal dialog.  A temp <div> element is used so that its innerHTML can be set as a string.\n\t\t\ttemp.innerHTML = "<a class=\'wb-lbx lbx-modal mfp-hide\' href=\'#" + componentName + "-modal\'>" + i18nText.timeoutTitle + "</a>" +\n\t\t\t\t"<section id=\'" + componentName + "-modal\' class=\'mfp-hide modal-dialog modal-content overlay-def\'>" +\n\t\t\t\t"<header class=\'modal-header\'><h2 class=\'modal-title\'>" + i18nText.timeoutTitle + "</h2></header>" +\n\t\t\t\t"<div class=\'modal-body\'></div>" +\n\t\t\t\t"<div class=\'modal-footer\'></div>" +\n\t\t\t\t"</section>";\n\n\t\t\t// Get the temporary <div>\'s top level children and append to the fragment\n\t\t\twhile ( ( child = temp.firstChild ) !== null ) {\n\t\t\t\tmodal.appendChild( child );\n\t\t\t}\n\t\t\tdocument.body.appendChild( modal );\n\n\t\t\t$modal = $document.find( modalID );\n\n\t\t\t// Get object references to the modal and its triggering link\n\t\t\t$modalLink = $modal.prev()\n\t\t\t\t.one( "wb-ready.wb-lbx", callback )\n\t\t\t\t.trigger( "wb-init.wb-lbx" );\n\t\t} else {\n\t\t\tcallback();\n\t\t}\n\t},\n\n\t/**\n\t * Initialize the refresh on click keepalive behaviour. This will cause a `keepalive.wb-sessto`\n\t * event to be triggered when the document is clicked, limited by the settings.refreshLimit value.\n\t * @function initRefreshOnClick\n\t * @param {jQuery DOM Element} $elm DOM element to trigger the event on\n\t * @param {Object} settings Key-value object that will be passed when event is triggered.\n\t */\n\tinitRefreshOnClick = function( $elm, settings ) {\n\t\tif ( settings.refreshOnClick ) {\n\t\t\t$document.on( "click", function( event ) {\n\t\t\t\tvar className = event.target.className,\n\t\t\t\t\tlastActivity, currentTime;\n\n\t\t\t\t// Ignore clicks when the modal dialog is open\n\t\t\t\tif ( ( !className || className.indexOf( confirmClass ) === -1 ) &&\n\t\t\t\t\t$( ".mfp-ready ." + confirmClass ).length === 0 ) {\n\n\t\t\t\t\tlastActivity = $elm.data( "lastActivity" );\n\t\t\t\t\tcurrentTime = getCurrentTime();\n\t\t\t\t\tif ( !lastActivity || ( currentTime - lastActivity ) > settings.refreshLimit ) {\n\t\t\t\t\t\t$elm\n\t\t\t\t\t\t\t.trigger( resetEvent, settings )\n\t\t\t\t\t\t\t.trigger( keepaliveEvent, settings );\n\t\t\t\t\t\t$elm.data( "lastActivity", currentTime );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t},\n\n\t/**\n\t * Keepalive session event handler. Sends the POST request to determine if the session is still alive.\n\t * @function keepalive\n\t * @param {jQuery Event} event `keepalive.wb-sessto` event that triggered the function call\n\t * @param {Object} settings Key-value object\n\t */\n\tkeepalive = function( event, settings ) {\n\t\tvar $elm = $( event.target );\n\t\tif ( settings.refreshCallbackUrl !== null ) {\n\t\t\t$.ajax( {\n\t\t\t\turl: settings.refreshCallbackUrl,\n\t\t\t\tdata: settings.additionalData,\n\t\t\t\tdataType: "text",\n\t\t\t\tmethod: settings.method,\n\t\t\t\tsuccess: function( response ) {\n\n\t\t\t\t\t// Session is valid\n\t\t\t\t\tif ( response && settings.refreshCallback( response ) ) {\n\t\t\t\t\t\t$elm.trigger( resetEvent, settings );\n\n\t\t\t\t\t// Session has timed out - let the user know they need to sign in again\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// End the inactivity timeouts since the session is already kaput\n\t\t\t\t\t\tclearTimeout( $elm.data( inactivityEvent ) );\n\t\t\t\t\t\tclearTimeout( $elm.data( keepaliveEvent ) );\n\n\t\t\t\t\t\topenModal( {\n\t\t\t\t\t\t\tbody: "<p>" + i18nText.timeoutAlready + "</p>",\n\t\t\t\t\t\t\tbuttons: $( "<button type=\'button\' class=\'" + confirmClass +\n\t\t\t\t\t\t\t\t" btn btn-primary popup-modal-dismiss\'>" + i18nText.buttonSignin + "</button>" )\n\t\t\t\t\t\t\t\t\t.data( "logouturl", settings.logouturl )\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t},\n\n\t/**\n\t * Inactivity check event handler. Displays the modal dialog to allow the user to confirm their activity.\n\t * @function inactivity\n\t * @param {jQuery Event} event `inactivity.wb-sessto` event that triggered the function call\n\t * @param {Object} settings Key-value object\n\t */\n\tinactivity = function( event, settings ) {\n\t\tvar $buttonContinue, $buttonEnd,\n\t\t\ttime = getTime( settings.reactionTime ),\n\t\t\ttimeoutBegin = i18nText.timeoutBegin\n\t\t\t\t.replace( "#min#", "<span class=\'min\'>" + time.minutes + "</span>" )\n\t\t\t\t.replace( "#sec#", "<span class=\'sec\'>" + time.seconds + "</span>" ),\n\t\t\tbuttonStart = "<button type=\'button\' class=\'",\n\t\t\tbuttonEnd = "</button>";\n\n\t\t// Clear the keepalive timeout to avoid double firing of requests\n\t\tclearTimeout( $( event.target ).data( keepaliveEvent ) );\n\n\t\t$buttonContinue = $( buttonStart + confirmClass +\n\t\t\t" btn btn-primary popup-modal-dismiss\'>" + i18nText.buttonContinue + buttonEnd )\n\t\t\t\t.data( settings )\n\t\t\t\t.data( "start", getCurrentTime() );\n\t\t$buttonEnd = $( buttonStart + confirmClass + " btn btn-default\'>" +\n\t\t\ti18nText.buttonEnd + buttonEnd )\n\t\t\t\t.data( "logouturl", settings.logouturl );\n\n\t\topenModal( {\n\t\t\tbody: "<p>" + timeoutBegin + "<br />" + i18nText.timeoutEnd + "</p>",\n\t\t\tbuttons: [ $buttonContinue, $buttonEnd ],\n\t\t\topen: function() {\n\t\t\t\tvar $minutes = $modal.find( ".min" ),\n\t\t\t\t\t$seconds = $modal.find( ".sec" );\n\t\t\t\tcountdownInterval = setInterval( function() {\n\t\t\t\t\tif ( countdown( $minutes, $seconds ) ) {\n\t\t\t\t\t\tclearInterval( countdownInterval );\n\n\t\t\t\t\t\t// Let the user know their session has timed out\n\t\t\t\t\t\t$modal.find( "p" ).text( i18nText.timeoutAlready );\n\t\t\t\t\t\t$buttonContinue.text( i18nText.buttonSignin );\n\t\t\t\t\t\t$buttonEnd.hide();\n\t\t\t\t\t}\n\t\t\t\t}, 1000 );\n\t\t\t}\n\t\t} );\n\t},\n\n\t/**\n\t * Initialize the inactivity and keepalive timeouts of the plugin\n\t * @function reset\n\t * @param {jQuery Event} event `reset.wb-sessto` event that triggered the function call\n\t * @param {Object} settings Key-value object\n\t */\n\treset = function( event, settings ) {\n\t\tvar $elm = $( event.target );\n\n\t\tinitEventTimeout( $elm, inactivityEvent, settings.inactivity, settings );\n\t\tif ( settings.refreshCallbackUrl !== null ) {\n\t\t\tinitEventTimeout( $elm, keepaliveEvent, settings.sessionalive, settings );\n\t\t}\n\t},\n\n\t/**\n\t * Checks if the user wants to keep their session alive.\n\t * @function inactivity\n\t * @param {jQuery Event} event `confirm.wb-sessto` event that triggered the function call\n\t */\n\tconfirm = function( event ) {\n\t\tvar elm = event.target,\n\t\t\t$elm = $( elm ),\n\t\t\tsettings = $elm.data();\n\n\t\tevent.preventDefault();\n\t\t$.magnificPopup.close();\n\t\tclearInterval( countdownInterval );\n\n\t\t// User wants their session maintained\n\t\tif ( settings.start !== undefined && ( getCurrentTime() - settings.start ) <= settings.reactionTime ) {\n\t\t\t$( selector )\n\t\t\t\t.trigger( resetEvent, settings )\n\t\t\t\t.trigger( keepaliveEvent, settings );\n\n\t\t// Negative confirmation or the user took too long; logout\n\t\t} else {\n\t\t\twindow.location.href = settings.logouturl;\n\t\t}\n\t},\n\n\t/**\n\t * Add the modal dialog\'s content and display it to the user\n\t * @function openModal\n\t * @param {Object} data Key-value object\n\t */\n\topenModal = function( data ) {\n\n\t\t// Detach the modal to prevent reflows while updating the element\n\t\t$modal = $modal.detach();\n\t\t$modal.find( ".modal-body" ).html( data.body );\n\t\t$modal.find( ".modal-footer" ).empty().append( data.buttons );\n\n\t\t// Re-attach the modal and open the dialog\n\t\t$modal = $modal.insertAfter( $modalLink );\n\t\t$modalLink.magnificPopup( "open" );\n\n\t\t// Execute the open callback if it exists\n\t\tif ( data.open ) {\n\t\t\tdata.open();\n\t\t}\n\t},\n\n\t/**\n\t * Returns the current time in milliseconds\n\t * @function getCurrentTime\n\t * @returns {integer} Current time in milliseconds\n\t */\n\tgetCurrentTime = function() {\n\t\treturn ( new Date() ).getTime();\n\t},\n\n\t/**\n\t * Parses a time value into a milliseconds integer value.\n\t * @function parseTime\n\t * @param {Mixed} value The time value to parse (integer or string)\n\t * @returns {integer} Millisecond integer value parsed from the time value\n\t */\n\tparseTime = function( value ) {\n\t\tvar result, num, mult,\n\t\t\tpowers = {\n\t\t\t\tms: 1,\n\t\t\t\tcs: 10,\n\t\t\t\tds: 100,\n\t\t\t\ts: 1000,\n\t\t\t\tdas: 10000,\n\t\t\t\ths: 100000,\n\t\t\t\tks: 1000000\n\t\t\t};\n\n\t\tif ( value == null ) { //eslint-disable-line no-eq-null\n\t\t\treturn null;\n\t\t}\n\n\t\tresult = /^([0-9]+(?:\\.[0-9]*)?)\\s*(.*s)?$/.exec( $.trim( value.toString() ) );\n\t\tif ( result[ 2 ] ) {\n\t\t\tnum = parseFloat( result[ 1 ] );\n\t\t\tmult = powers[ result[ 2 ] ] || 1;\n\t\t\treturn num * mult;\n\t\t}\n\t\treturn value;\n\t},\n\n\t/**\n\t * Converts a millisecond value into minutes and seconds\n\t * @function getTime\n\t * @param {integer} milliseconds The time value in milliseconds\n\t * @returns {Object} An object with a seconds and minutes property\n\t */\n\tgetTime = function( milliseconds ) {\n\t\tvar time = { minutes: "", seconds: "" };\n\n\t\tif ( milliseconds != null ) { //eslint-disable-line no-eq-null\n\t\t\ttime.minutes = parseInt( ( milliseconds / ( 1000 * 60 ) ) % 60, 10 );\n\t\t\ttime.seconds = parseInt( ( milliseconds / 1000 ) % 60, 10 );\n\t\t}\n\t\treturn time;\n\t},\n\n\t/**\n\t * Given 2 elements representing minutes and seconds, decrement their time value by 1 second\n\t * @function countdown\n\t * @param {jQuery DOM Element} $minutes Element that contains the minute value\n\t * @param {jQuery DOM Element} $seconds Element that contains the second value\n\t * @returns {boolean} Is the countdown finished?\n\t */\n\tcountdown = function( $minutes, $seconds ) {\n\t\tvar minutes = parseInt( $minutes.text(), 10 ),\n\t\t\tseconds = parseInt( $seconds.text(), 10 );\n\n\t\t// Decrement seconds and minutes\n\t\tif ( seconds > 0 ) {\n\t\t\tseconds -= 1;\n\t\t} else if ( minutes > 0 ) {\n\t\t\tminutes -= 1;\n\t\t\tseconds = 59;\n\t\t}\n\n\t\t// Update the DOM elements\n\t\t$minutes.text( minutes );\n\t\t$seconds.text( seconds );\n\n\t\treturn minutes === 0 && seconds === 0;\n\t};\n\n// Bind the plugin events\n$document.on( "timerpoke.wb " + initEvent + " " + keepaliveEvent + " " +\ninactivityEvent + " " + resetEvent, selector, function( event, settings ) {\n\n\tvar eventType = event.type;\n\n\tswitch ( eventType ) {\n\tcase "timerpoke":\n\tcase "wb-init":\n\t\tinit( event );\n\t\tbreak;\n\n\tcase "keepalive":\n\t\tkeepalive( event, settings );\n\t\tbreak;\n\n\tcase "inactivity":\n\t\tinactivity( event, settings );\n\t\tbreak;\n\n\tcase "reset":\n\t\treset( event, settings );\n\t\tbreak;\n\t}\n} );\n\n$document.on( "click", "." + confirmClass, confirm );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, document, wb );\n\n/**\n * @title WET-BOEW Share widget\n * @overview Facilitates sharing Web content on social media platforms.\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @pjackson28\n */\n( function( $, window, document, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-share",\n\tselector = "." + componentName,\n\tinitEvent = "wb-init" + selector,\n\tshareLink = "shr-lnk",\n\tpanelCount = 0,\n\t$document = wb.doc,\n\ti18n, i18nText,\n\n\t/*\n\t * Plugin users can override these defaults by setting attributes on the html elements that the\n\t * selector matches.\n\t */\n\tdefaults = {\n\t\thdLvl: "h2",\n\n\t\t// Supported types are: "page", "video" and "audio"\n\t\ttype: "page",\n\n\t\t// For custom types\n\t\t// custType = " this comment" results in "Share this comment"\n\t\tcustType: "",\n\n\t\turl: wb.pageUrlParts.href,\n\t\ttitle: document.title || $document.find( "h1:first" ).text(),\n\n\t\tpnlId: "",\n\t\tlnkClass: "",\n\t\timg: "",\n\t\tdesc: "",\n\n\t\t// For filtering the sites that area displayed and controlling the order\n\t\t// they are displayed. Empty array displays all sites in the default order.\n\t\t// Otherwise, it displays the sites in the order in the array using the\n\t\t// keys used by the sites object.\n\t\tfilter: [],\n\n\t\tsites: {\n\n\t\t\t// The definitions of the available bookmarking sites, in URL use\n\t\t\t// \'{u}\' for the page URL, \'{t}\' for the page title, {i} for the image, and \'{d}\' for the description\n\t\t\tbitly: {\n\t\t\t\tname: "bitly",\n\t\t\t\turl: "https://bitly.com/a/bitmarklet?u={u}"\n\t\t\t},\n\t\t\tblogger: {\n\t\t\t\tname: "Blogger",\n\t\t\t\turl: "http://www.blogger.com/blog_this.pyra?t=&amp;u={u}&amp;n={t}"\n\t\t\t},\n\t\t\tdelicious: {\n\t\t\t\tname: "Delicious",\n\t\t\t\turl: "http://delicious.com/post?url={u}&amp;title={t}"\n\t\t\t},\n\t\t\tdigg: {\n\t\t\t\tname: "Digg",\n\t\t\t\turl: "http://digg.com/submit?phase=2&amp;url={u}&amp;title={t}"\n\t\t\t},\n\t\t\tdiigo: {\n\t\t\t\tname: "Diigo",\n\t\t\t\turl: "http://www.diigo.com/post?url={u}&amp;title={t}"\n\t\t\t},\n\t\t\tfacebook: {\n\t\t\t\tname: "Facebook",\n\t\t\t\turl: "http://www.facebook.com/sharer.php?u={u}&amp;t={t}"\n\t\t\t},\n\t\t\tgmail: {\n\t\t\t\tname: "Gmail",\n\t\t\t\turl: "https://mail.google.com/mail/?view=cm&fs=1&tf=1&to=&su={t}&body={u}%0A{d}"\n\t\t\t},\n\t\t\tgoogleplus: {\n\t\t\t\tname: "Google+",\n\t\t\t\turl: "https://plus.google.com/share?url={u}&amp;hl=" + document.documentElement.lang\n\t\t\t},\n\t\t\tlinkedin: {\n\t\t\t\tname: "LinkedIn®",\n\t\t\t\turl: "http://www.linkedin.com/shareArticle?mini=true&amp;url={u}&amp;title={t}&amp;ro=false&amp;summary={d}&amp;source="\n\t\t\t},\n\t\t\tmyspace: {\n\t\t\t\tname: "MySpace",\n\t\t\t\turl: "http://www.myspace.com/Modules/PostTo/Pages/?u={u}&amp;t={t}"\n\t\t\t},\n\t\t\tpinterest: {\n\t\t\t\tname: "Pinterest",\n\t\t\t\turl: "http://www.pinterest.com/pin/create/button/?url={u}&amp;media={i}&amp;description={t}"\n\t\t\t},\n\t\t\treddit: {\n\t\t\t\tname: "reddit",\n\t\t\t\turl: "http://reddit.com/submit?url={u}&amp;title={t}"\n\t\t\t},\n\t\t\tstumbleupon: {\n\t\t\t\tname: "StumbleUpon",\n\t\t\t\turl: "http://www.stumbleupon.com/submit?url={u}&amp;title={t}"\n\t\t\t},\n\t\t\ttumblr: {\n\t\t\t\tname: "tumblr",\n\t\t\t\turl: "http://www.tumblr.com/share/link?url={u}&amp;name={t}&amp;description={d}"\n\t\t\t},\n\t\t\ttwitter: {\n\t\t\t\tname: "Twitter",\n\t\t\t\turl: "http://twitter.com/home?status={t}%20{u}"\n\t\t\t},\n\t\t\tyahoomail: {\n\t\t\t\tname: "Yahoo! Mail",\n\t\t\t\turl: "http://compose.mail.yahoo.com/?to=&subject={t}&body={u}%0A{d}"\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\tsites, heading, settings, panel, link, $share, $elm,\n\t\t\tpageHref, pageTitle, pageImage, pageDescription,\n\t\t\tsiteProperties, url, shareText, id, pnlId, regex,\n\t\t\tfilter, i, len, keys, key;\n\n\t\tif ( elm ) {\n\n\t\t\t// Only initialize the i18nText once\n\t\t\tif ( !i18nText ) {\n\t\t\t\ti18n = wb.i18n;\n\t\t\t\ti18nText = {\n\t\t\t\t\tshareText: i18n( "shr-txt" ),\n\t\t\t\t\tpage: i18n( "shr-pg" ),\n\t\t\t\t\tvideo: i18n( "shr-vid" ),\n\t\t\t\t\taudio: i18n( "shr-aud" ),\n\t\t\t\t\tdisclaimer: i18n( "shr-disc" ),\n\t\t\t\t\temail: i18n( "email" )\n\t\t\t\t};\n\n\t\t\t\t// Add an email mailto option\n\t\t\t\tdefaults.sites.email = {\n\t\t\t\t\tname: i18nText.email,\n\t\t\t\t\turl: "mailto:?to=&subject={t}&body={u}%0A{d}",\n\t\t\t\t\tisMailto: true\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t$elm = $( elm );\n\t\t\tsettings = $.extend(\n\t\t\t\ttrue,\n\t\t\t\t{},\n\t\t\t\tdefaults,\n\t\t\t\twindow[ componentName ],\n\t\t\t\twb.getData( $elm, componentName )\n\t\t\t);\n\t\t\tsites = settings.sites;\n\t\t\tfilter = settings.filter;\n\t\t\theading = settings.hdLvl;\n\n\t\t\tshareText = i18nText.shareText + ( settings.custType.length !== 0 ? settings.custType : i18nText[ settings.type ] );\n\t\t\tpnlId = settings.pnlId;\n\t\t\tid = "shr-pg" + ( pnlId.length !== 0 ? "-" + pnlId : panelCount );\n\t\t\tpageHref = encodeURIComponent( settings.url );\n\n\t\t\tregex = /\\\'|&#39;|&apos;/g;\n\t\t\tpageTitle = encodeURIComponent( settings.title )\n\t\t\t\t\t\t\t.replace( regex, "%27" );\n\t\t\tpageImage = encodeURIComponent( settings.img );\n\t\t\tpageDescription = encodeURIComponent( settings.desc )\n\t\t\t\t\t\t\t\t.replace( regex, "%27" );\n\n\t\t\t// Don\'t create the panel for the second link (class="link-only")\n\t\t\tif ( elm.className.indexOf( "link-only" ) === -1 ) {\n\t\t\t\tpanel = "<section id=\'" + id  + "\' class=\'shr-pg mfp-hide modal-dialog modal-content overlay-def" +\n\t\t\t\t\t"\'><header class=\'modal-header\'><" + heading + " class=\'modal-title\'>" +\n\t\t\t\t\tshareText + "</" + heading + "></header><div class=\'modal-body\'>" +\n\t\t\t\t\t"<ul class=\'list-unstyled colcount-xs-2\'>";\n\n\t\t\t\t// If there is no filter array of site keys, then generate an array of site keys\n\t\t\t\tif ( !filter || filter.length === 0 ) {\n\t\t\t\t\tkeys = [];\n\t\t\t\t\tfor ( key in sites ) {\n\t\t\t\t\t\tif ( sites.hasOwnProperty( key ) ) {\n\t\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tkeys = filter;\n\t\t\t\t}\n\n\t\t\t\t// i18n-friendly sort of the site keys\n\t\t\t\tkeys.sort( function( x, y ) {\n\t\t\t\t\treturn wb.normalizeDiacritics( x ).localeCompare( wb.normalizeDiacritics( y ) );\n\t\t\t\t} );\n\t\t\t\tlen = keys.length;\n\n\t\t\t\t// Generate the panel\n\t\t\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\t\t\tkey = keys[ i ];\n\t\t\t\t\tsiteProperties = sites[ key ];\n\t\t\t\t\turl = siteProperties.url\n\t\t\t\t\t\t\t.replace( /\\{u\\}/, pageHref )\n\t\t\t\t\t\t\t.replace( /\\{t\\}/, pageTitle )\n\t\t\t\t\t\t\t.replace( /\\{i\\}/, pageImage )\n\t\t\t\t\t\t\t.replace( /\\{d\\}/, pageDescription );\n\t\t\t\t\tpanel += "<li><a href=\'" + url + "\' class=\'" + shareLink +\n\t\t\t\t\t\t" " + ( siteProperties.isMailto ? "email" : key ) +\n\t\t\t\t\t\t" btn btn-default\' target=\'_blank\'>" +\n\t\t\t\t\t\tsiteProperties.name + "</a></li>";\n\t\t\t\t}\n\n\t\t\t\tpanel += "</ul><p class=\'col-sm-12 shr-dscl\'>" + i18nText.disclaimer +\n\t\t\t\t\t"</p><div class=\'clearfix\'></div></div></section>";\n\t\t\t\tpanelCount += 1;\n\t\t\t}\n\t\t\tlink = "<a href=\'#" + id + "\' aria-controls=\'" + id +\n\t\t\t\t"\' class=\'shr-opn wb-lbx " + settings.lnkClass +\n\t\t\t\t"\'><span class=\'glyphicon glyphicon-share\'></span>" +\n\t\t\t\tshareText + "</a>";\n\n\t\t\t$share = $( ( panel ? panel : "" ) + link );\n\n\t\t\t$elm.append( $share );\n\n\t\t\t$share\n\t\t\t\t.trigger( "wb-init.wb-lbx" );\n\n\t\t\t// Identify that initialization has completed\n\t\t\twb.ready( $elm, componentName );\n\t\t}\n\t};\n\n// Bind the init event of the plugin\n$document.on( "timerpoke.wb " + initEvent, selector, init );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, document, wb );\n\n/**\n * @title WET-BOEW Tables\n * @overview Integrates the DataTables plugin into WET providing searching, sorting, filtering, pagination and other advanced features for tables.\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @jeresiv\n */\n/*jshint scripturl:true*/\n( function( $, window, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-tables",\n\tselector = "." + componentName,\n\tinitEvent = "wb-init" + selector,\n\t$document = wb.doc,\n\tidCount = 0,\n\ti18n, i18nText, defaults,\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\telmId;\n\n\t\tif ( elm ) {\n\t\t\telmId = elm.id;\n\n\t\t\t// Ensure there is a unique id on the element\n\t\t\tif ( !elmId ) {\n\t\t\t\telmId = componentName + "-id-" + idCount;\n\t\t\t\tidCount += 1;\n\t\t\t\telm.id = elmId;\n\t\t\t}\n\n\t\t\t// Only initialize the i18nText once\n\t\t\tif ( !i18nText ) {\n\t\t\t\ti18n = wb.i18n;\n\t\t\t\ti18nText = {\n\t\t\t\t\taria: {\n\t\t\t\t\t\tsortAscending: i18n( "sortAsc" ),\n\t\t\t\t\t\tsortDescending: i18n( "sortDesc" )\n\t\t\t\t\t},\n\t\t\t\t\temptyTable: i18n( "emptyTbl" ),\n\t\t\t\t\tinfo: i18n( "infoEntr" ),\n\t\t\t\t\tinfoEmpty: i18n( "infoEmpty" ),\n\t\t\t\t\tinfoFiltered: i18n( "infoFilt" ),\n\t\t\t\t\tlengthMenu: i18n( "lenMenu" ),\n\t\t\t\t\tloadingRecords: i18n( "load" ),\n\t\t\t\t\tpaginate: {\n\t\t\t\t\t\tfirst: i18n( "first" ),\n\t\t\t\t\t\tlast: i18n( "last" ),\n\t\t\t\t\t\tnext: i18n( "nxt" ),\n\t\t\t\t\t\tprevious: i18n( "prv" ),\n\t\t\t\t\t\tpage: i18n( "page" )\n\t\t\t\t\t},\n\t\t\t\t\tprocessing: i18n( "process" ),\n\t\t\t\t\tsearch: i18n( "filter" ),\n\t\t\t\t\tthousands: i18n( "info1000" ),\n\t\t\t\t\tzeroRecords: i18n( "infoEmpty" )\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tdefaults = {\n\t\t\t\tasStripeClasses: [],\n\t\t\t\tlanguage: i18nText,\n\t\t\t\tdom: "<\'top\'fil>rt<\'bottom\'p><\'clear\'>"\n\t\t\t};\n\n\t\t\tModernizr.load( {\n\t\t\t\tload: [ "site!deps/jquery.dataTables" + wb.getMode() + ".js" ],\n\t\t\t\ttestReady: function() {\n\t\t\t\t\treturn ( $.fn.dataTable && $.fn.dataTable.version );\n\t\t\t\t},\n\t\t\t\tcomplete: function() {\n\t\t\t\t\tvar $elm = $( "#" + elmId ),\n\t\t\t\t\t\tdataTableExt = $.fn.dataTableExt;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Extend sorting support\n\t\t\t\t\t */\n\t\t\t\t\t$.extend( dataTableExt.type.order, {\n\n\t\t\t\t\t\t// Enable internationalization support in the sorting\n\t\t\t\t\t\t"html-pre": function( a ) {\n\t\t\t\t\t\t\treturn wb.normalizeDiacritics(\n\t\t\t\t\t\t\t\t!a ? "" : a.replace ?\n\t\t\t\t\t\t\t\t\ta.replace( /<.*?>/g, "" ).toLowerCase() : a + ""\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t},\n\t\t\t\t\t\t"string-case-pre": function( a ) {\n\t\t\t\t\t\t\treturn wb.normalizeDiacritics( a );\n\t\t\t\t\t\t},\n\t\t\t\t\t\t"string-pre": function( a ) {\n\t\t\t\t\t\t\treturn wb.normalizeDiacritics( a );\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Formatted number sorting\n\t\t\t\t\t\t"formatted-num-asc": function( a, b ) {\n\t\t\t\t\t\t\treturn wb.formattedNumCompare( a, b );\n\t\t\t\t\t\t},\n\t\t\t\t\t\t"formatted-num-desc": function( a, b ) {\n\t\t\t\t\t\t\treturn wb.formattedNumCompare( b, a );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\n\t\t\t\t\t// Add the container or the sorting icons\n\t\t\t\t\t$elm.find( "th" ).append( "<span class=\'sorting-cnt\'><span class=\'sorting-icons\'></span></span>" );\n\n\t\t\t\t\t// Create the DataTable object\n\t\t\t\t\t$elm.dataTable( $.extend( true, {}, defaults, window[ componentName ], wb.getData( $elm, componentName ) ) );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t};\n\n// Bind the init event of the plugin\n$document.on( "timerpoke.wb " + initEvent, selector, init );\n\n// Handle the draw.dt event\n$document.on( "init.dt draw.dt", selector, function( event, settings ) {\n\tvar $elm = $( event.target ),\n\t\tpagination = $elm.next( ".bottom" ).find( "div:first-child" ),\n\t\tpaginate_buttons = $elm.next( ".bottom" ).find( ".paginate_button" ),\n\t\tol = document.createElement( "OL" ),\n\t\tli = document.createElement( "LI" );\n\n\t// Determine if Pagination required\n\tif ( paginate_buttons.length === 1 || ( pagination.find( ".previous, .next" ).length === 2 && paginate_buttons.length < 4 ) ) {\n\t\tpagination.addClass( "hidden" );\n\t} else {\n\n\t\t// Make sure Pagination is visible\n\t\tpagination.removeClass( "hidden" );\n\n\t\t// Update Pagination List\n\t\tfor ( var i = 0; i < paginate_buttons.length; i++ ) {\n\t\t\tvar item = li.cloneNode( true );\n\t\t\titem.appendChild( paginate_buttons[ i ] );\n\t\t\tol.appendChild( item );\n\t\t}\n\n\t\tol.className = "pagination mrgn-tp-0 mrgn-bttm-0";\n\t\tpagination.empty();\n\t\tpagination.append( ol );\n\n\t\t// Update the aria-pressed properties on the pagination buttons\n\t\t// Should be pushed upstream to DataTables\n\t\t$elm.next( ".bottom" ).find( ".paginate_button" )\n\t\t\t.attr( {\n\t\t\t\t"role": "button",\n\t\t\t\t"href": "javascript:;"\n\t\t\t} )\n\t\t\t.not( ".previous, .next" )\n\t\t\t\t.attr( "aria-pressed", "false" )\n\t\t\t\t.html( function( index, oldHtml ) {\n\t\t\t\t\treturn "<span class=\'wb-inv\'>" + i18nText.paginate.page + " </span>" + oldHtml;\n\t\t\t\t} )\n\t\t\t\t.filter( ".current" )\n\t\t\t\t\t.attr( "aria-pressed", "true" );\n\t}\n\n\tif ( event.type === "init" ) {\n\n\t\t// Identify that initialization has completed\n\t\twb.ready( $elm, componentName );\n\t}\n\n\t// Identify that the table has been updated\n\t$elm.trigger( "wb-updated" + selector, [ settings ] );\n} );\n\n// Handle the draw.dt event\n$document.on( "submit", ".wb-tables-filter", function( event ) {\n\n\tevent.preventDefault();\n\n\tvar $form = $( this ),\n\t\t$datatable = $( "#" + $form.data( "bind-to" ) ).dataTable( { "retrieve": true } ).api();\n\n\t// Lets reset the search;\n\t$datatable.search( "" ).columns().search( "" );\n\n\t// Lets loop throug all options\n\tvar $value = "", $lastColumn = -1;\n\t$form.find( "[name]" ).each( function() {\n\t\tvar $elm = $( this ),\n\t\t\t$column = parseInt( $elm.attr( "data-column" ), 10 );\n\n\t\tif ( $elm.is( "select" ) ) {\n\t\t\t$value = $elm.find( "option:selected" ).val();\n\t\t} else if ( $elm.is( ":checkbox" ) ) {\n\t\t\tif ( $column !== $lastColumn && $lastColumn !== -1 ) {\n\t\t\t\t$value = "";\n\t\t\t}\n\t\t\t$lastColumn = $column;\n\n\t\t\tif ( $elm.is( ":checked" ) ) {\n\t\t\t\t$value += ( $value.length > 0 ) ? "|" : "";\n\t\t\t\t$value += $elm.val();\n\t\t\t}\n\t\t} else {\n\t\t\t$value = $elm.val();\n\t\t}\n\n\t\tif ( $value ) {\n\t\t\t$value = $value.replace( /\\s/g, "\\\\s*" );\n\t\t\t$datatable.column( $column ).search( "(" + $value + ")", true ).draw();\n\t\t}\n\t} );\n\n\treturn false;\n} );\n\n$document.on( "click", ".wb-tables-filter [type=\'reset\']", function( event ) {\n\tevent.preventDefault();\n\n\tvar $form = $( this ).closest( ".wb-tables-filter" ),\n\t\t$datatable = $( "#" + $form.data( "bind-to" ) ).dataTable( { "retrieve": true } ).api();\n\n\t$datatable.search( "" ).columns().search( "" ).draw();\n\n\t$form.find( "select" ).prop( "selectedIndex", 0 );\n\t$form.find( "input:checkbox" ).prop( "checked", false );\n\t$form.find( "input[type=date]" ).val( "" );\n\n\treturn false;\n} );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, wb );\n\n/**\n * @title WET-BOEW Tabbed interface\n * @overview Dynamically stacks multiple sections of content, transforming them into a tabbed interface.\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author WET Community\n */\n( function( $, window, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-tabs",\n\tselector = "." + componentName,\n\tinitEvent = "wb-init" + selector,\n\tshiftEvent = "wb-shift" + selector,\n\tselectEvent = "wb-select" + selector,\n\tupdatedEvent = "wb-updated" + selector,\n\tsetFocusEvent = "setfocus.wb",\n\tcontrols = selector + " ul[role=tablist] a, " + selector + " ul[role=tablist] .tab-count",\n\tinitialized = false,\n\ttabsAccordionClass = "tabs-acc",\n\tnestedTglPanelSelector = "> .tabpanels > details > .tgl-panel",\n\tactivePanel = "-activePanel",\n\tactivateEvent = "click keydown",\n\tpagePath = wb.pageUrlParts.pathname + "#",\n\t$document = wb.doc,\n\ti18n, i18nText,\n\n\t// Includes "smallview", "xsmallview" and "xxsmallview"\n\tsmallViewPattern = "smallview",\n\tisSmallView, oldIsSmallView,\n\n\tdefaults = {\n\t\texcludePlay: false,\n\t\tinterval: 6,\n\t\tupdateHash: false,\n\t\tignoreSession: false\n\t},\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\tisCarousel = true,\n\t\t\topen = "open",\n\t\t\thashTargetLen = 0,\n\t\t\t$panels, $tablist, activeId, $openPanel, $elm, elmId, $hashTarget,\n\t\t\tsettings, $panel, i, len, tablist, isOpen, hashFocus,\n\t\t\tnewId, positionY, groupClass, $tabPanels, openByHash;\n\n\t\tif ( elm ) {\n\t\t\t$elm = $( elm );\n\n\t\t\t// For backwards compatibility. Should be removed in WET v4.1\n\t\t\tif ( $elm.children( ".tabpanels" ).length === 0 ) {\n\t\t\t\t$elm.children( "[role=tabpanel], details" ).wrapAll( "<div class=\'tabpanels\'/>" );\n\t\t\t}\n\n\t\t\t$panels = $elm.find( "> .tabpanels > [role=tabpanel], > .tabpanels > details" );\n\t\t\t$tablist = $elm.children( "[role=tablist]" );\n\t\t\tisCarousel = $tablist.length !== 0;\n\n\t\t\t// If a carousel contains only 1 panel, remove its controls, visually-hide its thumbnails and prevent it from attempting to play\n\t\t\tif ( isCarousel && $panels.length === 1 ) {\n\n\t\t\t\t$elm.removeClass( "show-thumbs playing" );\n\t\t\t\t$elm.addClass( "exclude-controls" );\n\t\t\t}\n\n\t\t\tactiveId = wb.jqEscape( wb.pageUrlParts.hash.substring( 1 ) );\n\t\t\thashFocus = activeId.length !== 0;\n\t\t\t$openPanel = hashFocus ? $panels.filter( "#" + activeId ) : undefined;\n\t\t\topenByHash = $openPanel && $openPanel.length !== 0;\n\t\t\telmId = elm.id;\n\n\t\t\tsettings = $.extend(\n\t\t\t\ttrue,\n\t\t\t\t{},\n\t\t\t\tdefaults,\n\t\t\t\t{\n\t\t\t\t\tinterval: $elm.hasClass( "slow" ) ?\n\t\t\t\t\t\t\t\t9 : $elm.hasClass( "fast" ) ?\n\t\t\t\t\t\t\t\t\t3 : defaults.interval,\n\t\t\t\t\texcludeControls: $elm.hasClass( "exclude-controls" ),\n\t\t\t\t\texcludePlay: $elm.hasClass( "exclude-play" ),\n\t\t\t\t\tupdateHash: $elm.hasClass( "update-hash" ),\n\t\t\t\t\tplaying: $elm.hasClass( "playing" ),\n\t\t\t\t\tignoreSession: $elm.hasClass( "ignore-session" )\n\t\t\t\t},\n\t\t\t\twindow[ componentName ],\n\t\t\t\twb.getData( $elm, componentName )\n\t\t\t);\n\n\t\t\ttry {\n\n\t\t\t\t// If the panel was not set by URL hash\n\t\t\t\tif ( !openByHash ) {\n\t\t\t\t\tif ( hashFocus ) {\n\t\t\t\t\t\t$hashTarget = $panels.find( "#" + activeId );\n\t\t\t\t\t\thashTargetLen = $hashTarget.length;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the anchor target is within a panel, then open that panel\n\t\t\t\t\tif ( hashTargetLen !== 0 ) {\n\t\t\t\t\t\tactiveId = $hashTarget.closest( "[role=tabpanel]" ).attr( "id" );\n\n\t\t\t\t\t// Attempt to retrieve active panel from sessionStorage\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( !settings.ignoreSession ) {\n\t\t\t\t\t\t\tactiveId = sessionStorage.getItem( pagePath + elmId + activePanel );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( activeId ) {\n\t\t\t\t\t\t$openPanel = $panels.filter( "#" + activeId );\n\t\t\t\t\t}\n\n\t\t\t\t// If the panel was set by URL hash, then store in sessionStorage\n\t\t\t\t} else {\n\t\t\t\t\tif ( !settings.ignoreSession ) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsessionStorage.setItem( pagePath + elmId + activePanel, activeId );\n\t\t\t\t\t\t} catch ( error ) {\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch ( error ) {\n\t\t\t}\n\n\t\t\t// Determine the current view\n\t\t\tisSmallView = document.documentElement.className.indexOf( smallViewPattern ) !== -1;\n\n\t\t\t// Only initialize the i18nText once\n\t\t\tif ( !i18nText ) {\n\t\t\t\ti18n = wb.i18n;\n\t\t\t\ti18nText = {\n\t\t\t\t\tprev: i18n( "prv" ),\n\t\t\t\t\tnext: i18n( "nxt" ),\n\t\t\t\t\tplay: i18n( "tab-play" ),\n\t\t\t\t\trotStart: i18n( "tab-rot" ).on,\n\t\t\t\t\trotStop: i18n( "tab-rot" ).off,\n\t\t\t\t\tspace: i18n( "space" ),\n\t\t\t\t\thyphen: i18n( "hyphen" ),\n\t\t\t\t\tpause: i18n( "pause" ),\n\t\t\t\t\ttabCount: i18n( "lb-curr" )\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Build the tablist and enhance the panels as needed for details/summary\n\t\t\tif ( !isCarousel ) {\n\t\t\t\t$elm.addClass( tabsAccordionClass );\n\t\t\t\tgroupClass = elmId + "-grp";\n\t\t\t\t$tabPanels = $elm.children( ".tabpanels" );\n\t\t\t\t$panels = $tabPanels.children( "details" );\n\t\t\t\tlen = $panels.length;\n\n\t\t\t\t$tabPanels.detach();\n\n\t\t\t\t// Ensure there is only one panel open\n\t\t\t\t// Order of priority is hash, open property, first details\n\t\t\t\tif ( !$openPanel || $openPanel.length === 0 ) {\n\t\t\t\t\t$openPanel = $panels.filter( "[open]" ).first();\n\t\t\t\t\tif ( $openPanel.length === 0 ) {\n\t\t\t\t\t\t$openPanel = $panels.eq( 0 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$panels.removeAttr( open );\n\t\t\t\t$openPanel.attr( open, open );\n\n\t\t\t\t// Hide the tablist in small view and the summary elements in large view\n\t\t\t\ttablist = "<ul role=\'tablist\' aria-live=\'off\' class=\'generated\'>";\n\n\t\t\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\t\t\t$panel = $panels.eq( i );\n\t\t\t\t\t$panel\n\t\t\t\t\t\t.addClass( groupClass )\n\t\t\t\t\t\t.html(\n\t\t\t\t\t\t\t$panel.html()\n\t\t\t\t\t\t\t\t.replace( /(<\\/summary>)/i, "$1<div class=\'tgl-panel\'>" ) +\n\t\t\t\t\t\t\t"</div>"\n\t\t\t\t\t\t);\n\n\t\t\t\t\tnewId = $panel.attr( "id" );\n\t\t\t\t\tif ( !newId ) {\n\t\t\t\t\t\tnewId = wb.getId();\n\t\t\t\t\t\t$panel.attr( "id", newId );\n\t\t\t\t\t}\n\t\t\t\t\tisOpen = !!$panel.attr( open );\n\n\t\t\t\t\tif ( isSmallView ) {\n\t\t\t\t\t\tif ( !Modernizr.details ) {\n\t\t\t\t\t\t\t$panel.toggleClass( "open", isOpen );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$panel.attr( {\n\t\t\t\t\t\t\trole: "tabpanel",\n\t\t\t\t\t\t\topen: open\n\t\t\t\t\t\t} );\n\t\t\t\t\t\t$panel.addClass( ( Modernizr.details ? "" :  open + " " ) +\n\t\t\t\t\t\t\t"fade " + ( isOpen ? "in" : "noheight out wb-inv" ) );\n\t\t\t\t\t}\n\n\t\t\t\t\ttablist += "<li" + ( isOpen ? " class=\'active\'" : "" ) +\n\t\t\t\t\t\t"><a id=\'" + newId + "-lnk\' href=\'#" + newId + "\'>" +\n\t\t\t\t\t\t$panel.children( "summary" ).html() + "</a></li>";\n\t\t\t\t}\n\n\t\t\t\t$tablist = $( tablist + "</ul>" );\n\t\t\t\t$tabPanels.find( "> details > summary" )\n\t\t\t\t\t.addClass( "wb-toggle tgl-tab" )\n\t\t\t\t\t.attr( "data-toggle", "{\\"parent\\": \\"#" + elmId +\n\t\t\t\t\t\t"\\", \\"group\\": \\"." + groupClass + "\\"}" );\n\n\t\t\t\t$elm\n\t\t\t\t\t.prepend( $tablist )\n\t\t\t\t\t.append( $tabPanels )\n\t\t\t\t\t.trigger( "wb-init.wb-toggle" );\n\t\t\t} else if ( $openPanel && $openPanel.length !== 0 ) {\n\t\t\t\t$panels.filter( ".in" )\n\t\t\t\t\t.addClass( "out noheight" )\n\t\t\t\t\t.removeClass( "in" );\n\t\t\t\t$openPanel\n\t\t\t\t\t.addClass( "in" )\n\t\t\t\t\t.removeClass( "out noheight" );\n\t\t\t\t$tablist.find( ".active" )\n\t\t\t\t\t.removeClass( "active" );\n\t\t\t\t$tablist.find( "a" )\n\t\t\t\t\t.filter( "[href$=\'" + activeId + "\']" )\n\t\t\t\t\t.parent()\n\t\t\t\t\t\t.addClass( "active" );\n\t\t\t}\n\n\t\t\tdrizzleAria( $panels, $tablist );\n\n\t\t\tif ( isCarousel ) {\n\n\t\t\t\t// Returns true if the tabs should be rotating automatically\n\t\t\t\tif ( createControls( $tablist, settings ) ) {\n\n\t\t\t\t\t// Register this specific tabs instance for timerpoke.wb events\n\t\t\t\t\twb.add( "#" + elmId + selector );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If focus is being set by the URL hash, then ensure the tabs are\n\t\t\t// not above the top of the viewport (if the panel was the target),\n\t\t\t// or the anchor is not above the top of viewport (if the anchor was\n\t\t\t// the target)\n\t\t\tif ( hashFocus ) {\n\n\t\t\t\t// Need a slight delay to allow for the reflow\n\t\t\t\tsetTimeout( function() {\n\t\t\t\t\tif ( openByHash ) {\n\t\t\t\t\t\tpositionY = $tablist.offset().top;\n\t\t\t\t\t} else if ( hashTargetLen !== 0 ) {\n\t\t\t\t\t\tpositionY = $hashTarget.offset().top;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpositionY = -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( positionY !== -1 && positionY < document.body.scrollTop ) {\n\t\t\t\t\t\tdocument.body.scrollTop = positionY;\n\t\t\t\t\t}\n\t\t\t\t}, 1 );\n\t\t\t}\n\n\t\t\t$elm.data( {\n\t\t\t\t"wb-tabs": {\n\t\t\t\t\tpanels: $panels,\n\t\t\t\t\ttablist: $tablist,\n\t\t\t\t\tsettings: settings,\n\t\t\t\t\tctime: 0\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tinitialized = true;\n\t\t\tonResize( $elm );\n\n\t\t\t// Update the URL hash if needed\n\t\t\tif ( settings.updateHash ) {\n\t\t\t\tupdateHash( $openPanel[ 0 ] );\n\t\t\t}\n\n\t\t\t// Identify that initialization has completed\n\t\t\twb.ready( $elm, componentName );\n\t\t}\n\t},\n\n\t/**\n\t * @method onTimerPoke\n\t * @param {jQuery DOM element} $elm The plugin element\n\t */\n\tonTimerPoke = function( $elm ) {\n\t\tvar data = $elm.data( componentName ),\n\t\t\tdelayCurrent = parseFloat( data.ctime ) + 0.5;\n\n\t\t// Check if we need to rotate panels\n\t\tif ( parseFloat( data.settings.interval ) <= delayCurrent ) {\n\t\t\t$elm.trigger( shiftEvent );\n\t\t\tdelayCurrent = 0;\n\t\t}\n\n\t\tdata.ctime = delayCurrent;\n\t\t$elm.data( componentName, data );\n\t},\n\n\t/**\n\t * @method createControls\n\t * @param {jQuery DOM element} $tablist The plugin element\n\t * @param {object} settings Settings for the tabs instance\n\t * @returns {boolean} Whether or not the tabs should be rotating initially\n\t */\n\tcreateControls = function( $tablist, settings ) {\n\t\tvar prevText = i18nText.prev,\n\t\t\tnextText = i18nText.next,\n\t\t\tspaceText = i18nText.space,\n\t\t\texcludeControls = settings.excludeControls,\n\t\t\texcludePlay = settings.excludePlay,\n\t\t\tisPlaying = !excludeControls && !excludePlay && settings.playing,\n\t\t\tstate = isPlaying ? i18nText.pause : i18nText.play,\n\t\t\thidden = isPlaying ? i18nText.rotStop : i18nText.rotStart,\n\t\t\tglyphiconStart = "<span class=\'glyphicon glyphicon-",\n\t\t\twbInvStart = "<span class=\'wb-inv\'>",\n\t\t\ttabsToggleStart = "<li class=\'control ",\n\t\t\tbtnMiddle = "\' href=\'javascript:;\' role=\'button\' title=\'",\n\t\t\tbtnEnd = "</span></a></li> ",\n\t\t\ticonState = glyphiconStart + ( isPlaying ? "pause" : "play" ) + "\'></span>",\n\t\t\t$tabs = $tablist.find( "[role=tab]" ),\n\t\t\tcurrentIndex = $tabs.index( $tabs.filter( "[aria-selected=true]" ) ) + 1,\n\t\t\ti18nTabCount = i18nText.tabCount,\n\t\t\tfirstReplaceIndex = i18nTabCount.indexOf( "%" ),\n\t\t\tlastReplaceIndex = i18nTabCount.lastIndexOf( "%" ) + 1,\n\t\t\tprevControl = tabsToggleStart + "prv\'><a class=\'prv" + btnMiddle +\n\t\t\t\tprevText + "\'>" + glyphiconStart + "chevron-left\'></span>" +\n\t\t\t\twbInvStart + prevText + btnEnd,\n\t\t\ttabCount = tabsToggleStart + " tab-count\' tabindex=\'0\'><div>" +\n\t\t\t\ti18nTabCount.substring( 0, firstReplaceIndex ) +\n\t\t\t\t"<div class=\'curr-count\'>" +\n\t\t\t\ti18nTabCount.substring( firstReplaceIndex, lastReplaceIndex )\n\t\t\t\t\t.replace( "%curr%", "<span class=\'curr-index\'>" + currentIndex + "</span>" )\n\t\t\t\t\t.replace( "%total%", $tabs.length ) +\n\t\t\t\t"</div>" + i18nTabCount.substring( lastReplaceIndex ) +\n\t\t\t\t"</div></li>",\n\t\t\tnextControl = tabsToggleStart + "nxt\'><a class=\'nxt" + btnMiddle +\n\t\t\t\tnextText + "\'>" + glyphiconStart + "chevron-right\'></span>" +\n\t\t\t\twbInvStart + nextText + btnEnd,\n\t\t\tplayControl =  tabsToggleStart + "plypause\'><a class=\'plypause" +\n\t\t\t\tbtnMiddle + state + "\'>" + iconState + " <span>" + state +\n\t\t\t\t"</span>" + wbInvStart + spaceText + i18nText.hyphen + spaceText +\n\t\t\t\thidden + btnEnd;\n\n\t\tif ( !excludeControls ) {\n\t\t\t$tablist.prepend( prevControl + tabCount + nextControl );\n\t\t}\n\n\t\tif ( !excludeControls && !excludePlay ) {\n\t\t\t$tablist.append( playControl );\n\t\t}\n\n\t\treturn isPlaying;\n\t},\n\n\t/**\n\t * @method drizzleAria\n\t * @param {jQuery DOM element} $panels Tabpanel groupings\n\t * @param {jQuery DOM element} $tablist Pointers to the groupings\n\t */\n\tdrizzleAria = function( $panels, $tabList ) {\n\n\t\t// Let\'s process the elements for aria\n\t\tvar panels = $panels.get(),\n\t\t\ttabCounter = panels.length - 1,\n\t\t\tlistItems = $tabList.children().get(),\n\t\t\tlistCounter = listItems.length - 1,\n\t\t\tisDetails = $panels[ 0 ].nodeName.toLowerCase() === "details",\n\t\t\tisActive, item, link, panelId, activeFound;\n\n\t\tfor ( ; tabCounter !== -1; tabCounter -= 1 ) {\n\t\t\titem = panels[ tabCounter ];\n\t\t\tisActive = item.className.indexOf( "out" ) === -1;\n\n\t\t\tif ( !isDetails || !isSmallView ) {\n\t\t\t\titem.setAttribute( "aria-hidden", isActive ? "false" : "true" );\n\t\t\t\titem.setAttribute( "aria-expanded", isActive ? "true" : "false" );\n\t\t\t}\n\t\t\titem.setAttribute( "aria-labelledby", item.id + "-lnk" );\n\t\t}\n\n\t\tactiveFound = false;\n\t\tfor ( ; listCounter !== -1; listCounter -= 1 ) {\n\t\t\titem = listItems[ listCounter ];\n\t\t\titem.setAttribute( "role", "presentation" );\n\n\t\t\tisActive = item.className.indexOf( "active" ) !== -1;\n\t\t\tif ( isActive ) {\n\t\t\t\tactiveFound = true;\n\t\t\t} else if ( listCounter === 0 && !activeFound ) {\n\t\t\t\tisActive = true;\n\t\t\t\titem.className += " active";\n\t\t\t}\n\n\t\t\tlink = item.getElementsByTagName( "a" )[ 0 ];\n\t\t\tpanelId = link.getAttribute( "href" ).substring( 1 );\n\n\t\t\tlink.tabIndex = isActive ? "0" : "-1";\n\t\t\tlink.setAttribute( "role", "tab" );\n\t\t\tlink.setAttribute( "aria-selected", isActive ? "true" : "false" );\n\t\t\tlink.setAttribute( "aria-controls", panelId );\n\t\t\tlink.id = panelId + "-lnk";\n\t\t}\n\t\t$tabList.attr( "aria-live", "off" );\n\t},\n\n\t/**\n\t * @method updateHash\n\t * @param {DOM element} elm Tabpanel to be referenced in the URL hash\n\t */\n\tupdateHash = function( elm ) {\n\t\tvar elmId = elm.id;\n\n\t\twb.ignoreHashChange = true;\n\t\telm.id += "-off";\n\t\twindow.location.hash = elmId;\n\t\telm.id = elmId;\n\t\twb.ignoreHashChange = false;\n\t},\n\n\tupdateNodes = function( $panels, $controls, $next, $control ) {\n\t\tvar $tabs = $controls.find( "[role=tab]" ),\n\t\t\tnewIndex = $tabs.index( $control ) + 1,\n\t\t\t$currPanel = $panels.filter( ".in" ),\n\t\t\t$container = $next.closest( selector ),\n\t\t\ttabSettings = $container.data( componentName ).settings,\n\t\t\tmPlayers = $currPanel.find( ".wb-mltmd-inited" ).get(),\n\t\t\tmPlayersLen = mPlayers.length,\n\t\t\tmPlayer, i, j, last;\n\n\t\t// Handle the direction of the slide transitions\n\t\tif ( $currPanel[ 0 ].className.indexOf( "slide" ) !== -1 ) {\n\t\t\ti = $panels.index( $currPanel );\n\t\t\tj = $panels.index( $next );\n\t\t\tlast = $panels.length - 1;\n\n\t\t\t$panels.toggleClass(\n\t\t\t\t"reverse",\n\t\t\t\t( i > j && ( i !== last || j !== 0 ) ) || ( i === 0 && j === last )\n\t\t\t);\n\t\t}\n\n\t\t$currPanel\n\t\t\t.removeClass( "in" )\n\t\t\t.addClass( "out noheight" )\n\t\t\t.attr( {\n\t\t\t\t"aria-hidden": "true",\n\t\t\t\t"aria-expanded": "false"\n\t\t\t} );\n\n\t\t// Pause all multimedia players in the current panel\n\t\tfor ( i = 0; i !== mPlayersLen; i += 1 ) {\n\t\t\tmPlayer = mPlayers[ i ];\n\t\t\tif ( mPlayer.player ) {\n\t\t\t\tmPlayer.player( "pause" );\n\t\t\t}\n\t\t}\n\n\t\t$next\n\t\t\t.removeClass( "out noheight" )\n\t\t\t.addClass( "in" )\n\t\t\t.attr( {\n\t\t\t\t"aria-hidden": "false",\n\t\t\t\t"aria-expanded": "true"\n\t\t\t} );\n\n\t\t$controls\n\t\t\t.find( ".active" )\n\t\t\t\t.removeClass( "active" )\n\t\t\t\t.children( "a" )\n\t\t\t\t\t.attr( {\n\t\t\t\t\t\t"aria-selected": "false",\n\t\t\t\t\t\ttabindex: "-1"\n\t\t\t\t\t} );\n\n\t\t// Update the Item x of n\n\t\t$controls\n\t\t\t.find( ".curr-index" )\n\t\t\t\t.html( newIndex );\n\n\t\t$control\n\t\t\t.attr( {\n\t\t\t\t"aria-selected": "true",\n\t\t\t\ttabindex: "0"\n\t\t\t} )\n\t\t\t.parent()\n\t\t\t\t.addClass( "active" );\n\n\t\t// Update sessionStorage with the current active panel\n\t\tif ( !tabSettings.ignoreSession ) {\n\t\t\ttry {\n\t\t\t\tsessionStorage.setItem(\n\t\t\t\t\tpagePath + $container.attr( "id" ) + activePanel,\n\t\t\t\t\t$next.attr( "id" )\n\t\t\t\t);\n\t\t\t} catch ( error ) {\n\t\t\t}\n\t\t}\n\n\t\t// Update the URL hash if needed\n\t\tif ( tabSettings.updateHash ) {\n\t\t\tupdateHash( $next[ 0 ] );\n\t\t}\n\n\t\t// Identify that the tabbed interface/carousel was updated\n\t\t$container.trigger( updatedEvent, [ $next ] );\n\t},\n\n\t/**\n\t * @method onPick\n\t * @param {jQuery DOM element} $sldr The plugin element\n\t * @param {jQuery DOM element} $elm The selected link from the tablist\n\t */\n\tonPick = function( $sldr, $elm ) {\n\t\tvar data = $sldr.data( componentName ),\n\t\t\t$panels = data.panels,\n\t\t\t$controls = data.tablist,\n\t\t\t$next = $panels.filter( "#" + $elm.attr( "aria-controls" ) );\n\n\t\tupdateNodes( $panels, $controls, $next, $elm );\n\t},\n\n\t/**\n\t * @method onShift\n\t * @param (jQuery event} event Current event\n\t * @param {jQuery DOM element} $elm The plugin element\n\t */\n\tonShift = function( event, $elm ) {\n\t\tvar data = $elm.data( componentName ),\n\t\t\t$panels = data.panels,\n\t\t\tlen = $panels.length,\n\t\t\tcurrent = $elm.find( "> .tabpanels > .in" ).prevAll( "[role=tabpanel]" ).length,\n\t\t\tautoCycle = !event.shiftto,\n\t\t\tnext = current > len ? 0 : current + ( autoCycle ? 1 : event.shiftto );\n\n\t\tonSelect( $panels[ ( next > len - 1 ) ? 0 : ( next < 0 ) ? len - 1 : next ].id, autoCycle );\n\t},\n\n\t/**\n\t * @method onSelect\n\t * @param (string) id Id attribute of the panel\n\t * @param (boolean) autoCycle Whether change is caused by an auto cycle\n\t */\n\tonSelect = function( id, autoCycle ) {\n\t\tvar panelSelector = "#" + id,\n\t\t\t$panel = $( panelSelector ),\n\t\t\t$panelSelectorLink;\n\n\t\tif ( isSmallView && $panel[ 0 ].nodeName.toLowerCase() === "details" ) {\n\t\t\t$panel.children( "summary" ).trigger( $panel.attr( "open" ) ? setFocusEvent : "click" );\n\t\t} else {\n\t\t\t$panelSelectorLink = $( panelSelector + "-lnk" );\n\t\t\t$panelSelectorLink.trigger( {\n\t\t\t\ttype: "click",\n\t\t\t\twhich: autoCycle ? undefined : 1\n\t\t\t} );\n\n\t\t\t// Don\'t change the focus if change is cause by an auto cycle\n\t\t\tif ( !autoCycle ) {\n\t\t\t\t$panelSelectorLink.trigger( setFocusEvent );\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * @method onCycle\n\t * @param {jQuery DOM element} $elm The plugin element\n\t * @param {integer} shifto The item to shift to\n\t */\n\tonCycle = function( $elm, shifto ) {\n\t\t$elm.trigger( {\n\t\t\ttype: shiftEvent,\n\t\t\tshiftto: shifto\n\t\t} );\n\t},\n\n\t/**\n\t * @method onResize\n\t * @param {jQuery Object} $currentElm Element being initialized (only during initialization process).\n\t */\n\tonResize = function( $currentElm ) {\n\t\tvar $elms, $elm, $tabPanels, $details, $detailsElm, $tablist,\n\t\t\t$openDetails, openDetailsId, activeId, $summary, $panelElm,\n\t\t\ti, len, j, len2, viewChange, isInit, isActive;\n\n\t\tif ( initialized ) {\n\t\t\tisSmallView = document.documentElement.className.indexOf( smallViewPattern ) !== -1;\n\t\t\tviewChange = isSmallView !== oldIsSmallView;\n\t\t\tisInit = $currentElm.length ? true : false;\n\n\t\t\tif ( viewChange || isInit ) {\n\t\t\t\t$elms = isInit ? $currentElm : $( selector );\n\t\t\t\tlen = $elms.length;\n\n\t\t\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\t\t\t$elm = $elms.eq( i );\n\t\t\t\t\t$tabPanels = $elm.children( ".tabpanels" );\n\t\t\t\t\t$details = $tabPanels.children( "details" );\n\t\t\t\t\tlen2 = $details.length;\n\n\t\t\t\t\tif ( $details.length !== 0 ) {\n\t\t\t\t\t\t$tabPanels.detach();\n\t\t\t\t\t\t$summary = $details.children( "summary" );\n\t\t\t\t\t\t$tablist = $elm.children( "ul" );\n\n\t\t\t\t\t\tif ( isSmallView ) {\n\n\t\t\t\t\t\t\t// Switch to small view\n\t\t\t\t\t\t\tactiveId = $tablist.find( ".active a" ).attr( "href" ).substring( 1 );\n\t\t\t\t\t\t\tfor ( j = 0; j !== len2; j += 1 ) {\n\t\t\t\t\t\t\t\t$detailsElm = $details.eq( j );\n\t\t\t\t\t\t\t\t$panelElm = $detailsElm.children( ".tgl-panel" );\n\t\t\t\t\t\t\t\tisActive = $detailsElm.attr( "id" ) === activeId;\n\n\t\t\t\t\t\t\t\t$detailsElm\n\t\t\t\t\t\t\t\t\t.removeAttr( "role aria-expanded aria-hidden" )\n\t\t\t\t\t\t\t\t\t.removeClass( "fade out noheight in" )\n\t\t\t\t\t\t\t\t\t.toggleClass( "open", isActive );\n\n\t\t\t\t\t\t\t\t$panelElm\n\t\t\t\t\t\t\t\t\t.attr( "role", "tabpanel" )\n\t\t\t\t\t\t\t\t\t.removeAttr( "aria-expanded" )\n\t\t\t\t\t\t\t\t\t.removeAttr( "aria-hidden" );\n\n\t\t\t\t\t\t\t\tif ( isActive ) {\n\t\t\t\t\t\t\t\t\t$detailsElm.attr( "open", "open" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t$detailsElm.removeAttr( "open" );\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( !isInit ) {\n\t\t\t\t\t\t\t\t\t$detailsElm\n\t\t\t\t\t\t\t\t\t\t.children( "summary" )\n\t\t\t\t\t\t\t\t\t\t\t.attr( {\n\t\t\t\t\t\t\t\t\t\t\t\t"aria-expanded": isActive,\n\t\t\t\t\t\t\t\t\t\t\t\t"aria-selected": isActive\n\t\t\t\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if ( oldIsSmallView ) {\n\n\t\t\t\t\t\t\t// Switch to large view\n\t\t\t\t\t\t\t$openDetails = $details.filter( "[open]" );\n\t\t\t\t\t\t\topenDetailsId = $openDetails.attr( "id" );\n\n\t\t\t\t\t\t\t$openDetails = ( $openDetails.length === 0 ? $details : $openDetails ).eq( 0 );\n\n\t\t\t\t\t\t\t$details\n\t\t\t\t\t\t\t\t.attr( {\n\t\t\t\t\t\t\t\t\trole: "tabpanel",\n\t\t\t\t\t\t\t\t\topen: "open"\n\t\t\t\t\t\t\t\t} )\n\t\t\t\t\t\t\t\t.not( $openDetails )\n\t\t\t\t\t\t\t\t\t.addClass( "fade out noheight wb-inv" )\n\t\t\t\t\t\t\t\t\t.attr( {\n\t\t\t\t\t\t\t\t\t\t"aria-hidden": "true",\n\t\t\t\t\t\t\t\t\t\t"aria-expanded": "false"\n\t\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t$details.children( ".tgl-panel" ).removeAttr( "role" );\n\n\t\t\t\t\t\t\t$openDetails\n\t\t\t\t\t\t\t\t.addClass( "fade in" )\n\t\t\t\t\t\t\t\t.attr( {\n\t\t\t\t\t\t\t\t\t"aria-hidden": "false",\n\t\t\t\t\t\t\t\t\t"aria-expanded": "true"\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$summary.attr( "aria-hidden", !isSmallView );\n\t\t\t\t\t\t$tablist.attr( "aria-hidden", isSmallView );\n\n\t\t\t\t\t\t$elm.append( $tabPanels );\n\n\t\t\t\t\t\t// Update the tablist role\n\t\t\t\t\t\tif ( isSmallView && !isInit ) {\n\t\t\t\t\t\t\t$elm.attr( "role", "tablist" );\n\t\t\t\t\t\t} else if ( oldIsSmallView ) {\n\t\t\t\t\t\t\t$elm\n\t\t\t\t\t\t\t\t.removeAttr( "role" )\n\t\t\t\t\t\t\t\t.find( nestedTglPanelSelector ).removeAttr( "role" );\n\n\t\t\t\t\t\t\t$elm.find( "> ul [href$=\'" + openDetailsId + "\']" ).trigger( "click" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Need timeout to account for Toggle changes\n\t\t\t\tif ( isInit && !isSmallView && $elms.hasClass( tabsAccordionClass ) ) {\n\t\t\t\t\tsetTimeout( function() {\n\t\t\t\t\t\t$elms\n\t\t\t\t\t\t\t.removeAttr( "role" )\n\t\t\t\t\t\t\t.find( nestedTglPanelSelector ).removeAttr( "role" );\n\t\t\t\t\t}, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toldIsSmallView = isSmallView;\n\t\t}\n\n\t\tif ( viewChange || isInit ) {\n\n\t\t\t// Remove wb-inv from regular tabs that were used to prevent FOUC (after 300ms delay)\n\t\t\tsetTimeout( function() {\n\t\t\t\t$( selector + " .tabpanels > details.wb-inv" ).removeClass( "wb-inv" );\n\t\t\t}, 300 );\n\t\t}\n\t};\n\n// Bind the init event of the plugin\n$document.on( "timerpoke.wb " + initEvent + " " + shiftEvent + " " + selectEvent, selector, function( event ) {\n\tvar eventTarget = event.target,\n\t\teventCurrentTarget = event.currentTarget,\n\t\t$elm;\n\n\t// Filter out any events triggered by descendants\n\tif ( eventCurrentTarget === eventTarget ) {\n\t\tswitch ( event.type ) {\n\t\tcase "timerpoke":\n\t\t\t$elm = $( eventTarget );\n\t\t\tif ( !$elm.hasClass( componentName + "-inited" ) ) {\n\t\t\t\tinit( event );\n\t\t\t} else if ( $elm.hasClass( "playing" ) ) {\n\t\t\t\tonTimerPoke( $elm );\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Init\n\t\t */\n\t\tcase "wb-init":\n\t\t\tinit( event );\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Change tab panels by a delta\n\t\t */\n\t\tcase "wb-shift":\n\t\t\tonShift( event, $( eventTarget ) );\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Select a specific tab panel\n\t\t */\n\t\tcase "wb-select":\n\t\t\tonSelect( event.id );\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Since we are working with events we want to ensure that we are being passive about our control,\n\t * so returning true allows for events to always continue\n\t */\n\treturn true;\n} );\n\n/*\n * Tabs, next, previous and play/pause\n */\n$document.on( activateEvent, controls, function( event ) {\n\tvar which = event.which,\n\t\telm = event.currentTarget,\n\t\tclassName = elm.className,\n\t\tspaceText = i18nText.space,\n\t\t$elm, $sldr, sldrId, plypause, buttonText, data, isPlaying, isPlayPause;\n\n\t// No control, alt or meta keys and only left mouse button, enter key,\n\t// space bar, escape key and arrow keys\n\tif ( !( event.ctrlKey || event.altKey || event.metaKey ) &&\n\t\t\t( !which || which === 1 || which === 13 || which === 27 ||\n\t\t\twhich === 32 || ( which > 36 && which < 41 ) ) ) {\n\n\t\t// Stop propagation of the activate event\n\t\tevent.preventDefault();\n\t\tif ( event.stopPropagation ) {\n\t\t\tevent.stopImmediatePropagation();\n\t\t} else {\n\t\t\tevent.cancelBubble = true;\n\t\t}\n\n\t\t$elm = $( elm );\n\t\t$sldr = $elm.closest( selector );\n\t\tsldrId = $sldr[ 0 ].id;\n\t\tisPlaying = $sldr.hasClass( "playing" );\n\t\tisPlayPause = className.indexOf( "plypause" ) !== -1;\n\n\t\t// Reset ctime to 0\n\t\tdata = $sldr.data( componentName );\n\t\tdata.ctime = 0;\n\t\t$sldr.data( componentName, data );\n\n\t\t// Stop the slider from playing unless it is already stopped\n\t\t// and the play button is activated\n\t\tif ( ( isPlaying && which ) || ( isPlayPause && !( which > 36 && which < 41 ) ) ) {\n\t\t\tif ( isPlaying ) {\n\t\t\t\twb.remove( "#" + sldrId + selector );\n\t\t\t} else {\n\t\t\t\twb.add( "#" + sldrId + selector );\n\t\t\t}\n\n\t\t\t$sldr.toggleClass( "playing" );\n\t\t\tisPlaying = !isPlaying;\n\t\t\tbuttonText = isPlaying ? i18nText.pause : i18nText.play;\n\n\t\t\tplypause = $sldr.find( "a.plypause" )[ 0 ];\n\t\t\tplypause.setAttribute( "title", buttonText );\n\t\t\tplypause.innerHTML = "<span class=\'glyphicon glyphicon-" +\n\t\t\t\t( isPlaying ? "pause" : "play" ) + "\'></span> " +\n\t\t\t\t"<span>" + buttonText + "</span><span class=\'wb-inv\'>" +\n\t\t\t\tspaceText + i18nText.hyphen + spaceText +\n\t\t\t\t( isPlaying ? i18nText.rotStop : i18nText.rotStart ) + "</span>";\n\t\t}\n\n\t\t// Arrow keys\n\t\tif ( which > 36 ) {\n\t\t\tonCycle( $sldr, which < 39 ? -1 : 1 );\n\t\t\t$sldr.find( "> [role=tablist] .active a" ).trigger( setFocusEvent );\n\n\t\t// Not the escape key\n\t\t} else if ( which !== 27 ) {\n\n\t\t\t// If the target is a tab\n\t\t\tif ( elm.getAttribute( "role" ) === "tab" ) {\n\n\t\t\t\t// Only change the tabpanel if the tab is not currently selected\n\t\t\t\tif ( elm.getAttribute( "aria-selected" ) !== "true" ) {\n\t\t\t\t\tonPick( $sldr, $elm );\n\t\t\t\t}\n\n\t\t\t\t// Put focus on the tab panel if the enter key or space bar are used\n\t\t\t\tif ( which === 13 || which === 32 ) {\n\t\t\t\t\t$sldr.find( elm.getAttribute( "href" ) )\n\t\t\t\t\t\t.trigger( setFocusEvent );\n\t\t\t\t}\n\n\t\t\t// If the target is next, previous or tab count\n\t\t\t} else if ( !isPlayPause ) {\n\t\t\t\tonCycle( $sldr, className.indexOf( "prv" ) !== -1 ? -1 : 1 );\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Since we are working with events we want to ensure that we are being passive about our control,\n\t * so returning true allows for events to always continue\n\t */\n\treturn true;\n} );\n\n$document.on( activateEvent, selector + " [role=tabpanel]", function( event ) {\n\tvar currentTarget = event.currentTarget,\n\t\twhich = event.which,\n\t\t$container;\n\n\t// Stop propagation of the click/keydown event\n\tif ( event.stopPropagation ) {\n\t\tevent.stopImmediatePropagation();\n\t} else {\n\t\tevent.cancelBubble = true;\n\t}\n\n\t// Ctrl + Up arrow\n\tif ( event.ctrlKey && event.which === 38 ) {\n\n\t\t// Move focus to the tab or summary element\n\t\tif ( isSmallView ) {\n\t\t\t$( currentTarget ).prev().trigger( setFocusEvent );\n\t\t} else {\n\t\t\t$( currentTarget )\n\t\t\t\t.closest( selector )\n\t\t\t\t\t.find( "[href$=\'#" + currentTarget.id + "\']" )\n\t\t\t\t\t\t.trigger( setFocusEvent );\n\t\t}\n\n\t// Left mouse button click or escape key\n\t} else if ( !which || which === 1 || which === 27 ) {\n\t\t$container = $( event.currentTarget ).closest( selector );\n\n\t\t// Stop the carousel\n\t\tif ( $container.hasClass( "playing" ) ) {\n\t\t\t$container.find( ".plypause" ).trigger( "click" );\n\t\t}\n\t}\n} );\n\n// Handling for links to tabs from within a panel\n$document.on( "click", selector + " [role=tabpanel] a", function( event ) {\n\tvar currentTarget = event.currentTarget,\n\t\thref = currentTarget.getAttribute( "href" ),\n\t\twhich = event.which,\n\t\t$tabpanels, $panel, $summary;\n\n\t// Ignore middle and right mouse buttons\n\tif ( ( !which || which === 1 ) && href.charAt( 0 ) === "#" ) {\n\t\t$tabpanels = $( currentTarget ).closest( ".tabpanels" );\n\t\t$panel = $tabpanels.children( "#" + wb.jqEscape( href.substring( 1 ) ) );\n\t\tif ( $panel.length !== 0 ) {\n\t\t\tevent.preventDefault();\n\t\t\t$summary = $panel.children( "summary" );\n\t\t\tif ( $summary.length !== 0 && $summary.attr( "aria-hidden" ) !== "true" ) {\n\t\t\t\t$summary.trigger( "click" );\n\t\t\t} else {\n\t\t\t\t$tabpanels.parent().find( href + "-lnk" ).trigger( "click" );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// These events only fire at the document level\n$document.on( wb.resizeEvents, onResize );\n\n$document.on( activateEvent, selector + " > .tabpanels > details > summary", function( event ) {\n\tvar which = event.which,\n\t\tdetails = event.currentTarget.parentNode,\n\t\t$details, $container, tabSettings;\n\n\tif ( !( event.ctrlKey || event.altKey || event.metaKey ) &&\n\t\t( !which || which === 1 || which === 13 || which === 32 ) ) {\n\n\t\t$container = $( details.parentNode.parentNode );\n\t\t$details = $( details );\n\t\ttabSettings = $container.data( componentName ).settings;\n\n\t\t// Update sessionStorage with the current active panel\n\t\tif ( !tabSettings.ignoreSession ) {\n\t\t\ttry {\n\t\t\t\tsessionStorage.setItem(\n\t\t\t\t\tpagePath + $container.attr( "id" ) + activePanel,\n\t\t\t\t\tdetails.id\n\t\t\t\t);\n\t\t\t} catch ( error ) {\n\t\t\t}\n\t\t}\n\n\t\t// Update the URL hash if needed\n\t\tif ( tabSettings.updateHash ) {\n\t\t\tupdateHash( details );\n\t\t}\n\n\t\t// Identify that the tabbed interface accordion was updated\n\t\t// if the panel was not already open\n\t\tif ( !$details.attr( "open" ) ) {\n\t\t\t$container.trigger( updatedEvent, [ $details ] );\n\t\t}\n\t}\n} );\n\n// Change the panel based upon an external link click\n$document.on( "click", ".wb-tabs-ext", function( event ) {\n\tvar which = event.which;\n\n\t// Ignore middle and right mouse buttons\n\tif ( !which || which === 1 ) {\n\t\tevent.preventDefault();\n\t\tonSelect( event.currentTarget.getAttribute( "href" ).substring( 1 ) );\n\t}\n} );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, wb );\n\n/**\n * @title WET-BOEW Text highlighting\n * @overview Automatically highlights certain words on a Web page. The highlighted words can be selected via the query string.\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @pjackson28\n */\n( function( $, window, document, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-txthl",\n\tselector = "." + componentName,\n\tinitEvent = "wb-init" + selector,\n\t$document = wb.doc,\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\tparams = wb.pageUrlParts.params,\n\t\t\tsearchCriteria, newText;\n\n\t\tif ( elm ) {\n\t\t\tif ( event.txthl ) {\n\t\t\t\tsearchCriteria = $.isArray( event.txthl ) ? event.txthl.join( "|" ) : event.txthl;\n\t\t\t} else if ( params && params.txthl ) {\n\t\t\t\tsearchCriteria = decodeURIComponent(\n\t\t\t\t\twb.pageUrlParts.params.txthl\n\t\t\t\t\t\t.replace( /^\\s+|\\s+$|\\|+|\\"|\\(|\\)/g, "" ).replace( /\\++/g, "|" )\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif ( searchCriteria ) {\n\n\t\t\t\t// Strip html\n\t\t\t\tvar map = { "&": "&amp;", "<": "&lt;", ">": "&gt;", "\\"": "&quot;", "\'": "&#039;" };\n\t\t\t\tsearchCriteria = searchCriteria.replace( /[&<>"\']/g, function( m ) {\n\t\t\t\t\treturn map[ m ];\n\t\t\t\t} );\n\n\t\t\t\t// Make sure that we\'re not checking for text within a tag; only the text outside of tags.\n\t\t\t\tsearchCriteria = "(?=([^>]*<))([\\\\s\'])?(" + searchCriteria + ")(?!>)";\n\n\t\t\t\tnewText = elm.innerHTML.replace( new RegExp( searchCriteria, "gi" ), function( match, group1, group2, group3 ) {\n\t\t\t\t\treturn ( !group2 ? "" : group2 ) + "<mark class=\'txthl\'>" + group3 + "</mark>";\n\t\t\t\t} );\n\t\t\t\telm.innerHTML = newText;\n\t\t\t}\n\n\t\t\t// Identify that initialization has completed\n\t\t\twb.ready( $( elm ), componentName );\n\t\t}\n\t};\n\n// Bind the init event of the plugin\n$document.on( "timerpoke.wb " + initEvent, selector, init );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, document, wb );\n\n/**\n * @title WET-BOEW Toggle\n * @overview Plugin that allows a link to toggle elements between on and off states.\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @patheard\n */\n( function( $, window, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-toggle",\n\tselector = "." + componentName,\n\tselectorPanel = ".tgl-panel",\n\tselectorTab = ".tgl-tab",\n\tinitEvent = "wb-init" + selector,\n\ttoggleEvent = "toggle" + selector,\n\ttoggledEvent = "toggled" + selector,\n\tsetFocusEvent = "setfocus.wb",\n\tstates = {},\n\t$document = wb.doc,\n\t$window = wb.win,\n\n\tdefaults = {\n\t\tstateOn: "on",\n\t\tstateOff: "off"\n\t},\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar link = wb.init( event, componentName, selector, true ),\n\t\t\t$link, data, persistState;\n\n\t\tif ( link ) {\n\n\t\t\t// Merge the elements settings with the defaults\n\t\t\t$link = $( link );\n\t\t\tdata = $.extend( {}, defaults, $link.data( "toggle" ) );\n\t\t\t$link.data( "toggle", data );\n\n\t\t\t// Add aria attributes of the toggle element\n\t\t\tinitAria( link, data );\n\n\t\t\t// Persist toggle state across page loads\n\t\t\tif ( data.persist ) {\n\t\t\t\tpersistState = initPersist( $link, data );\n\t\t\t}\n\n\t\t\t// Toggle behaviour when the page is printed\n\t\t\tif ( data.print ) {\n\t\t\t\tinitPrint( $link, data );\n\t\t\t}\n\n\t\t\t// Set the initial state if the state has been specified and\n\t\t\t// the persistent state has not been set\n\t\t\tif ( !persistState && data.state ) {\n\t\t\t\tsetState( $link, data, data.state );\n\t\t\t}\n\n\t\t\t// Identify that initialization has completed\n\t\t\twb.ready( $link, componentName );\n\t\t}\n\t},\n\n\t/**\n\t * Initialize the aria attributes for a given toggle element\n\t * @param {DOM element} link The toggle element to initialize\n\t * @param {Object} data Simple key/value data object passed when the event was triggered\n\t */\n\tinitAria = function( link, data ) {\n\t\tvar i, len, elm, elms, parent, tabs, tab, panel, isOpen,\n\t\t\tariaControls = "",\n\t\t\thasOpen = false;\n\n\t\t// Group toggle elements with a parent are assumed to be a tablist\n\t\tif ( data.group != null && data.parent != null ) { //eslint-disable-line no-eq-null\n\t\t\tparent = document.querySelector( data.parent );\n\n\t\t\t// Check that the tablist widget hasn\'t already been initialized\n\t\t\tif ( parent.getAttribute( "role" ) !== "tablist" ) {\n\n\t\t\t\t// Only apply the tablist role if the parent is not the tabbed interface container\n\t\t\t\t// or the page is currently in "smallview", "xsmallview" or "xxsmallview"\n\t\t\t\tif ( parent.className.indexOf( "wb-tabs" ) === -1 ||\n\t\t\t\t\tdocument.documentElement.className.indexOf( "smallview" ) !== -1 ) {\n\t\t\t\t\tparent.setAttribute( "role", "tablist" );\n\t\t\t\t}\n\n\t\t\t\telms = parent.querySelectorAll( data.group );\n\t\t\t\ttabs = parent.querySelectorAll( data.group + " " + selectorTab );\n\n\t\t\t\t// Set the tab and panel aria attributes\n\t\t\t\tfor ( i = 0, len = elms.length; i !== len; i += 1 ) {\n\t\t\t\t\telm = elms[ i ];\n\t\t\t\t\ttab = tabs[ i ];\n\t\t\t\t\tpanel = elm.querySelector( selectorPanel );\n\n\t\t\t\t\t// Check if the element is toggled on based on the\n\t\t\t\t\t// open attribute or "on" CSS class\n\t\t\t\t\tisOpen = elm.nodeName.toLowerCase() === "details" ?\n\t\t\t\t\t\t!!elm.getAttribute( "open" ) :\n\t\t\t\t\t\t( " " + tab.className + " " ).indexOf( " " + data.stateOn + " " );\n\t\t\t\t\tif ( isOpen ) {\n\t\t\t\t\t\thasOpen = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( !tab.getAttribute( "id" ) ) {\n\t\t\t\t\t\ttab.setAttribute( "id", wb.getId() );\n\t\t\t\t\t}\n\t\t\t\t\ttab.setAttribute( "role", "tab" );\n\t\t\t\t\ttab.setAttribute( "aria-selected", isOpen );\n\t\t\t\t\ttab.setAttribute( "tabindex", isOpen ? "0" : "-1" );\n\t\t\t\t\ttab.setAttribute( "aria-posinset", i + 1 );\n\t\t\t\t\ttab.setAttribute( "aria-setsize", len );\n\n\t\t\t\t\tpanel.setAttribute( "role", "tabpanel" );\n\t\t\t\t\tpanel.setAttribute( "aria-labelledby", tab.getAttribute( "id" ) );\n\t\t\t\t\tpanel.setAttribute( "aria-expanded", isOpen );\n\t\t\t\t\tpanel.setAttribute( "aria-hidden", !isOpen );\n\t\t\t\t}\n\n\t\t\t\t// No open panels so put the first summary in the tab order\n\t\t\t\tif ( !hasOpen ) {\n\t\t\t\t\ttabs[ 0 ].setAttribute( "tabindex", "0" );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Set the elements this link controls\n\t\t} else {\n\t\t\telms = getElements( link, data );\n\t\t\tfor ( i = 0, len = elms.length; i !== len; i += 1 ) {\n\t\t\t\telm = elms[ i ];\n\t\t\t\tif ( !elm.id ) {\n\t\t\t\t\telm.id = wb.getId();\n\t\t\t\t}\n\t\t\t\tariaControls += elm.id + " ";\n\t\t\t}\n\t\t\tlink.setAttribute( "aria-controls", ariaControls.slice( 0, -1 ) );\n\t\t}\n\t},\n\n\t/**\n\t * Initializes persistent behaviour of the toggle element\n\t * @param {jQuery Object} $link The toggle element to initialize\n\t * @param {Object} data Simple key/value data object passed when the event was triggered\n\t * @returns {string} Persistent state\n\t */\n\tinitPersist = function( $link, data ) {\n\t\tvar state,\n\t\t\tlink = $link[ 0 ];\n\n\t\t// Store the persistence type and key for later use\n\t\tdata.persist = data.persist === "session" ? sessionStorage : localStorage;\n\t\tdata.persistKey = componentName + ( data.group ? data.group : "" ) + link.id;\n\n\t\t// If there\'s a saved toggle state, trigger the change to that state\n\t\tstate = data.persist.getItem( data.persistKey );\n\t\tif ( state ) {\n\t\t\t$link.trigger( toggleEvent, $.extend( {}, data, { type: state } ) );\n\t\t}\n\n\t\treturn state;\n\t},\n\n\t/**\n\t * Initialize open on print behaviour of the toggle element\n\t * @param {jQuery Object} $link The toggle element to initialize\n\t * @param {Object} data Simple key/value data object passed when the event was triggered\n\t */\n\tinitPrint = function( $link, data ) {\n\t\tvar mediaQuery,\n\t\t\tprintEvent = "beforeprint";\n\n\t\t$window.on( printEvent, function() {\n\t\t\t$link.trigger( toggleEvent, $.extend( {}, data, { type: data.print } ) );\n\t\t} );\n\n\t\t// Fallback for browsers that don\'t support print events\n\t\tif ( window.matchMedia ) {\n\t\t\tmediaQuery = window.matchMedia( "print" );\n\t\t\tif ( mediaQuery.addListener ) {\n\t\t\t\tmediaQuery.addListener( function( query ) {\n\t\t\t\t\tif ( query.matches ) {\n\t\t\t\t\t\t$window.trigger( printEvent );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Click handler for the toggle links\n\t * @param {jQuery Event} event The event that triggered this invocation\n\t */\n\tclick = function( event ) {\n\t\tvar $link = $( event.currentTarget );\n\n\t\t$link.trigger( toggleEvent, $link.data( "toggle" ) );\n\t\tevent.preventDefault();\n\n\t\t// Assign focus to eventTarget\n\t\t$link.trigger( setFocusEvent );\n\t},\n\n\t/**\n\t * Toggles the elements a link controls between the on and off states.\n\t * @param {jQuery Event} event The event that triggered this invocation\n\t * @param {Object} data Simple key/value data object passed when the event was triggered\n\t */\n\ttoggle = function( event, data ) {\n\t\tif ( event.namespace === componentName ) {\n\t\t\tvar dataGroup, key, $elmsGroup,\n\t\t\t\tisGroup = !!data.group,\n\t\t\t\tisPersist = !!data.persist,\n\t\t\t\tisTablist = isGroup && !!data.parent,\n\t\t\t\tlink = event.currentTarget,\n\t\t\t\t$link = $( link ),\n\t\t\t\tstateFrom = getState( $link, data ),\n\t\t\t\tisToggleOn = stateFrom === data.stateOff,\n\t\t\t\tstateTo = isToggleOn ? data.stateOn : data.stateOff,\n\t\t\t\t$elms = isTablist ?\t$link.parent( data.group ) : getElements( link, data );\n\n\t\t\t// Group toggle behaviour: only one element in the group open at a time.\n\t\t\tif ( isGroup ) {\n\n\t\t\t\t// Get the grouped elements using data.group as the CSS selector\n\t\t\t\tdataGroup = $.extend( {}, data, { selector: data.group } );\n\t\t\t\t$elmsGroup = getElements( link, dataGroup );\n\n\t\t\t\t// Set the toggle state to "off".  For tab lists, this is stored on the tab element\n\t\t\t\tsetState( isTablist ? $( data.parent ).find( selectorTab ) : $elmsGroup,\n\t\t\t\t\tdataGroup, data.stateOff );\n\n\t\t\t\t// Toggle all grouped elements to "off"\n\t\t\t\t$elmsGroup.wb( "toggle", data.stateOff, data.stateOn );\n\t\t\t\t$elmsGroup.trigger( toggledEvent, {\n\t\t\t\t\tisOn: false,\n\t\t\t\t\tisTablist: isTablist,\n\t\t\t\t\telms: $elmsGroup\n\t\t\t\t} );\n\n\t\t\t\t// Remove all grouped persistence keys\n\t\t\t\tif ( isPersist ) {\n\t\t\t\t\tfor ( key in data.persist ) {\n\t\t\t\t\t\tif ( key.indexOf( componentName + data.group ) === 0 ) {\n\t\t\t\t\t\t\tdata.persist.removeItem( key );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the toggle state. For tab lists, this is set on the tab element\n\t\t\tsetState( isTablist ? $link : $elms, data, stateTo );\n\n\t\t\t// Toggle all elements to the requested state\n\t\t\t$elms.wb( "toggle", stateTo, stateFrom );\n\t\t\t$elms.trigger( toggledEvent, {\n\t\t\t\tisOn: isToggleOn,\n\t\t\t\tisTablist: isTablist,\n\t\t\t\telms: $elms\n\t\t\t} );\n\n\t\t\t// Ensure that last focused element in the accordion remains keyboard focusable\n\t\t\t// whether it is collapsed or not\n\t\t\tif ( isGroup ) {\n\t\t\t\t$elms.find( "summary" ).attr( { "tabindex": "0" } );\n\t\t\t}\n\n\t\t\t// Store the toggle link\'s current state if persistence is turned on.\n\t\t\t// Try/catch is required to address exceptions thrown when using BB10 or\n\t\t\t// private browsing in iOS.\n\t\t\tif ( isPersist ) {\n\t\t\t\ttry {\n\t\t\t\t\tdata.persist.setItem( data.persistKey, stateTo );\n\t\t\t\t} catch ( error ) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Sets the required property and attribute for toggling open/closed a details element\n\t * @param {jQuery Event} event The event that triggered this invocation\n\t * @param {Object} data Simple key/value data object passed when the event was triggered\n\t */\n\ttoggleDetails = function( event, data ) {\n\t\tif ( event.namespace === componentName && event.target === event.currentTarget ) {\n\t\t\tvar top,\n\t\t\t\tisOn = data.isOn,\n\t\t\t\t$elms = data.elms,\n\t\t\t\t$this = $( this ),\n\t\t\t\t$detail = $this.is( "summary" ) ? $this.parent() : $this;\n\n\t\t\t// Stop propagation of the toggleDetails event\n\t\t\tif ( event.stopPropagation ) {\n\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t} else {\n\t\t\t\tevent.cancelBubble = true;\n\t\t\t}\n\n\t\t\t$detail.prop( "open", isOn );\n\n\t\t\tif ( data.isTablist ) {\n\n\t\t\t\t// Set the required aria attributes\n\t\t\t\t$elms.find( selectorTab ).attr( {\n\t\t\t\t\t"aria-selected": isOn,\n\t\t\t\t\ttabindex: isOn ? "0" : "-1"\n\t\t\t\t} );\n\t\t\t\t$elms.find( selectorPanel ).attr( {\n\t\t\t\t\t"aria-hidden": !isOn,\n\t\t\t\t\t"aria-expanded": isOn\n\t\t\t\t} );\n\n\t\t\t\t// Check that the top of the open element is in view.\n\t\t\t\tif ( isOn && $elms.length === 1 ) {\n\t\t\t\t\ttop = $elms.offset().top;\n\t\t\t\t\tif ( top < $window.scrollTop() ) {\n\t\t\t\t\t\t$window.scrollTop( top );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Returns the elements a given toggle element controls.\n\t * @param {DOM element} link Toggle element that was clicked\n\t * @param {Object} data Simple key/value data object passed when the event was triggered\n\t * @returns {jQuery Object} DOM elements the toggle link controls\n\t */\n\tgetElements = function( link, data ) {\n\t\tvar selector = data.selector || link,\n\t\t\tparent = data.parent || null;\n\n\t\treturn parent !== null ? $( parent ).find( selector ) : $( selector );\n\t},\n\n\t/**\n\t * Gets the current toggle state of elements controlled by the given link.\n\t * @param {jQuery Object} $link Toggle link that was clicked\n\t * @param {Object} data Simple key/value data object passed when the event was triggered\n\t */\n\tgetState = function( $link, data ) {\n\t\tvar parent = data.parent,\n\t\t\tselector = data.selector,\n\t\t\ttype = data.type;\n\n\t\t// Get opposite state of the type. Toggle reverses this\n\t\t// to the requested state.\n\t\tif ( type ) {\n\t\t\treturn type === "on" ? data.stateOff : data.stateOn;\n\n\t\t// <details> elements use the open attribute to determine state\n\t\t} else if ( $link[ 0 ].nodeName.toLowerCase() === "summary" ) {\n\t\t\treturn $link.parent().attr( "open" ) ? data.stateOn : data.stateOff;\n\n\t\t// When no selector, use the data attribute of the link\n\t\t} else if ( !selector ) {\n\t\t\treturn $link.data( componentName + "-state" ) || data.stateOff;\n\n\t\t// Get the current on/off state of the elements specified by the selector and parent\n\t\t} else if ( states.hasOwnProperty( selector ) ) {\n\t\t\treturn states[ selector ].hasOwnProperty( parent ) ?\n\t\t\t\tstates[ selector ][ parent ] :\n\t\t\t\tstates[ selector ].all;\n\t\t}\n\t\treturn data.stateOff;\n\t},\n\n\t/*\n\t * Sets the current toggle state of elements controlled by the given link.\n\t * @param {DOM element} link Toggle link that was clicked\n\t * @param {Object} data Simple key/value data object passed when the event was triggered\n\t * @param {String} state The current state of the elements: "on" or "off"\n\t */\n\tsetState = function( $elms, data, state ) {\n\t\tvar prop,\n\t\t\tparent = data.parent,\n\t\t\tselector = data.selector,\n\t\t\telmsState = states[ selector ];\n\n\t\tif ( selector ) {\n\n\t\t\t// Check the selector object has been created\n\t\t\tif ( !elmsState ) {\n\t\t\t\telmsState = { all: data.stateOff };\n\t\t\t\tstates[ selector ] = elmsState;\n\t\t\t}\n\n\t\t\t// If there\'s a parent, set its state\n\t\t\tif ( parent ) {\n\t\t\t\telmsState[ parent ] = state;\n\n\t\t\t// No parent means set all states for the given selector. This is\n\t\t\t// because toggle links that apply to the entire DOM also affect\n\t\t\t// links that are restricted by parent.\n\t\t\t} else {\n\t\t\t\tfor ( prop in elmsState ) {\n\t\t\t\t\tif ( elmsState.hasOwnProperty( prop ) ) {\n\t\t\t\t\t\telmsState[ prop ] = state;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Store the state on the elements as well. This allows a link to toggle itself.\n\t\t$elms.data( componentName + "-state", state );\n\t};\n\n// Bind the plugin\'s events\n$document.on( "timerpoke.wb " + initEvent + " " + toggleEvent +\n" click", selector, function( event, data ) {\n\n\tvar eventType = event.type;\n\n\tswitch ( eventType ) {\n\tcase "click":\n\t\tclick( event );\n\t\tbreak;\n\n\tcase "toggle":\n\t\ttoggle( event, data );\n\t\tbreak;\n\n\tcase "timerpoke":\n\tcase "wb-init":\n\t\tinit( event );\n\t\tbreak;\n\t}\n} );\n\n$document.on( toggledEvent, "summary, details", toggleDetails );\n\n// Keyboard handling for the accordion\n$document.on( "keydown", selectorTab, function( event ) {\n\tvar which = event.which,\n\t\tdata, $elm, $parent, $group, $newPanel, index;\n\n\tif ( !event.ctrlKey && which > 34 && which < 41 ) {\n\t\tevent.preventDefault();\n\t\t$elm = $( event.currentTarget );\n\t\tdata = $elm.data( "toggle" );\n\t\t$parent = $document.find( data.parent );\n\t\t$group = $parent.find( data.group );\n\t\tindex = $group.index( $elm.parent() );\n\n\t\tswitch ( which ) {\n\n\t\t// End\n\t\tcase 35:\n\t\t\t$newPanel = $group.last();\n\t\t\tbreak;\n\n\t\t// Home\n\t\tcase 36:\n\t\t\t$newPanel = $group.first();\n\t\t\tbreak;\n\n\t\t// Left / up arrow\n\t\tcase 37:\n\t\tcase 38:\n\t\t\tif ( index === 0 ) {\n\t\t\t\t$newPanel = $group.last();\n\t\t\t} else {\n\t\t\t\t$newPanel = $group.eq( index - 1 );\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Right / down arrow\n\t\tcase 39:\n\t\tcase 40:\n\t\t\tif ( index === $group.length - 1 ) {\n\t\t\t\t$newPanel = $group.first();\n\t\t\t} else {\n\t\t\t\t$newPanel = $group.eq( index + 1 );\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t$newPanel\n\t\t\t.children( "summary" )\n\t\t\t\t.trigger( setFocusEvent );\n\t}\n} );\n\n$document.on( "keydown", selectorPanel, function( event ) {\n\n\t// Ctrl + Up arrow\n\tif ( event.ctrlKey && event.which === 38 ) {\n\n\t\t// Move focus to the summary element\n\t\t$( event.currentTarget )\n\t\t\t.prev()\n\t\t\t\t.trigger( setFocusEvent );\n\t}\n} );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, wb );\n\n/**\n * @title WET-BOEW Twitter embedded timeline\n * @overview Helps with implementing Twitter embedded timelines.\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @pjackson28\n */\n( function( $, window, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-twitter",\n\tselector = "." + componentName,\n\tinitEvent = "wb-init" + selector,\n\t$document = wb.doc,\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar eventTarget = wb.init( event, componentName, selector ),\n\t\t\tprotocol = wb.pageUrlParts.protocol;\n\n\t\tif ( eventTarget ) {\n\t\t\tModernizr.load( {\n\t\t\t\tload: ( protocol.indexOf( "http" ) === -1 ? "http:" : protocol ) + "//platform.twitter.com/widgets.js",\n\t\t\t\tcomplete: function() {\n\n\t\t\t\t\t// Identify that initialization has completed\n\t\t\t\t\twb.ready( $( eventTarget ), componentName );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t};\n\n$document.on( "timerpoke.wb " + initEvent, selector, init );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, wb );\n\n/**\n * @title WET-BOEW Disable Event\n * @overview Event creates the active offer for users that have disabled the event.\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @gc\n */\n( function( $, window, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the event - meaning that they will be initialized once per page,\n * not once per instance of event on the page.\n */\nvar componentName = "wb-disable",\n\tselector = "#wb-tphp",\n\t$document = wb.doc,\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector, true ),\n\t\t\tnQuery = "?",\n\t\t\t$html = wb.html,\n\t\t\ti18n = wb.i18n,\n\t\t\tpageUrl = wb.pageUrlParts,\n\t\t\tli, param,\n\t\t\tnoticeHeader = i18n( "disable-notice-h" ),\n\t\t\tnoticeBody = i18n( "disable-notice" ),\n\t\t\tnoticehtml = "<section",\n\t\t\tnoticehtmlend = "</a>.</p></section>";\n\n\t\tif ( elm ) {\n\t\t\tli = document.createElement( "li" );\n\t\t\tli.className = "wb-slc";\n\n\t\t\t// Rebuild the query string\n\t\t\tfor ( param in pageUrl.params ) {\n\t\t\t\tif ( param && pageUrl.params.hasOwnProperty( param ) && param !== "wbdisable" ) {\n\t\t\t\t\tnQuery += param + "=" + pageUrl.params[ param ] + "&#38;";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif ( wb.isDisabled || ( wb.ie && wb.ielt7 ) ) {\n\t\t\t\t\t$html.addClass( "wb-disable" );\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\t// Store preference for WET plugins and polyfills to be disabled in localStorage\n\t\t\t\t\t\tlocalStorage.setItem( "wbdisable", "true" );\n\t\t\t\t\t} catch ( e ) {}\n\n\t\t\t\t\t// Add notice and link to re-enable WET plugins and polyfills\n\t\t\t\t\tnoticehtml = noticehtml + " class=\'alert alert-warning text-center\'><h2>" + noticeHeader + "</h2><p>" + noticeBody + "</p><p><a rel=\'alternate\' property=\'significantLink\' href=\'" + nQuery + "wbdisable=false\'>" + i18n( "wb-enable" ) + noticehtmlend;\n\t\t\t\t\t$( elm ).after( noticehtml );\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\t$html.addClass( "wb-enable" );\n\n\t\t\t\t\tif ( localStorage ) {\n\n\t\t\t\t\t\t// Store preference for WET plugins and polyfills to be enabled in localStorage\n\t\t\t\t\t\tlocalStorage.setItem( "wbdisable", "false" );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remove variable from URL\n\t\t\t\t\tvar lc = window.location.href.replace( "wbdisable=false", "" ).replace( "?#", "#" );\n\t\t\t\t\tif ( lc.indexOf( "?" ) === ( lc.length - 1 ) ) {\n\t\t\t\t\t\tlc = lc.replace( "?", "" );\n\t\t\t\t\t}\n\t\t\t\t\twindow.history.replaceState( "", "", lc );\n\t\t\t\t}\n\t\t\t} catch ( error ) {\n\t\t\t}\n\n\t\t\t// Append the Basic HTML version link version\n\t\t\tli.innerHTML = "<a class=\'wb-sl\' rel=\'alternate\' href=\'" + nQuery + "wbdisable=true\'>" + i18n( "wb-disable" ) + "</a>";\n\n\t\t\t// Add link to disable WET plugins and polyfills\n\t\t\telm.appendChild( li );\n\n\t\t\t// Identify that initialization has completed\n\t\t\twb.ready( $document, componentName );\n\t\t}\n\t};\n\n// Bind the events\n$document.on( "timerpoke.wb", selector, init );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, wb );\n\n/**\n * @title WET-BOEW Focus\n * @overview User agent safe way of assigning focus to an element\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @pjackson28\n */\n( function( $, wb ) {\n"use strict";\n\nvar $document = wb.doc,\n\t$window = wb.win,\n\tclickEvents = "click vclick",\n\tsetFocusEvent = "setfocus.wb",\n\tlinkSelector = "a[href]",\n\t$linkTarget,\n\n\t/**\n\t * @method processHash\n\t */\n\tprocessHash = function() {\n\t\tvar hash = wb.pageUrlParts.hash;\n\n\t\tif ( hash && ( $linkTarget = $( "#" + wb.jqEscape( hash.substring( 1 ) ) ) ).length !== 0 ) {\n\t\t\t$linkTarget.trigger( setFocusEvent );\n\t\t}\n\t};\n\n// Bind the setfocus event\n$document.on( setFocusEvent, function( event ) {\n\tif ( event.namespace === "wb" ) {\n\t\tvar $elm = $( event.target ),\n\t\t\t$closedParents = $elm.not( "summary" ).parents( "details, [role=\'tabpanel\']" ),\n\t\t\t$closedPanels, $closedPanel, len, i;\n\n\t\tif ( $closedParents.length !== 0 ) {\n\n\t\t\t// Open any closed ancestor details elements\n\t\t\t$closedParents.not( "[open]" ).children( "summary" ).trigger( "click" );\n\n\t\t\t// Open any closed tabpanels\n\t\t\t$closedPanels = $closedParents.filter( "[aria-hidden=\'true\']" );\n\t\t\tlen = $closedPanels.length;\n\t\t\tfor ( i = 0; i !== len; i += 1 ) {\n\t\t\t\t$closedPanel = $closedPanels.eq( i );\n\t\t\t\t$closedPanel.closest( ".wb-tabs" )\n\t\t\t\t\t.find( "#" + $closedPanel.attr( "aria-labelledby" ) )\n\t\t\t\t\t\t.trigger( "click" );\n\t\t\t}\n\t\t}\n\n\t\t// Set the tabindex to -1 (as needed) to ensure the element is focusable\n\t\t$elm\n\t\t\t.filter( ":not([tabindex], a[href], button, input, textarea, select)" )\n\t\t\t\t.attr( "tabindex", "-1" );\n\n\t\t// Assigns focus to an element (delay allows for revealing of hidden content)\n\t\tsetTimeout( function() {\n\t\t\t$elm.trigger( "focus" );\n\n\t\t\tvar $topBar = $( ".wb-bar-t[aria-hidden=false]" );\n\n\t\t\t// Ensure the top bar overlay does not conceal the focus target\n\t\t\tif ( $topBar.length !== 0 ) {\n\t\t\t\tdocument.documentElement.scrollTop -= $topBar.outerHeight();\n\t\t\t}\n\n\t\t\treturn $elm;\n\t\t}, 100 );\n\t}\n} );\n\n// Set focus to the target of a deep link from a different page\n// (helps browsers that can\'t set the focus on their own)\n$document.on( "wb-ready.wb", processHash );\n\n// Handle any changes to the URL hash after the page has loaded\n$window.on( "hashchange", function() {\n\twb.pageUrlParts.hash = window.location.hash;\n\tif ( !wb.ignoreHashChange ) {\n\t\tprocessHash();\n\t}\n} );\n\n// Helper for browsers that can\'t change keyboard and/or event focus on a same page link click\n$document.on( clickEvents, linkSelector, function( event ) {\n\tvar testHref = event.currentTarget.getAttribute( "href" );\n\n\t// Same page links only\n\tif ( testHref.charAt( 0 ) === "#" && !event.isDefaultPrevented() &&\n\t\t( $linkTarget = $( "#" + wb.jqEscape( testHref.substring( 1 ) ) ) ).length !== 0 ) {\n\t\twb.ignoreHashChange = true;\n\t\t$linkTarget.trigger( setFocusEvent );\n\t}\n} );\n\n} )( jQuery, wb );\n\n/**\n * Web Experience Toolkit (WET) / Boîte à outils de l\'expérience Web (BOEW)\n * @title Zebra\n * @overview Apply Zebra stripping on a complex data table and simulate column hovering effect\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @duboisp\n *\n */\n( function( $, window, document, wb ) {\n"use strict";\n\n/**\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-zebra",\n\tselector = "." + componentName,\n\thoverColClass = componentName + "-col-hover",\n\tselectorHoverCol = "." + hoverColClass + " td, " + hoverColClass + " th",\n\tinitEvent = "wb-init" + selector,\n\ttableParsingEvent = "passiveparse.wb-tableparser",\n\ttableParsingCompleteEvent = "parsecomplete.wb-tableparser",\n\t$document = wb.doc,\n\tidCount = 0,\n\ti18n, i18nText,\n\n\t/**\n\t * Main Entry function to apply the complex zebra stripping\n\t * @method zebraTable\n\t * @param {jQuery DOM element} $elm table element use to apply complex zebra stripping\n\t */\n\tzebraTable = function( $elm ) {\n\t\tvar i, iLength, tblGroup,\n\n\t\t\t// Cache the table parsed results\n\t\t\ttblparser = $elm.data().tblparser;\n\n\t\tfunction addCellClass( arr, className ) {\n\t\t\tvar i, iLength;\n\n\t\t\tfor ( i = 0, iLength = arr.length; i !== iLength; i += 1 ) {\n\t\t\t\t$( arr[ i ].elem ).addClass( className );\n\t\t\t}\n\t\t}\n\n\t\t// Key Cell\n\t\tif ( tblparser.keycell ) {\n\t\t\taddCellClass( tblparser.keycell, "wb-cell-key" );\n\t\t}\n\n\t\t// Description Cell\n\t\tif ( tblparser.desccell ) {\n\t\t\taddCellClass( tblparser.desccell, "wb-cell-desc" );\n\t\t}\n\n\t\t// Layout Cell\n\t\tif ( tblparser.layoutCell ) {\n\t\t\taddCellClass( tblparser.layoutCell, "wb-cell-layout" );\n\t\t}\n\n\t\t// Summary Row Group\n\t\tif ( tblparser.lstrowgroup ) {\n\t\t\tfor ( i = 0, iLength = tblparser.lstrowgroup.length; i !== iLength; i += 1 ) {\n\t\t\t\ttblGroup = tblparser.lstrowgroup[ i ];\n\n\t\t\t\t// Add a class to the row\n\t\t\t\tif ( tblGroup.type === 3 || tblGroup.row[ 0 ].type === 3 ) {\n\t\t\t\t\t$( tblGroup.elem ).addClass( "wb-group-summary" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Summary Column Group\n\t\tif ( tblparser.colgroup ) {\n\t\t\tfor ( i = 0, iLength = tblparser.colgroup.length; i !== iLength; i += 1 ) {\n\t\t\t\ttblGroup = tblparser.colgroup[ i ];\n\n\t\t\t\t// Add a class to the row\n\t\t\t\tif ( tblGroup.type === 3 ) {\n\t\t\t\t\t$( tblGroup.elem ).addClass( "wb-group-summary" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Identify that initialization has completed\n\t\twb.ready( $elm, componentName );\n\t},\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\tdeps = [\n\t\t\t\t"site!deps/tableparser" + wb.getMode() + ".js"\n\t\t\t],\n\t\t\telmId;\n\n\t\tif ( elm ) {\n\t\t\telmId = elm.id;\n\n\t\t\t// Ensure there is a unique id on the element\n\t\t\tif ( !elmId ) {\n\t\t\t\telmId = componentName + "-id-" + idCount;\n\t\t\t\tidCount += 1;\n\t\t\t\telm.id = elmId;\n\t\t\t}\n\n\t\t\t// Only initialize the i18nText once\n\t\t\tif ( !i18nText ) {\n\t\t\t\ti18n = wb.i18n;\n\t\t\t\ti18nText = {\n\t\t\t\t\ttableMention: i18n( "hyphen" ) + i18n( "tbl-txt" ),\n\t\t\t\t\ttableFollowing: i18n( "hyphen" ) + i18n( "tbl-dtls" )\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Load the required dependencies\n\t\t\tModernizr.load( {\n\n\t\t\t\t// For loading multiple dependencies\n\t\t\t\tload: deps,\n\t\t\t\tcomplete: function() {\n\n\t\t\t\t\t// Let\'s parse the table\n\t\t\t\t\t$( "#" + elmId ).trigger( tableParsingEvent );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t};\n\n// Bind the init event of the plugin\n$document.on( "timerpoke.wb " + initEvent + " " + tableParsingCompleteEvent, selector, function( event ) {\n\tvar eventTarget = event.target;\n\n\tswitch ( event.type ) {\n\n\t/*\n\t * Init\n\t */\n\tcase "timerpoke":\n\tcase "wb-init":\n\t\tinit( event );\n\t\tbreak;\n\n\t/*\n\t * Data table parsed\n\t */\n\tcase "parsecomplete":\n\t\tif ( event.currentTarget === eventTarget ) {\n\t\t\tzebraTable( $( eventTarget ) );\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Since we are working with events we want to ensure that we are being passive about our control,\n\t * so returning true allows for events to always continue\n\t */\n\treturn true;\n} );\n\n// Applying the hover, Simulate Column Hovering Effect\n$document.on( "mouseenter focusin", selectorHoverCol, function( event ) {\n\tvar tblparserCell = $( event.currentTarget ).data().tblparser;\n\n\tif ( tblparserCell.col && tblparserCell.col.elem ) {\n\t\t$( tblparserCell.col.elem ).addClass( "table-hover" );\n\t}\n} );\n\n// Removing the hover, Simulate Column Hovering Effect\n$document.on( "mouseleave focusout", selectorHoverCol, function( event ) {\n\tvar tblparserCell = $( event.currentTarget ).data().tblparser;\n\n\tif ( tblparserCell.col && tblparserCell.col.elem ) {\n\t\t$( tblparserCell.col.elem ).removeClass( "table-hover" );\n\t}\n} );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, document, wb );\n'},function(t,e,n){n(0)(n(7))},function(t,e){t.exports='/**\n * @title WET-BOEW Action Manager\n * @overview API that coordinate actions with other wet-boew plugin\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @duboisp\n */\n( function( $, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar $document = wb.doc,\n\tcomponentName = "wb-actionmng",\n\tselector = "." + componentName,\n\tselectorPreset = "[data-" + componentName + "]",\n\trunCssFlag = componentName + "Rn",\n\tinitEvent = "wb-init." + componentName,\n\tactionEvent = componentName + selector,\n\tpostponePreActions = { },\n\tpostponeActions = { },\n\tgroupPostAction = { },\n\tactionMngEvent = [\n\t\t"patch",\n\t\t"ajax",\n\t\t"addClass",\n\t\t"removeClass",\n\t\t"tblfilter",\n\t\t"run"\n\t].join( "." + actionEvent + " " ) + "." + actionEvent,\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\t$elm,\n\t\t\tactions, i, i_len, i_cache, i_trggrp;\n\n\t\tif ( elm ) {\n\t\t\t$elm = $( elm );\n\n\t\t\tactions = wb.getData( $elm, componentName );\n\n\t\t\tif ( actions ) {\n\t\t\t\tif ( !$.isArray( actions ) ) {\n\t\t\t\t\tactions = [ actions ];\n\t\t\t\t}\n\t\t\t\ti_len = actions.length;\n\t\t\t\tfor ( i = 0; i !== i_len; i += 1 ) {\n\t\t\t\t\ti_cache = actions[ i ];\n\t\t\t\t\ti_trggrp = i_cache.trggroup;\n\t\t\t\t\tif ( i_trggrp && i_cache.action ) {\n\t\t\t\t\t\taddDelayedAction( i_trggrp, groupPostAction, i_cache );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Identify that initialization has completed\n\t\t\twb.ready( $elm, componentName );\n\t\t}\n\t},\n\taddDelayedAction = function( k, a, o ) {\n\t\tif ( !a[ k ] ) {\n\t\t\ta[ k ] = [ ];\n\t\t}\n\t\ta[ k ].push( o );\n\t},\n\texecutePostAction = function( $elm, k, a ) {\n\t\tvar actions, i_cache, i_action;\n\n\t\tactions = a[ k ];\n\t\twhile ( ( i_cache = actions.shift() ) ) {\n\t\t\ti_action = i_cache.action;\n\t\t\tif ( !i_action ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t$elm.trigger( i_action + "." + actionEvent, i_cache );\n\t\t\tdelete i_cache.action;\n\t\t}\n\t},\n\tpatchAct = function( event, data ) {\n\n\t\t// Prepare patches operation for execution by the json-manager\n\t\tvar source = data.source,\n\t\t\tops = data.patches,\n\t\t\tisCumulative = !!data.cumulative;\n\n\t\tif ( !ops ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !$.isArray( ops ) ) {\n\t\t\tops = [ ops ];\n\t\t}\n\n\t\t$( source ).trigger( {\n\t\t\ttype: "patches.wb-jsonmanager",\n\t\t\tpatches: ops,\n\t\t\tfpath: data.fpath,\n\t\t\tfilter: data.filter || [],\n\t\t\tfilternot: data.filternot || [],\n\t\t\tcumulative: isCumulative // Ensure the patches would remain as any other future update.\n\t\t} );\n\n\t},\n\tajaxAct = function( event, data ) {\n\t\tvar $container, containerID, ajxType;\n\n\t\tif ( !data.container ) {\n\t\t\tcontainerID = wb.getId();\n\t\t\t$container = $( "<div id=\'" + containerID + "\'></div>" );\n\t\t\t$( event.target ).after( $container );\n\t\t} else {\n\t\t\t$container = $( data.container );\n\t\t}\n\n\t\tif ( data.trigger ) {\n\t\t\t$container.attr( "data-trigger-wet", "true" );\n\t\t}\n\n\t\tajxType = data.type ? data.type : "replace";\n\t\t$container.attr( "data-ajax-" + ajxType, data.url );\n\n\t\t$container.one( "wb-contentupdated", function( event, data ) {\n\t\t\tvar updtElm = event.currentTarget,\n\t\t\t\ttrigger = updtElm.getAttribute( "data-trigger-wet" );\n\n\t\t\tupdtElm.removeAttribute( "data-ajax-" + data[ "ajax-type" ] );\n\t\t\tif ( trigger ) {\n\t\t\t\t$( updtElm )\n\t\t\t\t\t.find( wb.allSelectors )\n\t\t\t\t\t\t.addClass( "wb-init" )\n\t\t\t\t\t\t.filter( ":not(#" + updtElm.id + " .wb-init .wb-init)" )\n\t\t\t\t\t\t\t.trigger( "timerpoke.wb" );\n\t\t\t\tupdtElm.removeAttribute( "data-trigger-wet" );\n\t\t\t}\n\t\t} );\n\t\t$container.trigger( "wb-update.wb-data-ajax" );\n\t},\n\taddClassAct = function( event, data ) {\n\t\tvar $elm = $( data.source || event.target );\n\t\tif ( !data.class ) {\n\t\t\treturn;\n\t\t}\n\t\t$elm.addClass( data.class );\n\t},\n\tremClassAct = function( event, data ) {\n\t\tvar $elm = $( data.source || event.target );\n\t\tif ( !data.class ) {\n\t\t\treturn;\n\t\t}\n\t\t$elm.removeClass( data.class );\n\t},\n\ttblflrAct = function( event, data ) {\n\t\tvar elm = event.target,\n\t\t\t$source = $( data.source || elm ),\n\t\t\t$datatable,\n\t\t\tcolumn = data.column,\n\t\t\tcolInt = parseInt( column, 10 ),\n\t\t\tregex = !!data.regex,\n\t\t\tsmart = ( !data.smart ) ? true : !!data.smart,\n\t\t\tcaseinsen = ( !data.caseinsen ) ? true : !!data.caseinsen;\n\n\t\tif ( $source.get( 0 ).nodeName !== "TABLE" ) {\n\t\t\tthrow "Table filtering can only applied on table";\n\t\t}\n\t\t$datatable = $source.dataTable( { "retrieve": true } ).api();\n\t\tcolumn = ( colInt === true ) ? colInt : column;\n\t\t$datatable.column( column ).search( data.value, regex, smart, caseinsen ).draw();\n\t},\n\trunAct = function( event, data ) {\n\n\t\tvar elm = event.target,\n\t\t\t$elm = $( elm ),\n\t\t\tgrpAction = groupPostAction[ data.trggroup ],\n\t\t\ti, i_len, i_cache, i_action;\n\n\t\tif ( grpAction && !$elm.hasClass( runCssFlag ) ) {\n\t\t\t$elm.addClass( runCssFlag );\n\n\t\t\ti_len = grpAction.length;\n\t\t\tfor ( i = 0; i !== i_len; i += 1 ) {\n\t\t\t\ti_cache = grpAction[ i ];\n\n\t\t\t\ti_action = i_cache.action;\n\t\t\t\tif ( !i_action ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t$elm.trigger( i_action + "." + actionEvent, i_cache );\n\t\t\t}\n\t\t\t$elm.removeClass( runCssFlag );\n\t\t}\n\t};\n\n// Main entry to submit wet-boew plugin actions\n// It will be only executed once per event chain\n$document.on( "do." + actionEvent, function( event ) {\n\tvar elm =  event.element || event.target,\n\t\t$elm, elmID = elm.id,\n\t\tactions = event.actions || [ ],\n\t\ti, i_len, i_cache,\n\t\ti_action, i_target, i_trggrp;\n\n\t// Filter out any events triggered by descendants\n\tif ( ( elm === event.target || event.currentTarget === event.target ) && elm.className.indexOf( componentName ) === -1 ) {\n\n\t\tif ( !$.isArray( actions ) ) {\n\t\t\tactions = [ actions ];\n\t\t}\n\n\t\ti_len = actions.length;\n\n\t\t// Add a CSS selector to trigger action Events\n\t\tif ( i_len ) {\n\t\t\t$elm = $( elm );\n\t\t\t$elm.addClass( componentName );\n\t\t}\n\n\t\t// For this elements, check if we do not have some postponed pre action to execute.\n\t\tif ( elmID && postponePreActions[ elmID ] ) {\n\t\t\texecutePostAction( $elm, elmID, postponePreActions );\n\t\t}\n\n\t\tfor ( i = 0; i !== i_len; i += 1 ) {\n\t\t\ti_cache = actions[ i ];\n\n\t\t\ti_action = i_cache.action;\n\t\t\tif ( !i_action ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ti_target = i_cache.target;\n\t\t\tif ( i_target ) {\n\n\t\t\t\tif ( !i_cache.trgbefore ) {\n\t\t\t\t\taddDelayedAction( i_target, postponeActions, i_cache );\n\t\t\t\t} else {\n\t\t\t\t\taddDelayedAction( i_target, postponePreActions, i_cache );\n\t\t\t\t}\n\n\t\t\t\t// If the target are in a group\n\t\t\t\ti_trggrp = i_cache.trggroup;\n\t\t\t\tif ( i_trggrp ) {\n\t\t\t\t\taddDelayedAction( i_trggrp, groupPostAction, i_cache );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$elm.trigger( i_action + "." + actionEvent, i_cache );\n\t\t\t}\n\t\t}\n\n\t\t// For this elements, check if we do not have some postponed action to execute.\n\t\tif ( elmID && postponeActions[ elmID ] ) {\n\t\t\texecutePostAction( $elm, elmID, postponeActions );\n\t\t}\n\n\t\t$( event.target ).removeClass( componentName );\n\t}\n} );\n\n//Remove any action for grouped postponed action\n$document.on( "clean." + actionEvent, function( event ) {\n\tvar elm =  event.element || event.target,\n\t\ttargetGroup = event.trggroup,\n\t\tactionsGrp, i_cache;\n\n\t// Filter out any events triggered by descendants\n\tif ( elm === event.target || event.currentTarget === event.target ) {\n\t\tif ( targetGroup && groupPostAction[ targetGroup ] ) {\n\t\t\tactionsGrp = groupPostAction[ targetGroup ];\n\t\t\twhile ( ( i_cache = actionsGrp.shift() ) ) {\n\t\t\t\tdelete i_cache.action;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n$document.on( actionMngEvent, selector, function( event, data ) {\n\n\tvar eventType = event.type;\n\n\tif ( actionEvent === event.namespace ) {\n\t\tswitch ( eventType ) {\n\t\tcase "run":\n\t\t\trunAct( event, data );\n\t\t\tbreak;\n\t\tcase "tblfilter":\n\t\t\ttblflrAct( event, data );\n\t\t\tbreak;\n\t\tcase "addClass":\n\t\t\taddClassAct( event, data );\n\t\t\tbreak;\n\t\tcase "removeClass":\n\t\t\tremClassAct( event, data );\n\t\t\tbreak;\n\t\tcase "ajax":\n\t\t\tajaxAct( event, data );\n\t\t\tbreak;\n\t\tcase "patch":\n\t\t\tpatchAct( event, data );\n\t\t\tbreak;\n\t\t}\n\t}\n} );\n\n// Bind the init event of the plugin\n$document.on( "timerpoke.wb " + initEvent, selectorPreset, init );\n\n// Add the timer poke to initialize the plugin\nwb.add( selectorPreset );\n\n} )( jQuery, wb );\n\n/**\n * @title WET-BOEW Data Json [data-json-after], [data-json-append],\n * [data-json-before], [data-json-prepend], [data-json-replace], [data-json-replacewith] and [data-wb-json]\n * @overview Insert content extracted from JSON file.\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @duboisp\n */\n/*global jsonpointer */\n( function( $, window, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-data-json",\n\tshortName = "wb-json",\n\tselectors = [\n\t\t"[data-json-after]",\n\t\t"[data-json-append]",\n\t\t"[data-json-before]",\n\t\t"[data-json-prepend]",\n\t\t"[data-json-replace]",\n\t\t"[data-json-replacewith]",\n\t\t"[data-" + shortName + "]"\n\t],\n\tallowJsonTypes = [ "after", "append", "before", "prepend", "val" ],\n\tallowAttrNames = /(href|src|data-*|pattern|min|max|step|low|high)/,\n\tallowPropNames = /(checked|selected|disabled|required|readonly|multiple|hidden)/,\n\tselectorsLength = selectors.length,\n\tselector = selectors.join( "," ),\n\tinitEvent = "wb-init." + componentName,\n\tupdateEvent = "wb-update." + componentName,\n\tcontentUpdatedEvent = "wb-contentupdated",\n\tdataQueue = componentName + "-queue",\n\t$document = wb.doc,\n\ts,\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered this handler\n\t * @param {string} ajaxType The type of JSON operation, either after, append, before or replace\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\t$elm;\n\n\t\tif ( elm ) {\n\n\t\t\tvar jsonCoreTypes = [\n\t\t\t\t\t"before",\n\t\t\t\t\t"replace",\n\t\t\t\t\t"replacewith",\n\t\t\t\t\t"after",\n\t\t\t\t\t"append",\n\t\t\t\t\t"prepend"\n\t\t\t\t],\n\t\t\t\tjsonType, jsondata,\n\t\t\t\ti, i_len = jsonCoreTypes.length, i_cache,\n\t\t\t\tlstCall = [],\n\t\t\t\turl;\n\n\t\t\t$elm = $( elm );\n\n\t\t\tfor ( i = 0; i !== i_len; i += 1 ) {\n\t\t\t\tjsonType = jsonCoreTypes[ i ];\n\t\t\t\turl = elm.getAttribute( "data-json-" + jsonType );\n\t\t\t\tif ( url !== null ) {\n\t\t\t\t\tlstCall.push( {\n\t\t\t\t\t\ttype: jsonType,\n\t\t\t\t\t\turl: url\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Identify that initialization has completed\n\t\t\twb.ready( $elm, componentName );\n\n\t\t\tjsondata = wb.getData( $elm, shortName );\n\n\t\t\tif ( jsondata && jsondata.url ) {\n\t\t\t\tlstCall.push( jsondata );\n\t\t\t} else if ( jsondata && $.isArray( jsondata ) ) {\n\t\t\t\ti_len = jsondata.length;\n\t\t\t\tfor ( i = 0; i !== i_len; i += 1 ) {\n\t\t\t\t\tlstCall.push( jsondata[ i ] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Save it to the dataJSON object.\n\t\t\t$elm.data( dataQueue, lstCall );\n\n\t\t\ti_len = lstCall.length;\n\t\t\tfor ( i = 0; i !== i_len; i += 1 ) {\n\t\t\t\ti_cache = lstCall[ i ];\n\t\t\t\tloadJSON( elm, i_cache.url, i, i_cache.nocache, i_cache.nocachekey );\n\t\t\t}\n\n\t\t}\n\t},\n\n\tloadJSON = function( elm, url, refId, nocache, nocachekey ) {\n\t\tvar $elm = $( elm ),\n\t\t\tfetchObj = {\n\t\t\t\turl: url,\n\t\t\t\trefId: refId,\n\t\t\t\tnocache: nocache,\n\t\t\t\tnocachekey: nocachekey\n\t\t\t},\n\t\t\tsettings = window[ componentName ],\n\t\t\turlParts;\n\n\t\t// Detect CORS requests\n\t\tif ( settings && ( url.substr( 0, 4 ) === "http" || url.substr( 0, 2 ) === "//" ) ) {\n\t\t\turlParts = wb.getUrlParts( url );\n\t\t\tif ( ( wb.pageUrlParts.protocol !== urlParts.protocol || wb.pageUrlParts.host !== urlParts.host ) && ( !Modernizr.cors || settings.forceCorsFallback ) ) {\n\t\t\t\tif ( typeof settings.corsFallback === "function" ) {\n\t\t\t\t\tfetchObj.dataType = "jsonp";\n\t\t\t\t\tfetchObj.jsonp = "callback";\n\t\t\t\t\tfetchObj = settings.corsFallback( fetchObj );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t$elm.trigger( {\n\t\t\ttype: "json-fetch.wb",\n\t\t\tfetch: fetchObj\n\t\t} );\n\t},\n\n\n\t// Manage JSON value After the json data has been fetched. This function can deal with array.\n\tjsonFetched = function( event ) {\n\n\t\tvar elm = event.target,\n\t\t\t$elm = $( elm ),\n\t\t\tlstCall = $elm.data( dataQueue ),\n\t\t\tfetchObj = event.fetch,\n\t\t\titmSettings = lstCall[ fetchObj.refId ],\n\t\t\tjsonType = itmSettings.type,\n\t\t\tattrname = itmSettings.prop || itmSettings.attr,\n\t\t\tshowEmpty = itmSettings.showempty,\n\t\t\tcontent = fetchObj.response,\n\t\t\ttypeOfContent = typeof content,\n\t\t\tjQueryCaching;\n\n\t\tif ( showEmpty || typeOfContent !== "undefined" ) {\n\n\t\t\tif ( showEmpty && typeOfContent === "undefined" ) {\n\t\t\t\tcontent = "";\n\t\t\t}\n\n\t\t\t//Prevents the force caching of nested resources\n\t\t\tjQueryCaching = jQuery.ajaxSettings.cache;\n\t\t\tjQuery.ajaxSettings.cache = true;\n\n\t\t\t// "replace" and "replaceWith" doesn\'t map to a jQuery function\n\t\t\tif ( !jsonType ) {\n\t\t\t\tjsonType = "template";\n\t\t\t\tapplyTemplate( elm, itmSettings, content );\n\n\t\t\t\t// Trigger wet\n\t\t\t\tif ( itmSettings.trigger ) {\n\t\t\t\t\t$elm\n\t\t\t\t\t\t.find( wb.allSelectors )\n\t\t\t\t\t\t\t.addClass( "wb-init" )\n\t\t\t\t\t\t\t.filter( ":not(#" + elm.id + " .wb-init .wb-init)" )\n\t\t\t\t\t\t\t\t.trigger( "timerpoke.wb" );\n\t\t\t\t}\n\t\t\t} else if ( jsonType === "replace" ) {\n\t\t\t\t$elm.html( content );\n\t\t\t} else if ( jsonType === "replacewith" ) {\n\t\t\t\t$elm.replaceWith( content );\n\t\t\t} else if ( jsonType === "addclass" ) {\n\t\t\t\t$elm.addClass( content );\n\t\t\t} else if ( jsonType === "removeclass" ) {\n\t\t\t\t$elm.removeClass( content );\n\t\t\t} else if ( jsonType === "prop" && attrname && allowPropNames.test( attrname ) ) {\n\t\t\t\t$elm.prop( attrname, content );\n\t\t\t} else if ( jsonType === "attr" && attrname && allowAttrNames.test( attrname ) ) {\n\t\t\t\t$elm.attr( attrname, content );\n\t\t\t} else if ( typeof $elm[ jsonType ] === "function" && allowJsonTypes.indexOf( jsonType ) !== -1 ) {\n\t\t\t\t$elm[ jsonType ]( content );\n\t\t\t} else {\n\t\t\t\tthrow componentName + " do not support type: " + jsonType;\n\t\t\t}\n\n\t\t\t//Resets the initial jQuery caching setting\n\t\t\tjQuery.ajaxSettings.cache = jQueryCaching;\n\n\t\t\t$elm.trigger( contentUpdatedEvent, { "json-type": jsonType, "content": content } );\n\t\t}\n\t},\n\n\t// Apply the template as per the configuration\n\tapplyTemplate = function( elm, settings, content ) {\n\n\t\tvar mapping = settings.mapping || [ {} ],\n\t\t\tmapping_len,\n\t\t\tfilterTrueness = settings.filter || [],\n\t\t\tfilterFaslseness = settings.filternot || [],\n\t\t\tqueryAll = settings.queryall,\n\t\t\ti, i_len, i_cache,\n\t\t\tj, j_cache, j_cache_attr,\n\t\t\tbasePntr,\n\t\t\tclone, selElements,\n\t\t\tcached_node,\n\t\t\tcached_textContent,\n\t\t\tcached_value,\n\t\t\tselectorToClone = settings.tobeclone,\n\t\t\telmClass = elm.className,\n\t\t\telmAppendTo = elm,\n\t\t\tdataTable,\n\t\t\ttemplate = settings.source ? document.querySelector( settings.source ) : elm.querySelector( "template" );\n\n\t\tif ( !$.isArray( content ) ) {\n\t\t\tif ( typeof content !== "object" ) {\n\t\t\t\tcontent = [ content ];\n\t\t\t} else {\n\t\t\t\tcontent = $.map( content, function( val, index ) {\n\t\t\t\t\tif ( typeof val === "object" && !$.isArray( val ) ) {\n\t\t\t\t\t\tif ( !val[ "@id" ] ) {\n\t\t\t\t\t\t\tval[ "@id" ] = index;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tval = {\n\t\t\t\t\t\t\t"@id": index,\n\t\t\t\t\t\t\t"@value": val\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\treturn [ val ];\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\t\ti_len = content.length;\n\n\t\tif ( !$.isArray( mapping ) ) {\n\t\t\tmapping = [ mapping ];\n\t\t}\n\t\tmapping_len = mapping.length;\n\n\t\t// Special support for adding row to a wb-table\n\t\t// Condition must be meet:\n\t\t//  * The element need to be a table\n\t\t//  * Data-table need to be initialized\n\t\t//  * The mapping need to be an array of string\n\t\tif ( elm.tagName === "TABLE" && mapping && elmClass.indexOf( "wb-tables-inited" ) !== -1 && typeof mapping[ 0 ] === "string" ) {\n\t\t\tdataTable = $( elm ).dataTable( { "retrieve": true } ).api();\n\t\t\tfor ( i = 0; i < i_len; i += 1 ) {\n\t\t\t\ti_cache = content[ i ];\n\t\t\t\tif ( filterPassJSON( i_cache, filterTrueness, filterFaslseness ) ) {\n\t\t\t\t\tbasePntr = "/" + i;\n\t\t\t\t\tcached_value = [];\n\t\t\t\t\tfor ( j = 0; j < mapping_len; j += 1 ) {\n\t\t\t\t\t\tcached_value.push( jsonpointer.get( content, basePntr + mapping[ j ] ) );\n\t\t\t\t\t}\n\t\t\t\t\tdataTable.row.add( cached_value );\n\t\t\t\t}\n\t\t\t}\n\t\t\tdataTable.draw();\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !template ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Needed when executing sub-template that wasn\'t polyfill, like in IE11\n\t\tif ( !template.content ) {\n\t\t\twb.tmplPolyfill( template );\n\t\t}\n\n\t\tif ( settings.appendto ) {\n\t\t\telmAppendTo = $( settings.appendto ).get( 0 );\n\t\t}\n\n\t\tfor ( i = 0; i < i_len; i += 1 ) {\n\t\t\ti_cache = content[ i ];\n\n\t\t\tif ( filterPassJSON( i_cache, filterTrueness, filterFaslseness ) ) {\n\n\t\t\t\tbasePntr = "/" + i;\n\n\t\t\t\tif ( !selectorToClone ) {\n\t\t\t\t\tclone = template.content.cloneNode( true );\n\t\t\t\t} else {\n\t\t\t\t\tclone = template.content.querySelector( selectorToClone ).cloneNode( true );\n\t\t\t\t}\n\n\t\t\t\tif ( queryAll ) {\n\t\t\t\t\tselElements = clone.querySelectorAll( queryAll );\n\t\t\t\t}\n\n\t\t\t\tfor ( j = 0; j < mapping_len || j === 0; j += 1 ) {\n\t\t\t\t\tj_cache = mapping[ j ];\n\n\t\t\t\t\t// Get the node used to insert content\n\t\t\t\t\tif ( selElements ) {\n\t\t\t\t\t\tcached_node = selElements[ j ];\n\t\t\t\t\t} else if ( j_cache.selector ) {\n\t\t\t\t\t\tcached_node = clone.querySelector( j_cache.selector );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcached_node = clone;\n\t\t\t\t\t}\n\t\t\t\t\tj_cache_attr = j_cache.attr;\n\t\t\t\t\tif ( j_cache_attr ) {\n\t\t\t\t\t\tif ( !cached_node.hasAttribute( j_cache_attr ) ) {\n\t\t\t\t\t\t\tcached_node.setAttribute( j_cache_attr, "" );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcached_node = cached_node.getAttributeNode( j_cache_attr );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get the value\n\t\t\t\t\tif ( typeof i_cache === "string" ) {\n\t\t\t\t\t\tcached_value = i_cache;\n\t\t\t\t\t} else if ( typeof j_cache === "string" ) {\n\t\t\t\t\t\tcached_value = jsonpointer.get( content, basePntr + j_cache );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcached_value = jsonpointer.get( content, basePntr + j_cache.value );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Placeholder text replacement if any\n\t\t\t\t\tif ( j_cache.placeholder ) {\n\t\t\t\t\t\tcached_textContent = cached_node.textContent || "";\n\t\t\t\t\t\tcached_value = cached_textContent.replace( j_cache.placeholder, cached_value );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the value to the node\n\t\t\t\t\tif ( $.isArray( cached_value ) ) {\n\t\t\t\t\t\tapplyTemplate( cached_node, j_cache, cached_value );\n\t\t\t\t\t} else if ( j_cache.isHTML ) {\n\t\t\t\t\t\tcached_node.innerHTML = cached_value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcached_node.textContent = cached_value;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telmAppendTo.appendChild( clone );\n\t\t\t}\n\t\t}\n\t},\n\n\t// Filtering a JSON\n\t// Return true if trueness && falseness\n\t// Return false if !( trueness && falseness )\n\t// trueness and falseness is an array of { "path": "", "value": "" } object\n\tfilterPassJSON = function( obj, trueness, falseness ) {\n\t\tvar i, i_cache,\n\t\t\ttrueness_len = trueness.length,\n\t\t\tfalseness_len = falseness.length,\n\t\t\tcompareResult = false,\n\t\t\tisEqual;\n\n\t\tif ( trueness_len || falseness_len ) {\n\n\t\t\tfor ( i = 0; i < trueness_len; i += 1 ) {\n\t\t\t\ti_cache = trueness[ i ];\n\t\t\t\tisEqual = _equalsJSON( jsonpointer.get( obj, i_cache.path ), i_cache.value );\n\n\t\t\t\tif ( i_cache.optional ) {\n\t\t\t\t\tcompareResult = compareResult || isEqual;\n\t\t\t\t} else if ( !isEqual ) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tcompareResult = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( trueness_len && !compareResult ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < falseness_len; i += 1 ) {\n\t\t\t\ti_cache = falseness[ i ];\n\t\t\t\tisEqual = _equalsJSON( jsonpointer.get( obj, i_cache.path ), i_cache.value );\n\n\t\t\t\tif ( isEqual && !i_cache.optional || isEqual && i_cache.optional ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn true;\n\t},\n\n\t//\n\t_equalsJSON = function( a, b ) {\n\t\tswitch ( typeof a ) {\n\t\tcase "undefined":\n\t\t\treturn false;\n\t\tcase "boolean":\n\t\tcase "string":\n\t\tcase "number":\n\t\t\treturn a === b;\n\t\tcase "object":\n\t\t\tif ( a === null ) {\n\t\t\t\treturn b === null;\n\t\t\t}\n\t\t\tif ( $.isArray( a ) ) {\n\t\t\t\tif (  $.isArray( b ) || a.length !== b.length ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tfor ( var i = 0, l = a.length; i < l; i++ ) {\n\t\t\t\t\tif ( !_equalsJSON( a[ i ], b[ i ] ) ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvar bKeys = _objectKeys( b ),\n\t\t\t\tbLength = bKeys.length;\n\t\t\tif ( _objectKeys( a ).length !== bLength ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor ( var i = 0; i < bLength; i++ ) {\n\t\t\t\tif ( !_equalsJSON( a[ i ], b[ i ] ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t},\n\t_objectKeys = function( obj ) {\n\t\tif ( $.isArray( obj ) ) {\n\t\t\tvar keys = new Array( obj.length );\n\t\t\tfor ( var k = 0; k < keys.length; k++ ) {\n\t\t\t\tkeys[ k ] = "" + k;\n\t\t\t}\n\t\t\treturn keys;\n\t\t}\n\t\tif ( Object.keys ) {\n\t\t\treturn Object.keys( obj );\n\t\t}\n\t\tvar keys = [];\n\t\tfor ( var i in obj ) {\n\t\t\tif ( obj.hasOwnProperty( i ) ) {\n\t\t\t\tkeys.push( i );\n\t\t\t}\n\t\t}\n\t\treturn keys;\n\t},\n\n\t// Manage JSON value After the json data has been fetched\n\tjsonUpdate = function( event ) {\n\t\tvar elm = event.target,\n\t\t\t$elm = $( elm ),\n\t\t\tlstCall = $elm.data( dataQueue ),\n\t\t\trefId = lstCall.length,\n\t\t\twbJsonConfig = event[ "wb-json" ];\n\n\t\tif ( !( wbJsonConfig.url && ( wbJsonConfig.type || wbJsonConfig.source ) ) ) {\n\t\t\tthrow "Data JSON update not configured properly";\n\t\t}\n\n\t\tlstCall.push( wbJsonConfig );\n\t\t$elm.data( dataQueue, lstCall );\n\n\t\tloadJSON( elm, wbJsonConfig.url, refId );\n\t};\n\n$document.on( "json-failed.wb", selector, function( ) {\n\tthrow "Bad JSON Fetched from url in " + componentName;\n} );\n\n// Load template polyfill\nModernizr.load( {\n\ttest: ( "content" in document.createElement( "template" ) ),\n\tnope: "site!deps/template" + wb.getMode() + ".js"\n} );\n\n$document.on( "timerpoke.wb " + initEvent + " " + updateEvent + " json-fetched.wb", selector, function( event ) {\n\n\tif ( event.currentTarget === event.target ) {\n\t\tswitch ( event.type ) {\n\n\t\tcase "timerpoke":\n\t\tcase "wb-init":\n\t\t\tinit( event );\n\t\t\tbreak;\n\t\tcase "wb-update":\n\t\t\tjsonUpdate( event );\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjsonFetched( event );\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn true;\n} );\n\n// Add the timerpoke to initialize the plugin\nfor ( s = 0; s !== selectorsLength; s += 1 ) {\n\twb.add( selectors[ s ] );\n}\n\n} )( jQuery, window, wb );\n\n/**\n * @title WET-BOEW Template polyfill\n * @overview The <template> element hold elements for Javascript and templating usage. Based on code from http://ironlasso.com/template-tag-polyfill-for-internet-explorer/\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @duboisp\n */\n( function( $, document, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the polyfill - meaning that they will be initialized once per page.\n * This polyfill is mostly used to support <template> element in IE11\n */\nvar componentName = "wb-template",\n\tselector = "template",\n\tinitEvent = "wb-init." + componentName,\n\t$document = wb.doc,\n\n\t/**\n\t * @method polyfill\n\t * @param {DOM element} element that we need to apply the polyfill\n\t */\n\tpolyfill = function( elm ) {\n\n\t\tif ( elm.content ) {\n\t\t\treturn;\n\t\t}\n\t\tvar elPlate = elm,\n\t\t\tqContent,\n\t\t\tdocContent;\n\n\t\tqContent = elPlate.childNodes;\n\t\tdocContent = document.createDocumentFragment();\n\n\t\twhile ( qContent[ 0 ] ) {\n\t\t\tdocContent.appendChild( qContent[ 0 ] );\n\t\t}\n\n\t\telPlate.content = docContent;\n\n\t},\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector );\n\n\t\tif ( elm ) {\n\n\t\t\tpolyfill( elm );\n\n\t\t\t// Identify that initialization has completed\n\t\t\twb.ready( $( elm ), componentName );\n\t\t}\n\t};\n\n// Make it available of when template element is needed on the fly, like subtemplate support in IE11\nwb.tmplPolyfill = polyfill;\n\n// Bind the events of the polyfill\n$document.on( "timerpoke.wb " + initEvent, selector, init );\n\n// Add the timer poke to initialize the polyfill\nwb.add( selector );\n\n} )( jQuery, document, wb );\n\n/**\n * @title WET-BOEW URL mapping\n * @overview Execute pre-configured action based on url query string\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @duboisp\n */\n( function( $, window, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-doaction",\n\tselector = "a[data-" + componentName + "],button[data-" + componentName + "]",\n\trunActions = "do.wb-actionmng",\n\t$document = wb.doc;\n\n$document.on( "click", selector, function( event ) {\n\n\tvar elm = event.target,\n\t\t$elm = $( elm );\n\n\t// Get the selector when click on a child of it, like click on a figure wrapped in a anchor with doaction.\n\tif ( event.currentTarget !== event.target ) {\n\t\t$elm = $elm.parentsUntil( "main", selector );\n\t\telm = $elm[ 0 ];\n\t}\n\n\t// Ensure that we only execute for anchor and button\n\tif ( elm.nodeName === "BUTTON" || elm.nodeName === "A" ) {\n\n\t\tif ( wb.isReady ) {\n\n\t\t\t// Execute actions if any.\n\t\t\t$elm.trigger( {\n\t\t\t\ttype: runActions,\n\t\t\t\tactions: wb.getData( $elm, componentName )\n\t\t\t} );\n\t\t} else {\n\n\t\t\t// Execution of the action after WET will be ready\n\t\t\t$document.one( "wb-ready.wb", function( ) {\n\t\t\t\t$elm.trigger( {\n\t\t\t\t\ttype: runActions,\n\t\t\t\t\tactions: wb.getData( $elm, componentName )\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\t\treturn false;\n\t}\n} );\n\n\n} )( jQuery, window, wb );\n\n/**\n * @title WET-BOEW Field Flow\n * @overview Transform a basic list into a selectable list.\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @duboisp\n */\n( function( $, document, wb ) {\n"use strict";\n\nvar componentName = "wb-fieldflow",\n\tselector = "." + componentName,\n\tformComponent = componentName + "-form",\n\tsubComponentName = componentName + "-sub",\n\tcrtlSelectClass = componentName + "-init",\n\tcrtlSelectSelector = "." + crtlSelectClass,\n\tbasenameInput = componentName + wb.getId(),\n\tbasenameInputSelector = "[name^=" + basenameInput + "]",\n\tlabelClass = componentName + "-label",\n\theaderClass = componentName + "-header",\n\tselectorForm = "." + formComponent,\n\tinitEvent = "wb-init" + selector,\n\tdrawEvent = "draw" + selector,\n\tactionEvent = "action" + selector,\n\tsubmitEvent = "submit" + selector,\n\tsubmitedEvent = "submited" + selector,\n\treadyEvent = "ready" + selector,\n\tcleanEvent = "clean" + selector,\n\tresetActionEvent = "reset" + selector,\n\tcreateCtrlEvent = "createctrl" + selector,\n\tregisterJQData = componentName + "-register", // Data that contain all the component registered (to the form element and component), used for executing action upon submit\n\tregisterHdnFld = componentName + "-hdnfld",\n\tconfigData = componentName + "-config",\n\tpushJQData =  componentName + "-push",\n\tsubmitJQData =  componentName + "-submit", // List of action to perform upon form submission\n\tactionData =  componentName + "-action", // temp for code transition\n\toriginData =  componentName + "-origin", // To carry the plugin origin ID, any implementation of "createCtrlEvent" must set that option.\n\tsourceDataAttr =  "data-" + componentName + "-source",\n\tflagOptValueData =  componentName + "-flagoptvalue",\n\t$document = wb.doc,\n\tdefaults = {\n\t\ttoggle: {\n\t\t\tstateOn: "visible", // For toggle plugin\n\t\t\tstateOff: "hidden"  // For toggle plugin\n\t\t},\n\t\ti18n:\n\t\t{\n\t\t\t"en": {\n\t\t\t\tbtn: "Continue", // Action button\n\t\t\t\tdefaultsel: "Make your selection...", // text use for the first empty select\n\t\t\t\trequired: "required"// text for the required label\n\t\t\t},\n\t\t\t"fr": {\n\t\t\t\tbtn: "Allez",\n\t\t\t\tdefaultsel: "Sélectionnez dans la liste...", // text use for the first empty select\n\t\t\t\trequired: "obligatoire" // text for the required label\n\t\t\t}\n\t\t},\n\t\taction: "ajax",\n\t\tprop: "url"\n\t},\n\tfieldflowActionsEvents = [\n\t\t[\n\t\t\t"redir",\n\t\t\t"query",\n\t\t\t"ajax",\n\t\t\t"addClass",\n\t\t\t"removeClass",\n\t\t\t"removeClass",\n\t\t\t"append",\n\t\t\t"tblfilter",\n\t\t\t"toggle"\n\t\t].join( "." + actionEvent + " " ) + "." + actionEvent,\n\t\t[\n\t\t\t"ajax",\n\t\t\t"toggle",\n\t\t\t"redir",\n\t\t\t"addClass",\n\t\t\t"removeClass"\n\t\t].join( "." + submitEvent + " " ) + "." + submitEvent,\n\t\t[\n\t\t\t"tblfilter",\n\t\t\tcomponentName\n\t\t].join( "." + drawEvent + " " ) + "." + drawEvent,\n\t\t[\n\t\t\t"select",\n\t\t\t"checkbox",\n\t\t\t"radio"\n\t\t].join( "." + createCtrlEvent + " " ) + "." + createCtrlEvent\n\t].join( " " ),\n\n\t/**\n\t* @method init\n\t* @param {jQuery Event} event Event that triggered the function call\n\t*/\n\tinit = function( event ) {\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\t$elm, elmId,\n\t\t\twbDataElm,\n\t\t\tconfig,\n\t\t\ti18n;\n\n\t\tif ( elm ) {\n\t\t\t$elm = $( elm );\n\t\t\telmId = elm.id;\n\n\t\t\t// Set default i18n information\n\t\t\tif ( defaults.i18n[ wb.lang ] ) {\n\t\t\t\tdefaults.i18n = defaults.i18n[ wb.lang ];\n\t\t\t}\n\n\t\t\t// Extend this data with the contextual default\n\t\t\twbDataElm = wb.getData( $elm, componentName );\n\t\t\tif ( wbDataElm && wbDataElm.i18n ) {\n\t\t\t\twbDataElm.i18n = $.extend( {}, defaults.i18n, wbDataElm.i18n );\n\t\t\t}\n\t\t\tconfig = $.extend( {}, defaults, wbDataElm );\n\n\t\t\tif ( config.defaultIfNone && !$.isArray( config.defaultIfNone ) ) {\n\t\t\t\tconfig.defaultIfNone = [ config.defaultIfNone ];\n\t\t\t}\n\n\t\t\t// Set the data to the component, if other event need to have access to it.\n\t\t\t$elm.data( configData, config );\n\t\t\ti18n = config.i18n;\n\n\t\t\t// Add startWith function (ref: https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/String/startsWith)\n\t\t\tif ( !String.prototype.startsWith ) {\n\t\t\t\tString.prototype.startsWith = function( searchString, position ) {\n\t\t\t\t\tposition = position || 0;\n\t\t\t\t\treturn this.substr( position, searchString.length ) === searchString;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Transform the list into a select, use the first paragrap content for the label, and extract for i18n the name of the button action.\n\t\t\tvar bodyID = wb.getId(),\n\t\t\t\tstdOut,\n\t\t\t\tformElm, $form;\n\n\t\t\tif ( config.noForm ) {\n\t\t\t\tstdOut = "<div class=\'mrgn-tp-md\'><div id=\'" + bodyID + "\'></div></div>";\n\n\t\t\t\t// Need to add the class="formComponent" to the div that wrap the form element.\n\t\t\t\tformElm = elm.parentElement;\n\t\t\t\twhile ( formElm.nodeName !== "FORM" ) {\n\t\t\t\t\tformElm = formElm.parentElement;\n\t\t\t\t}\n\t\t\t\t$( formElm.parentElement ).addClass( formComponent );\n\t\t\t} else {\n\t\t\t\tstdOut = "<div class=\'wb-frmvld " + formComponent + "\'><form><div id=\'" + bodyID + "\'>";\n\t\t\t\tstdOut = stdOut + "</div><input type=\\"submit\\" value=\\"" + i18n.btn + "\\" class=\\"btn btn-primary mrgn-bttm-md\\" /> </form></div>";\n\t\t\t}\n\t\t\t$elm.addClass( "hidden" );\n\t\t\tstdOut = $( stdOut );\n\t\t\t$elm.after( stdOut );\n\n\t\t\tif ( !config.noForm ) {\n\t\t\t\tformElm = stdOut.find( "form" );\n\t\t\t\tstdOut.trigger( "wb-init.wb-frmvld" );\n\t\t\t}\n\n\t\t\t$form = $( formElm );\n\n\t\t\t// Register this plugin within the form, this is to manage form submission\n\t\t\tpushData( $form, registerJQData, elmId );\n\n\t\t\tif ( !config.outputctnrid ) { // Output container ID\n\t\t\t\tconfig.outputctnrid = bodyID;\n\t\t\t}\n\n\t\t\tif ( !config.source ) {\n\t\t\t\tconfig.source = elm; // We assume th container have the source\n\t\t\t}\n\n\t\t\tif ( !config.srctype ) {\n\t\t\t\tconfig.srctype = componentName;\n\t\t\t}\n\n\t\t\tconfig.inline = !!config.inline;\n\n\t\t\t// Trigger the drop down loading\n\t\t\t$elm.trigger( config.srctype + "." + drawEvent, config );\n\n\t\t\t// Do requested DOM manipulation\n\t\t\tif ( config.unhideelm ) {\n\t\t\t\t$( config.unhideelm ).removeClass( "hidden" );\n\t\t\t}\n\t\t\tif ( config.hideelm ) {\n\t\t\t\t$( config.hideelm ).addClass( "hidden" );\n\t\t\t}\n\n\t\t\t// Identify that initialization has completed\n\t\t\twb.ready( $elm, componentName );\n\n\t\t\tif ( config.ext ) {\n\t\t\t\tconfig.form = $form.get( 0 );\n\t\t\t\t$elm.trigger( config.ext + "." + readyEvent, config );\n\t\t\t}\n\t\t}\n\t},\n\tpushData = function( $elm, prop, data, reset ) {\n\t\tvar dtCache = $elm.data( prop );\n\t\tif ( !dtCache || reset ) {\n\t\t\tdtCache = [];\n\t\t}\n\t\tdtCache.push( data );\n\t\treturn $elm.data( prop, dtCache );\n\t},\n\tsubRedir = function( event, data ) {\n\n\t\tvar form = data.form,\n\t\t\turl = data.url;\n\n\t\tif ( url ) {\n\t\t\tform.setAttribute( "action", url );\n\t\t}\n\t},\n\tactQuery = function( event, data ) {\n\t\tvar $selectElm = data.$selElm,\n\t\t\tfieldName = data.name,\n\t\t\tfieldValue = data.value;\n\n\t\tif ( fieldName ) {\n\t\t\tdata.provEvt.setAttribute( "name", fieldName );\n\t\t}\n\t\tif ( fieldValue ) {\n\t\t\t$selectElm.val( fieldValue );\n\t\t}\n\n\t\t// Add a flag to know the option value was inserted\n\t\t$selectElm.attr( "data-" + flagOptValueData, flagOptValueData );\n\t},\n\tactAjax = function( event, data ) {\n\t\tvar provEvt = data.provEvt,\n\t\t\t$container;\n\n\t\tif ( !data.live ) {\n\t\t\tdata.preventSubmit = true;\n\t\t\tpushData( $( provEvt ), submitJQData, data );\n\t\t} else {\n\t\t\tif ( !data.container ) {\n\n\t\t\t\t// Create the container next to component\n\t\t\t\t$container = $( "<div></div>" );\n\t\t\t\t$( provEvt.parentNode ).append( $container );\n\t\t\t\tdata.container = $container.get( 0 );\n\t\t\t}\n\t\t\t$( event.target ).trigger( "ajax." + submitEvent, data );\n\t\t}\n\t},\n\tsubAjax = function( event, data ) {\n\t\tvar $container, containerID, ajxType,\n\t\t\tcleanSelector = data.clean;\n\n\t\tif ( !data.container ) {\n\t\t\tcontainerID = wb.getId();\n\t\t\t$container = $( "<div id=\'" + containerID + "\'></div>" );\n\t\t\t$( data.form ).append( $container );\n\t\t\tcleanSelector = "#" + containerID;\n\t\t} else {\n\t\t\t$container = $( data.container );\n\t\t}\n\n\t\tif ( cleanSelector ) {\n\t\t\t$( data.origin ).one( cleanEvent, function( ) {\n\t\t\t\t$( cleanSelector ).empty();\n\t\t\t} );\n\t\t}\n\n\t\tif ( data.trigger ) {\n\t\t\t$container.attr( "data-trigger-wet", "true" );\n\t\t}\n\n\t\tajxType = data.type ? data.type : "replace";\n\t\t$container.attr( "data-ajax-" + ajxType, data.url );\n\n\t\t$container.one( "wb-contentupdated", function( event, data ) {\n\t\t\tvar updtElm = event.currentTarget,\n\t\t\t\ttrigger = updtElm.getAttribute( "data-trigger-wet" );\n\n\t\t\tupdtElm.removeAttribute( "data-ajax-" + data[ "ajax-type" ] );\n\t\t\tif ( trigger ) {\n\t\t\t\t$( updtElm )\n\t\t\t\t\t.find( wb.allSelectors )\n\t\t\t\t\t\t.addClass( "wb-init" )\n\t\t\t\t\t\t.filter( ":not(#" + updtElm.id + " .wb-init .wb-init)" )\n\t\t\t\t\t\t\t.trigger( "timerpoke.wb" );\n\t\t\t\tupdtElm.removeAttribute( "data-trigger-wet" );\n\t\t\t}\n\t\t} );\n\t\t$container.trigger( "wb-update.wb-data-ajax" );\n\t},\n\tsubToggle = function( event, data ) {\n\t\tvar $origin = $( data.origin ),\n\t\t\tconfig = $( event.target ).data( configData ),\n\t\t\ttoggleOpts = data.toggle;\n\n\n\t\t// For simple toggle call syntax\n\t\tif ( toggleOpts && typeof toggleOpts === "string" ) {\n\t\t\ttoggleOpts = { selector: toggleOpts };\n\t\t}\n\t\ttoggleOpts = $.extend( {}, toggleOpts, config.toggle );\n\n\t\t// Doing an add and remove "wb-toggle" class in order to avoid the click event added by toggle plugin\n\t\t$origin.addClass( "wb-toggle" );\n\t\t$origin.trigger( "toggle.wb-toggle", toggleOpts );\n\n\t\t// Set the cleaning task\n\t\ttoggleOpts.type = "off";\n\t\t$origin.one( cleanEvent, function( ) {\n\t\t\t$origin.addClass( "wb-toggle" );\n\t\t\t$origin.trigger( "toggle.wb-toggle", toggleOpts );\n\t\t\t$origin.removeClass( "wb-toggle" );\n\t\t} );\n\t},\n\tactAppend = function( event, data ) {\n\t\tif ( event.namespace === actionEvent ) {\n\t\t\tvar srctype = data.srctype ? data.srctype : componentName;\n\t\t\tdata.container = data.provEvt.parentNode.id;\n\t\t\tif ( !data.source ) {\n\t\t\t\tthrow "A source is required to append a field flow control.";\n\t\t\t}\n\t\t\t$( event.currentTarget ).trigger( srctype + "." + drawEvent, data );\n\t\t}\n\t},\n\tactTblFilter = function( event, data ) {\n\t\tif ( event.namespace === actionEvent ) {\n\t\t\tvar sourceSelector = data.source,\n\t\t\t\t$datatable = $( sourceSelector ).dataTable( { "retrieve": true } ).api(),\n\t\t\t\t$dtSelectedColumn,\n\t\t\t\tcolumn = data.column,\n\t\t\t\tcolInt = parseInt( column, 10 ),\n\t\t\t\tregex = !!data.regex,\n\t\t\t\tsmart = ( !data.smart ) ? true : !!data.smart,\n\t\t\t\tcaseinsen = ( !data.caseinsen ) ? true : !!data.caseinsen;\n\n\t\t\tcolumn = ( colInt === true ) ? colInt : column;\n\n\t\t\t$dtSelectedColumn = $datatable.column( column );\n\n\t\t\t$dtSelectedColumn.search( data.value, regex, smart, caseinsen ).draw();\n\n\t\t\t// Add a clean up task\n\t\t\t$( data.provEvt ).one( cleanEvent, function( ) {\n\t\t\t\t$dtSelectedColumn.search( "" ).draw();\n\t\t\t} );\n\n\t\t}\n\t},\n\tdrwTblFilter = function( event, data ) {\n\t\tif ( event.namespace === drawEvent ) {\n\t\t\tvar selColumn = data.column, // (integer/datatable column selector)\n\t\t\t\tcsvExtract = data.csvextract, // (true|false) assume items are in CSV format instead of being inside "li" elements\n\t\t\t\t$column,\n\t\t\t\tsourceSelector = data.source,\n\t\t\t\t$source = $( sourceSelector ),\n\t\t\t\t$datatable,\n\t\t\t\tarrData, $listItem,\n\t\t\t\ti, i_len,\n\t\t\t\tj, j_len,\n\t\t\t\titems = [ ],\n\t\t\t\tcur_itm,\n\t\t\t\tprefLabel = data.label,\n\t\t\t\tdefaultSelectedLabel = data.defaultselectedlabel,\n\t\t\t\tlblselector = data.lblselector,\n\t\t\t\tfilterSequence = data.fltrseq ? data.fltrseq : [ ],\n\t\t\t\tlimit = data.limit ? data.limit : 10,\n\t\t\t\tfirstFilterSeq,\n\t\t\t\tactionItm, filterItm,\n\t\t\t\trenderas;\n\n\t\t\t// Check if the datatable has been loaded, if not we will wait until it is.\n\t\t\tif ( !$source.hasClass( "wb-tables-inited" ) ) {\n\t\t\t\t$source.one( "wb-ready.wb-tables", function() {\n\t\t\t\t\t$( event.target ).trigger( "tblfilter." + drawEvent, data );\n\t\t\t\t} );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$datatable = $source.dataTable( { "retrieve": true } ).api();\n\n\t\t\tif ( $datatable.rows( { "search": "applied" } ).data().length <= limit  ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\trenderas = data.renderas ? data.renderas : "select"; // Default it will render as select\n\n\t\t\tif ( !selColumn && filterSequence.length ) {\n\t\t\t\tcur_itm = filterSequence.shift();\n\t\t\t\tif ( !cur_itm.column ) {\n\t\t\t\t\tthrow "Column is undefined in the filter sequence";\n\t\t\t\t}\n\t\t\t\tselColumn = cur_itm.column;\n\t\t\t\tcsvExtract = cur_itm.csvextract;\n\t\t\t\tdefaultSelectedLabel = cur_itm.defaultselectedlabel;\n\t\t\t\tprefLabel = cur_itm.label;\n\t\t\t\tlblselector = cur_itm.lblselector;\n\t\t\t}\n\n\t\t\t$column = $datatable.column( selColumn, { "search": "applied" } );\n\n\t\t\t// Get the items\n\t\t\tif ( csvExtract ) {\n\t\t\t\tarrData = $column.data();\n\t\t\t\tfor ( i = 0, i_len = arrData.length; i !== i_len; i += 1 ) {\n\t\t\t\t\titems = items.concat( arrData[ i ].split( "," ) );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tarrData = $column.nodes();\n\t\t\t\tfor ( i = 0, i_len = arrData.length; i !== i_len; i += 1 ) {\n\t\t\t\t\t$listItem = $( arrData[ i ] ).find( "li" );\n\t\t\t\t\tfor ( j = 0, j_len = $listItem.length; j !== j_len; j += 1 ) {\n\t\t\t\t\t\titems.push( $( $listItem[ j ] ).text() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\titems = items.sort().filter( function( item, pos, ary ) {\n\t\t\t\treturn !pos || item !== ary[ pos - 1 ];\n\t\t\t} );\n\n\t\t\tvar elm = event.target,\n\t\t\t\t$elm = $( elm ),\n\t\t\t\titemsToCreate = [ ],\n\t\t\t\tpushAction = data.actions ? data.actions : [ ];\n\n\t\t\tif ( filterSequence.length ) {\n\t\t\t\tfirstFilterSeq = filterSequence[ 0 ];\n\t\t\t\tfilterItm = {\n\t\t\t\t\taction: "append",\n\t\t\t\t\tsrctype: "tblfilter",\n\t\t\t\t\tsource: sourceSelector,\n\t\t\t\t\trenderas: firstFilterSeq.renderas ? firstFilterSeq.renderas : renderas,\n\t\t\t\t\tfltrseq: filterSequence,\n\t\t\t\t\tlimit: limit\n\t\t\t\t};\n\t\t\t}\n\t\t\tfor ( i = 0, i_len = items.length; i !== i_len; i += 1 ) {\n\t\t\t\tcur_itm = items[ i ];\n\t\t\t\tactionItm = {\n\t\t\t\t\tlabel: cur_itm,\n\t\t\t\t\tactions: [\n\t\t\t\t\t\t{ // Set an action upon item selection\n\t\t\t\t\t\t\taction: "tblfilter",\n\t\t\t\t\t\t\tsource: sourceSelector,\n\t\t\t\t\t\t\tcolumn: selColumn,\n\t\t\t\t\t\t\tvalue: cur_itm\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t};\n\t\t\t\tif ( filterItm ) {\n\t\t\t\t\tactionItm.actions.push( filterItm );\n\t\t\t\t}\n\t\t\t\titemsToCreate.push( actionItm );\n\t\t\t}\n\n\t\t\tif ( !prefLabel ) {\n\t\t\t\tprefLabel = $column.header().textContent;\n\t\t\t}\n\n\t\t\tif ( !data.outputctnrid ) {\n\t\t\t\tdata.outputctnrid = data.provEvt.parentElement.id;\n\t\t\t}\n\n\t\t\t$elm.trigger( renderas + "." + createCtrlEvent, {\n\t\t\t\tactions: pushAction,\n\t\t\t\tsource: $source.get( 0 ),\n\t\t\t\toutputctnrid: data.outputctnrid,\n\t\t\t\tlabel: prefLabel,\n\t\t\t\tdefaultselectedlabel: defaultSelectedLabel,\n\t\t\t\tlblselector: lblselector,\n\t\t\t\titems: itemsToCreate,\n\t\t\t\tinline: data.inline\n\t\t\t} );\n\n\t\t}\n\t},\n\tdrwFieldflow = function( event, data ) {\n\t\tif ( event.namespace === drawEvent ) {\n\t\t\tvar elm = event.target,\n\t\t\t\t$elm = $( elm ),\n\t\t\t\twbDataElm,\n\t\t\t\t$source = $( data.source ),\n\t\t\t\tsource = $source.get( 0 ),\n\t\t\t\t$labelExplicit, $firstChild,\n\t\t\t\tlabelSelector = data.lblselector || "." + labelClass,\n\t\t\t\tlabelTxt,\n\t\t\t\titmSelector = data.itmselector || "ul:first() > li", $items,\n\t\t\t\tactions,\n\t\t\t\trenderas;\n\n\t\t\t// Extend if it is a sub-component\n\t\t\tif ( $source.hasClass( subComponentName ) ) {\n\t\t\t\twbDataElm = wb.getData( $source, componentName );\n\t\t\t\t$source.data( configData, wbDataElm );\n\t\t\t\tdata = $.extend( {}, data, wbDataElm );\n\t\t\t}\n\n\t\t\tactions = data.actions || [ ];\n\t\t\trenderas = data.renderas ? data.renderas : "select"; // Default it will render as select\n\n\t\t\t// Check if the first node is a div and contain the label.\n\t\t\tif ( !source.id ) {\n\t\t\t\tsource.id = wb.getId();\n\t\t\t}\n\t\t\t$firstChild = $source.children().first();\n\n\t\t\tif ( !$firstChild.hasClass( headerClass ) ) {\n\n\t\t\t\t// Only use what defined as the label, nothing else\n\t\t\t\t$labelExplicit = $firstChild.find( labelSelector );\n\t\t\t\tif ( $labelExplicit.length ) {\n\t\t\t\t\tlabelTxt = $labelExplicit.html();\n\t\t\t\t} else {\n\t\t\t\t\tlabelTxt = $source.find( "> p" ).html();\n\t\t\t\t}\n\t\t\t\tlabelSelector = null; // unset the label selector because it not needed for the control creation\n\t\t\t} else {\n\t\t\t\tlabelTxt = $firstChild.html();\n\t\t\t\titmSelector = "." + headerClass + " + " + itmSelector;\n\t\t\t}\n\n\t\t\t$items = getItemsData( $source.find( itmSelector ) );\n\n\t\t\tif ( !data.outputctnrid ) {\n\t\t\t\tdata.outputctnrid = data.provEvt.parentElement.id;\n\t\t\t}\n\n\t\t\t$elm.trigger( renderas + "." + createCtrlEvent, {\n\t\t\t\tactions: actions,\n\t\t\t\tsource: source,\n\t\t\t\tattributes: data.attributes,\n\t\t\t\toutputctnrid: data.outputctnrid,\n\t\t\t\tlabel: labelTxt,\n\t\t\t\tlblselector: labelSelector,\n\t\t\t\tdefaultselectedlabel: data.defaultselectedlabel,\n\t\t\t\trequired: !!!data.isoptional,\n\t\t\t\tnoreqlabel: data.noreqlabel,\n\t\t\t\titems: $items,\n\t\t\t\tinline: data.inline\n\t\t\t} );\n\t\t}\n\t},\n\tctrlSelect = function( event, data ) {\n\t\tvar bodyId = data.outputctnrid,\n\t\t\t$body = $( "#" + bodyId ),\n\t\t\tactions = data.actions,\n\t\t\tlblselector = data.lblselector,\n\t\t\tisReq = !!data.required,\n\t\t\tuseReqLabel = !!!data.noreqlabel,\n\t\t\titems = data.items,\n\t\t\telm = event.target,\n\t\t\t$elm = $( elm ),\n\t\t\tsource = data.source,\n\t\t\tattributes = data.attributes,\n\t\t\ti18n = $elm.data( configData ).i18n,\n\t\t\tautoID = wb.getId(),\n\t\t\tlabelPrefix = "<label for=\'" + autoID + "\'",\n\t\t\tlabelSuffix = "</span>",\n\t\t\t$out, $tmpLabel,\n\t\t\tselectOut, $selectOut,\n\t\t\tdefaultSelectedLabel = data.defaultselectedlabel ? data.defaultselectedlabel : i18n.defaultsel,\n\t\t\ti, i_len, j, j_len, cur_itm;\n\n\t\t// Create the label\n\t\tif ( isReq && useReqLabel ) {\n\t\t\tlabelPrefix += " class=\'required\'";\n\t\t\tlabelSuffix += " <strong class=\'required\'>(" + i18n.required + ")</strong>";\n\t\t}\n\t\tlabelPrefix += "><span class=\'field-name\'>";\n\t\tlabelSuffix += "</label>";\n\n\t\tif ( !lblselector ) {\n\t\t\t$out = $( labelPrefix + data.label + labelSuffix );\n\t\t} else {\n\t\t\t$out = $( "<div>" + data.label + "</div>" );\n\t\t\t$tmpLabel = $out.find( lblselector );\n\t\t\t$tmpLabel.html( labelPrefix + $tmpLabel.html() + labelSuffix );\n\t\t}\n\n\t\t// Create the select\n\t\tselectOut = "<select id=\'" + autoID + "\' name=\'" + basenameInput + autoID + "\' class=\'full-width form-control mrgn-bttm-md " + crtlSelectClass + "\' data-" + originData + "=\'" + elm.id + "\' " + sourceDataAttr + "=\'" + source.id + "\'";\n\t\tif ( isReq ) {\n\t\t\tselectOut += " required";\n\t\t}\n\t\tif ( attributes && typeof attributes === "object" ) {\n\t\t\tfor ( i in attributes ) {\n\t\t\t\tif ( attributes.hasOwnProperty( i ) ) {\n\t\t\t\t\tselectOut += " " + i + "=\'" + attributes[ i ] + "\'";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tselectOut += "><option value=\'\'>" + defaultSelectedLabel + "</option>";\n\t\tfor ( i = 0, i_len = items.length; i !== i_len; i += 1 ) {\n\t\t\tcur_itm = items[ i ];\n\n\t\t\tif ( !cur_itm.group ) {\n\t\t\t\tselectOut += buildSelectOption( cur_itm );\n\t\t\t} else {\n\n\t\t\t\t// We have a group of sub-items, the cur_itm are a group\n\t\t\t\tselectOut += "<optgroup label=\'" + cur_itm.label + "\'>";\n\t\t\t\tj_len = cur_itm.group.length;\n\t\t\t\tfor ( j = 0; j !== j_len; j += 1 ) {\n\t\t\t\t\tselectOut += buildSelectOption( cur_itm.group[ j ] );\n\t\t\t\t}\n\t\t\t\tselectOut += "</optgroup>";\n\t\t\t}\n\t\t}\n\t\tselectOut += "</select>";\n\t\t$selectOut = $( selectOut );\n\n\t\t$body.append( $out ).append( $selectOut );\n\n\t\t// Set post action if any\n\t\tif ( actions && actions.length > 0 ) {\n\t\t\t$selectOut.data( pushJQData, actions );\n\t\t}\n\n\t\t// Register this control\n\t\tpushData( $elm, registerJQData, autoID );\n\t},\n\tctrlChkbxRad = function( event, data ) {\n\t\tvar bodyId = data.outputctnrid,\n\t\t\tactions = data.actions,\n\t\t\tlblselector = data.lblselector,\n\t\t\tisReq = !!data.required,\n\t\t\tuseReqLabel = !!!data.noreqlabel,\n\t\t\titems = data.items,\n\t\t\telm = event.target,\n\t\t\t$elm = $( elm ),\n\t\t\tsource = data.source,\n\t\t\ti18n = $elm.data( configData ).i18n,\n\t\t\tattributes = data.attributes,\n\t\t\tctrlID = wb.getId(),\n\t\t\tfieldsetPrefix = "<legend class=\'h5 ",\n\t\t\tfieldsetSuffix = "</span>",\n\t\t\tfieldsetHTML = "<fieldset id=\'" + ctrlID + "\' data-" + originData + "=\'" + elm.id + "\' " + sourceDataAttr + "=\'" + source.id + "\' class=\'" + crtlSelectClass + " mrgn-bttm-md\'",\n\t\t\t$out,\n\t\t\t$tmpLabel, $cloneLbl, $prevContent,\n\t\t\tradCheckOut = "",\n\t\t\ttypeRadCheck = data.typeRadCheck,\n\t\t\tisInline = data.inline,\n\t\t\tfieldName = basenameInput + ctrlID,\n\t\t\ti, i_len, j, j_len, cur_itm;\n\n\t\tif ( attributes && typeof attributes === "object" ) {\n\t\t\tfor ( i in attributes ) {\n\t\t\t\tif ( attributes.hasOwnProperty( i ) ) {\n\t\t\t\t\tfieldsetHTML += " " + i + "=\'" + attributes[ i ] + "\'";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$out = $( fieldsetHTML + "></fieldset>" );\n\n\t\t// Create the legend\n\t\tif ( isReq && useReqLabel ) {\n\t\t\tfieldsetPrefix += " required";\n\t\t\tfieldsetSuffix += " <strong class=\'required\'>(" + i18n.required + ")</strong>";\n\t\t}\n\t\tfieldsetPrefix += "\'>";\n\t\tfieldsetSuffix += "</legend>";\n\t\tif ( !lblselector ) {\n\t\t\t$out.append( $( fieldsetPrefix + data.label + fieldsetSuffix ) );\n\t\t} else {\n\t\t\t$cloneLbl = $( "<div>" + data.label + "</div>" );\n\t\t\t$tmpLabel = $cloneLbl.find( lblselector );\n\t\t\t$out.append( ( fieldsetPrefix + $tmpLabel.html() + fieldsetSuffix ) )\n\t\t\t\t.append( $tmpLabel.nextAll() );\n\t\t\t$prevContent = $tmpLabel.prevAll();\n\t\t}\n\n\t\t// Create radio\n\t\tfor ( i = 0, i_len = items.length; i !== i_len; i += 1 ) {\n\t\t\tcur_itm = items[ i ];\n\n\t\t\tif ( !cur_itm.group ) {\n\t\t\t\tradCheckOut += buildCheckboxRadio( cur_itm, fieldName, typeRadCheck, isInline, isReq );\n\t\t\t} else {\n\n\t\t\t\t// We have a group of sub-items, the cur_itm are a group\n\t\t\t\tradCheckOut += "<p>" + cur_itm.label + "</p>";\n\t\t\t\tj_len = cur_itm.group.length;\n\t\t\t\tfor ( j = 0; j !== j_len; j += 1 ) {\n\t\t\t\t\tradCheckOut += buildCheckboxRadio( cur_itm.group[ j ], fieldName, typeRadCheck, isInline, isReq );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$out.append( radCheckOut );\n\t\t$( "#" + bodyId ).append( $out );\n\t\tif ( $prevContent ) {\n\t\t\t$out.before( $prevContent );\n\t\t}\n\n\t\t// Set post action if any\n\t\tif ( actions && actions.length > 0 ) {\n\t\t\t$out.data( pushJQData, actions );\n\t\t}\n\n\t\t// Register this control\n\t\tpushData( $elm, registerJQData, ctrlID );\n\t},\n\tgetItemsData = function( $items, preventRecusive ) {\n\t\tvar arrItems = $items.get(),\n\t\t\ti, i_len = arrItems.length, itmCached,\n\t\t\titmLabel, itmValue, grpItem,\n\t\t\tj, j_len, childNodes, firstNode, childNode, $childNode, childNodeID,\n\t\t\tparsedItms = [],\n\t\t\tactions;\n\n\t\tfor ( i = 0; i !== i_len; i += 1 ) {\n\t\t\titmCached = arrItems[ i ];\n\n\t\t\titmValue = "";\n\t\t\tgrpItem = null;\n\t\t\titmLabel = "";\n\n\t\t\tfirstNode = itmCached.firstChild;\n\t\t\tchildNodes = itmCached.childNodes;\n\t\t\tj_len = childNodes.length;\n\n\t\t\tif ( !firstNode ) {\n\t\t\t\tthrow "You have a markup error, There may be an empyt <li> elements in your list.";\n\t\t\t}\n\n\t\t\tactions = [];\n\n\t\t\t// Is firstNode an anchor?\n\t\t\tif ( firstNode.nodeName === "A" ) {\n\t\t\t\titmValue = firstNode.getAttribute( "href" );\n\t\t\t\titmLabel = $( firstNode ).html();\n\t\t\t\tj_len = 1; // Force following elements to be ignored\n\n\t\t\t\tactions.push( {\n\t\t\t\t\taction: "redir",\n\t\t\t\t\turl: itmValue\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\t// Iterate until we have found the labelClass or <ul> or element with subSelector or end of the array\n\t\t\tfor ( j = 1; j !== j_len; j += 1 ) {\n\t\t\t\tchildNode = childNodes[ j ];\n\t\t\t\t$childNode = $( childNode );\n\n\t\t\t\t// Sub plugin\n\t\t\t\tif ( $childNode.hasClass( subComponentName ) ) {\n\t\t\t\t\tchildNodeID = childNode.id || wb.getId();\n\t\t\t\t\tchildNode.id = childNodeID;\n\t\t\t\t\titmValue = componentName + "-" + childNodeID;\n\n\t\t\t\t\tactions.push( {\n\t\t\t\t\t\taction: "append",\n\t\t\t\t\t\tsrctype: componentName,\n\t\t\t\t\t\tsource: "#" + childNodeID\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Grouping\n\t\t\t\tif ( childNode.nodeName === "UL" ) {\n\t\t\t\t\tif ( preventRecusive ) {\n\t\t\t\t\t\tthrow "Recursive error, please check your code";\n\t\t\t\t\t}\n\t\t\t\t\tgrpItem = getItemsData( $childNode.children(), true );\n\t\t\t\t}\n\n\t\t\t\t// Explicit label to use\n\t\t\t\tif ( $childNode.hasClass( labelClass ) ) {\n\t\t\t\t\titmLabel = $childNode.html();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( !itmLabel ) {\n\t\t\t\titmLabel = firstNode.nodeValue;\n\t\t\t}\n\n\t\t\t// Set an id on the element\n\t\t\tif ( !itmCached.id ) {\n\t\t\t\titmCached.id = wb.getId();\n\t\t\t}\n\n\t\t\t// Return the item parsed\n\t\t\tparsedItms.push( {\n\t\t\t\t"bind": itmCached.id,\n\t\t\t\t"label": itmLabel,\n\t\t\t\t"actions": actions,\n\t\t\t\t"group": grpItem\n\t\t\t} );\n\t\t}\n\t\treturn parsedItms;\n\t},\n\tbuildSelectOption = function( data ) {\n\t\tvar label = data.label,\n\t\t\tout = "<option value=\'" + label + "\'";\n\n\t\tout += buildDataAttribute( data );\n\n\t\tout += ">" + label + "</option>";\n\n\t\treturn out;\n\t},\n\tbuildDataAttribute = function( data ) {\n\t\tvar out = "",\n\t\t\tdataFieldflow = {};\n\n\t\tdataFieldflow.bind = data.bind || "";\n\t\tdataFieldflow.actions = data.actions || [ ];\n\n\t\tout += " data-" + componentName + "=\'" + JSON.stringify( dataFieldflow ) + "\'";\n\n\t\treturn out;\n\t},\n\tbuildCheckboxRadio = function( data, fieldName, inputType, isInline, isReq ) {\n\t\tvar label = data.label,\n\t\t\tfieldID = wb.getId(),\n\t\t\tinline = isInline ? "-inline" : "",\n\t\t\tout = " for=\'" + fieldID + "\'><input id=\'" + fieldID + "\' type=\'" + inputType + "\' name=\'" + fieldName + "\' value=\'" + label + "\'";\n\n\t\tif ( isInline ) {\n\t\t\tout = "<label class=\'" + inputType + inline + "\'" + out;\n\t\t} else {\n\t\t\tout = "<div class=\'" + inputType + "\'><label" + out;\n\t\t}\n\n\t\tout += buildDataAttribute( data );\n\n\t\tif ( isReq ) {\n\t\t\tout += " required=\'required\'";\n\t\t}\n\t\tout += " /> " + label + "</label>";\n\n\t\tif ( !isInline ) {\n\t\t\tout += "</div>";\n\t\t}\n\n\t\treturn out;\n\t};\n\n$document.on( resetActionEvent, selector + ", ." + subComponentName, function( event ) {\n\tvar elm = event.target,\n\t\t$elm,\n\t\tsettings,\n\t\tsettingsReset,\n\t\tresetAction = [],\n\t\ti, i_len, i_cache, action, isLive;\n\n\tif ( elm === event.currentTarget ) {\n\t\t$elm = $( elm );\n\t\tsettings = $elm.data( configData );\n\n\t\tif ( settings && settings.reset ) {\n\t\t\tsettingsReset = settings.reset;\n\n\t\t\tif ( $.isArray( settingsReset ) ) {\n\t\t\t\tresetAction = settingsReset;\n\t\t\t} else {\n\t\t\t\tresetAction.push( settingsReset );\n\t\t\t}\n\n\t\t\ti_len = resetAction.length;\n\t\t\tfor ( i = 0; i !== i_len; i += 1 ) {\n\t\t\t\ti_cache = resetAction[ i ];\n\t\t\t\taction = i_cache.action;\n\t\t\t\tif ( action ) {\n\t\t\t\t\tisLive = i_cache.live;\n\t\t\t\t\tif ( isLive !== false ) {\n\t\t\t\t\t\ti_cache.live = true;\n\t\t\t\t\t}\n\t\t\t\t\t$elm.trigger( action + "." + actionEvent, i_cache );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Load content after the user have choosen an option\n$document.on( "change", selectorForm + " " + crtlSelectSelector, function( event ) {\n\n\tvar elm = event.currentTarget,\n\t\t$elm = $( elm ),\n\t\tselCurrentElm, cacheAction,\n\t\ti, i_len, dtCached, dtCachedTarget,\n\t\titmToClean = $elm.nextAll(), itm, idxItem,\n\t\t$orgin = $( "#" + elm.getAttribute( "data-" + originData ) ),\n\t\t$source = $( "#" + elm.getAttribute( sourceDataAttr ) ),\n\t\tlstIdRegistered = $orgin.data( registerJQData ),\n\t\t$optSel = $elm.find( ":checked", $elm ),\n\t\tform = $elm.get( 0 ).form;\n\n\t//\n\t// 1. Cleaning\n\t//\n\ti_len = itmToClean.length;\n\tif ( i_len ) {\n\t\tfor ( i = i_len; i !== 0; i -= 1 ) {\n\t\t\titm = itmToClean[ i ];\n\t\t\tif ( itm ) {\n\t\t\t\tidxItem = lstIdRegistered.indexOf( itm.id );\n\t\t\t\tif ( idxItem > -1 ) {\n\t\t\t\t\tlstIdRegistered.splice( idxItem, 1 );\n\t\t\t\t}\n\t\t\t\t$( "#" + itm.getAttribute( sourceDataAttr ) ).trigger( resetActionEvent ).trigger( cleanEvent );\n\t\t\t\t$( itm ).trigger( cleanEvent );\n\t\t\t}\n\t\t}\n\t\t$orgin.data( registerJQData, lstIdRegistered );\n\t\titmToClean.remove();\n\t}\n\t$source.trigger( resetActionEvent ).trigger( cleanEvent );\n\t$elm.trigger( cleanEvent );\n\n\t// Remove any action that is pending for form submission\n\t$elm.data( submitJQData, [] );\n\n\t//\n\t// 2. Get defined actions\n\t//\n\n\tvar actions = [],\n\t\tsettings, settingsSrc, selFieldFlowData,\n\t\tactionAttr,\n\t\tdefaultAction,\n\t\tdefaultProp,\n\t\tbaseAction,\n\t\tnowActions = [],\n\t\tpostActions = [], postAction_len,\n\t\tbindTo,\n\t\tbindToElm;\n\n\t// From the component, default action\n\tsettings = $orgin.data( configData );\n\tsettingsSrc = $source.data( configData );\n\tif ( settingsSrc && settings ) {\n\t\tsettings = $.extend( {}, settings, settingsSrc );\n\t}\n\tif ( $optSel.length && $optSel.val() && settings && settings.default ) {\n\t\tcacheAction = settings.default;\n\t\tif ( $.isArray( cacheAction ) ) {\n\t\t\tactions = cacheAction;\n\t\t} else {\n\t\t\tactions.push( cacheAction );\n\t\t}\n\t}\n\n\tdefaultAction = settings.action;\n\tdefaultProp = settings.prop;\n\tactionData = settings.actionData || {};\n\n\t// From the component, action pushed for later\n\tcacheAction = $elm.data( pushJQData );\n\tif ( cacheAction ) {\n\t\tactions = actions.concat( cacheAction );\n\t}\n\n\t// For each the binded elements that are selected\n\tfor ( i = 0, i_len = $optSel.length; i !== i_len; i += 1 ) {\n\t\tselCurrentElm = $optSel.get( i );\n\t\tselFieldFlowData = wb.getData( selCurrentElm, componentName );\n\t\tif ( selFieldFlowData ) {\n\t\t\tbindTo = selFieldFlowData.bind;\n\t\t\tactions = actions.concat( selFieldFlowData.actions );\n\n\t\t\tif ( bindTo ) {\n\n\t\t\t\t// Retreive action set on the binded element\n\t\t\t\tbindToElm = document.getElementById( bindTo );\n\t\t\t\tactionAttr = bindToElm.getAttribute( "data-" + componentName );\n\t\t\t\tif ( actionAttr ) {\n\t\t\t\t\tif ( actionAttr.startsWith( "{" ) || actionAttr.startsWith( "[" ) ) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcacheAction = JSON.parse( actionAttr );\n\t\t\t\t\t\t} catch ( error ) {\n\t\t\t\t\t\t\t$.error( "Bad JSON object " + actionAttr );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( !$.isArray( cacheAction ) ) {\n\t\t\t\t\t\t\tcacheAction = [ cacheAction ];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcacheAction = {};\n\t\t\t\t\t\tcacheAction.action = defaultAction;\n\t\t\t\t\t\tcacheAction[ defaultProp ] = actionAttr;\n\t\t\t\t\t\tcacheAction = $.extend( true, {}, actionData, cacheAction );\n\t\t\t\t\t\tcacheAction = [ cacheAction ];\n\t\t\t\t\t}\n\t\t\t\t\tactions = actions.concat( cacheAction );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// If there is no action, do nothing\n\tif ( !actions.length ) {\n\t\treturn true;\n\t}\n\n\t//\n\t// 3. Sort action\n\t// \t\t\tarray1 = Action to be executed now\n\t//\t\t\tarray2 = Action to be postponed for later use\n\tfor ( i = 0, i_len = actions.length; i !== i_len; i += 1 ) {\n\t\tdtCached = actions[ i ];\n\t\tdtCachedTarget = dtCached.target;\n\t\tif ( !dtCachedTarget || dtCachedTarget === bindTo ) {\n\t\t\tnowActions.push( dtCached );\n\t\t} else {\n\t\t\tpostActions.push( dtCached );\n\t\t}\n\t}\n\n\t//\n\t// 4. Execute action for the current item\n\t//\n\tbaseAction = settings.base || {};\n\tpostAction_len = postActions.length;\n\tfor ( i = 0, i_len = nowActions.length; i !== i_len; i += 1 ) {\n\t\tdtCached = $.extend( {}, baseAction, nowActions[ i ] );\n\t\tdtCached.origin = $source.get( 0 );\n\t\tdtCached.provEvt = elm;\n\t\tdtCached.$selElm = $optSel;\n\t\tdtCached.form = form;\n\t\tif ( postAction_len ) {\n\t\t\tdtCached.actions = postActions;\n\t\t}\n\t\t$orgin.trigger( dtCached.action + "." + actionEvent, dtCached );\n\t}\n\treturn true;\n} );\n\n\n// Load content after the user have choosen an option\n$document.on( "submit", selectorForm + " form", function( event ) {\n\n\tvar elm = event.currentTarget,\n\t\t$elm = $( elm ),\n\t\twbFieldFlowRegistered = $elm.data( registerJQData ),\n\t\twbRegisteredHidden = $elm.data( registerHdnFld ) || [],\n\t\t$hdnField,\n\t\ti, i_len = wbFieldFlowRegistered ? wbFieldFlowRegistered.length : 0,\n\t\t$wbFieldFlow, fieldOrigin,\n\t\tlstFieldFlowPostEvent = [],\n\t\tcomponentRegistered, $componentRegistered, $origin, lstOrigin = [],\n\t\tsettings,\n\t\tj, j_len,\n\t\tm, m_len, m_cache,\n\t\tactions,\n\t\tpreventSubmit = false, lastProvEvt;\n\n\t// Run the cleaning on the current items\n\tif ( i_len ) {\n\t\t$wbFieldFlow = $( "#" + wbFieldFlowRegistered[ i_len - 1 ] );\n\t\tfieldOrigin = $wbFieldFlow.data( registerJQData );\n\t\t$( "#" + fieldOrigin[ fieldOrigin.length - 1 ] ).trigger( cleanEvent );\n\t\t$wbFieldFlow.trigger( cleanEvent );\n\t}\n\n\t// For each wb-fieldflow component, execute submiting task.\n\tfor ( i = 0; i !== i_len; i += 1 ) {\n\t\t$wbFieldFlow = $( "#" + wbFieldFlowRegistered[ i ] );\n\t\tcomponentRegistered = $wbFieldFlow.data( registerJQData );\n\t\tj_len = componentRegistered.length;\n\t\tfor ( j = 0; j !== j_len; j += 1 ) {\n\t\t\t$componentRegistered = $( "#" + componentRegistered[ j ] );\n\t\t\t$origin = $( "#" + $componentRegistered.data( originData ) );\n\t\t\tlstOrigin.push( $origin );\n\t\t\tsettings = $origin.data( configData );\n\t\t\tactions = $componentRegistered.data( submitJQData );\n\n\t\t\t// If there is If None setting\n\t\t\tif ( !actions && settings.defaultIfNone ) {\n\t\t\t\tactions = settings.defaultIfNone;\n\t\t\t\tfor ( m = 0, m_len = actions.length; m !== m_len; m += 1 ) {\n\t\t\t\t\tm_cache = actions[ m ];\n\t\t\t\t\tm_cache.origin = $origin.get( 0 );\n\t\t\t\t\tm_cache.$selElm = $origin.prev().find( "input, select" ).eq( 0 );\n\t\t\t\t\tm_cache.provEvt = m_cache.$selElm.get( 0 );\n\t\t\t\t\tm_cache.form = elm;\n\t\t\t\t\t$origin.trigger( m_cache.action + "." + actionEvent, m_cache );\n\t\t\t\t}\n\t\t\t\tactions = $componentRegistered.data( submitJQData );\n\t\t\t}\n\t\t\tif ( actions ) {\n\t\t\t\tfor ( m = 0, m_len = actions.length; m !== m_len; m += 1 ) {\n\t\t\t\t\tm_cache = actions[ m ];\n\t\t\t\t\tm_cache.form = elm;\n\t\t\t\t\t$wbFieldFlow.trigger( m_cache.action + "." + submitEvent, m_cache );\n\t\t\t\t\tlstFieldFlowPostEvent.push( {\n\t\t\t\t\t\t$elm: $wbFieldFlow,\n\t\t\t\t\t\tdata: m_cache\n\t\t\t\t\t} );\n\t\t\t\t\tpreventSubmit = preventSubmit || m_cache.preventSubmit;\n\t\t\t\t\tlastProvEvt = m_cache.provEvt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Before to submit, remove jj-down accessesory control\n\tif ( !preventSubmit ) {\n\t\t$elm.find( basenameInputSelector ).removeAttr( "name" );\n\n\t\t// Fix an issue when clicking back with the mouse\n\t\ti_len = wbRegisteredHidden.length;\n\t\tfor ( i = 0; i !== i_len; i += 1 ) {\n\t\t\t$( wbRegisteredHidden[ i ] ).remove();\n\t\t}\n\t\twbRegisteredHidden = [];\n\n\t\t// Check the form action, if there is query string, do split it and create hidden field for submission\n\t\t// The following is may be simply caused by a cross-server security issue generated by the browser itself\n\t\tvar frmAction, idxQueryDelimiter,\n\t\t\tqueryString, cacheParam, cacheName,\n\t\t\titems, params;\n\n\t\tfrmAction = $elm.attr( "action" );\n\t\tif ( frmAction ) {\n\t\t\tidxQueryDelimiter = frmAction.indexOf( "?" );\n\t\t\tif ( idxQueryDelimiter > 0 ) {\n\n\t\t\t\t// Split the query string and create hidden input.\n\t\t\t\tqueryString = frmAction.substring( idxQueryDelimiter + 1 );\n\t\t\t\tparams = queryString.split( "&" );\n\n\t\t\t\ti_len = params.length;\n\t\t\t\tfor ( i = 0; i !== i_len; i += 1 ) {\n\t\t\t\t\tcacheParam = params[ i ];\n\t\t\t\t\tcacheName = cacheParam;\n\t\t\t\t\tif ( cacheParam.indexOf( "=" ) > 0 ) {\n\t\t\t\t\t\titems = cacheParam.split( "=", 2 );\n\t\t\t\t\t\tcacheName = items[ 0 ];\n\t\t\t\t\t\tcacheParam = items[ 1 ];\n\t\t\t\t\t}\n\t\t\t\t\t$hdnField = $( "<input type=\'hidden\' name=\'" + cacheName + "\' value=\'" + cacheParam + "\' />" );\n\t\t\t\t\t$elm.append( $hdnField );\n\t\t\t\t\twbRegisteredHidden.push( $hdnField.get( 0 ) );\n\t\t\t\t}\n\t\t\t\t$elm.data( registerHdnFld, wbRegisteredHidden );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Add global action\n\ti_len = lstOrigin.length;\n\tfor ( i = 0; i !== i_len; i += 1 ) {\n\t\t$origin = lstOrigin[ i ];\n\t\tsettings = $origin.data( configData );\n\t\tif ( settings.action ) {\n\t\t\tlstFieldFlowPostEvent.push( {\n\t\t\t\t$elm: $origin,\n\t\t\t\tdata: settings\n\t\t\t} );\n\t\t}\n\t}\n\n\ti_len = lstFieldFlowPostEvent.length;\n\tfor ( i = 0; i !== i_len; i += 1 ) {\n\t\tm_cache = lstFieldFlowPostEvent[ i ];\n\t\tm_cache.data.lastProvEvt = lastProvEvt;\n\t\tm_cache.$elm.trigger( m_cache.data.action + "." + submitedEvent, m_cache.data );\n\t}\n\tif ( preventSubmit ) {\n\t\tevent.preventDefault();\n\t\tif ( event.stopPropagation ) {\n\t\t\tevent.stopImmediatePropagation();\n\t\t} else {\n\t\t\tevent.cancelBubble = true;\n\t\t}\n\t\treturn false;\n\t}\n} );\n\n$document.on( "keyup", selectorForm + " select", function( Ev ) {\n\n\t// Add the fix for the on change event - https://bugzilla.mozilla.org/show_bug.cgi?id=126379\n\tif ( navigator.userAgent.indexOf( "Gecko" ) !== -1 ) {\n\n\t\t// prevent tab, alt, ctrl keys from fireing the event\n\t\tif ( Ev.keyCode && ( Ev.keyCode === 1 || Ev.keyCode === 9 || Ev.keyCode === 16 || Ev.altKey || Ev.ctrlKey ) ) {\n\t\t\treturn true;\n\t\t}\n\t\t$( Ev.target ).trigger( "change" );\n\t\treturn true;\n\t}\n} );\n\n$document.on( fieldflowActionsEvents, selector, function( event, data ) {\n\n\tvar eventType = event.type;\n\n\tswitch ( event.namespace ) {\n\tcase drawEvent:\n\t\tswitch ( eventType ) {\n\t\tcase componentName:\n\t\t\tdrwFieldflow( event, data );\n\t\t\tbreak;\n\t\tcase "tblfilter":\n\t\t\tdrwTblFilter( event, data );\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase createCtrlEvent:\n\t\tswitch ( eventType ) {\n\t\tcase "select":\n\t\t\tctrlSelect( event, data );\n\t\t\tbreak;\n\t\tcase "checkbox":\n\t\t\tdata.typeRadCheck = "checkbox";\n\t\t\tctrlChkbxRad( event, data );\n\t\t\tbreak;\n\t\tcase "radio":\n\t\t\tdata.typeRadCheck = "radio";\n\t\t\tctrlChkbxRad( event, data );\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase actionEvent:\n\t\tswitch ( eventType ) {\n\t\tcase "append":\n\t\t\tactAppend( event, data );\n\t\t\tbreak;\n\t\tcase "redir":\n\t\t\tpushData( $( data.provEvt ), submitJQData, data, true );\n\t\t\tbreak;\n\t\tcase "ajax":\n\t\t\tactAjax( event, data );\n\t\t\tbreak;\n\t\tcase "tblfilter":\n\t\t\tactTblFilter( event, data );\n\t\t\tbreak;\n\t\tcase "toggle":\n\t\t\tif ( data.live ) {\n\t\t\t\tsubToggle( event, data );\n\t\t\t} else {\n\t\t\t\tdata.preventSubmit = true;\n\t\t\t\tpushData( $( data.provEvt ), submitJQData, data );\n\t\t\t}\n\t\t\tbreak;\n\t\tcase "addClass":\n\t\t\tif ( !data.source || !data.class ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( data.live ) {\n\t\t\t\t$( data.source ).addClass( data.class );\n\t\t\t} else {\n\t\t\t\tdata.preventSubmit = true;\n\t\t\t\tpushData( $( data.provEvt ), submitJQData, data );\n\t\t\t}\n\t\t\tbreak;\n\t\tcase "removeClass":\n\t\t\tif ( !data.source || !data.class ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( data.live ) {\n\t\t\t\t$( data.source ).removeClass( data.class );\n\t\t\t} else {\n\t\t\t\tdata.preventSubmit = true;\n\t\t\t\tpushData( $( data.provEvt ), submitJQData, data );\n\t\t\t}\n\t\t\tbreak;\n\t\tcase "query":\n\t\t\tactQuery( event, data );\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase submitEvent:\n\t\tswitch ( eventType ) {\n\t\tcase "redir":\n\t\t\tsubRedir( event, data );\n\t\t\tbreak;\n\t\tcase "ajax":\n\t\t\tsubAjax( event, data );\n\t\t\tbreak;\n\t\tcase "toggle":\n\t\t\tsubToggle( event, data );\n\t\t\tbreak;\n\t\tcase "addClass":\n\t\t\t$( data.source ).addClass( data.class );\n\t\t\tbreak;\n\t\tcase "removeClass":\n\t\t\t$( data.source ).removeClass( data.class );\n\t\t\tbreak;\n\t\tcase "query":\n\t\t\tactQuery( event, data );\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n} );\n\n// Bind the init event of the plugin\n$document.on( "timerpoke.wb " + initEvent, selector, function( event ) {\n\tswitch ( event.type ) {\n\tcase "timerpoke":\n\tcase "wb-init":\n\t\tinit( event );\n\t\tbreak;\n\t}\n\n\t/*\n\t* Since we are working with events we want to ensure that we are being passive about our control,\n\t* so returning true allows for events to always continue\n\t*/\n\treturn true;\n} );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, document, wb );\n\n/**\n * @title WET-BOEW JSON Fetch [ json-fetch ]\n * @overview Load and filter data from a JSON file\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @duboisp\n */\n/*global jsonpointer */\n( function( $, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar $document = wb.doc,\n\tcomponent = "json-fetch",\n\tfetchEvent = component + ".wb",\n\tjsonCache = { },\n\tjsonCacheBacklog = { },\n\tcompleteJsonFetch = function( callerId, refId, response, status, xhr, selector ) {\n\t\tif ( !window.jsonpointer ) {\n\n\t\t\t// JSON pointer library is loaded but not executed in memory yet, we need to wait a tick before to continue\n\t\t\tsetTimeout( function() {\n\t\t\t\tcompleteJsonFetch( callerId, refId, response, status, xhr, selector );\n\t\t\t}, 100 );\n\t\t\treturn false;\n\t\t}\n\t\tif ( selector ) {\n\t\t\tresponse = jsonpointer.get( response, selector );\n\t\t}\n\t\t$( "#" + callerId ).trigger( {\n\t\t\ttype: "json-fetched.wb",\n\t\t\tfetch: {\n\t\t\t\tresponse: response,\n\t\t\t\tstatus: status,\n\t\t\t\txhr: xhr,\n\t\t\t\trefId: refId\n\t\t\t}\n\t\t}, this );\n\t};\n\n// Event binding\n$document.on( fetchEvent, function( event ) {\n\n\tvar caller = event.element || event.target,\n\t\tfetchOpts = event.fetch,\n\t\turlParts = fetchOpts.url.split( "#" ),\n\t\turl = urlParts[ 0 ],\n\t\tfetchNoCache = fetchOpts.nocache,\n\t\tfetchNoCacheKey = fetchOpts.nocachekey || wb.cacheBustKey || "wbCacheBust",\n\t\tfetchNoCacheValue,\n\t\tfetchCacheURL,\n\t\thashPart,\n\t\tdatasetName,\n\t\tselector = urlParts[ 1 ] || false,\n\t\tcallerId, refId = fetchOpts.refId,\n\t\tcachedResponse;\n\n\t// Filter out any events triggered by descendants\n\tif ( caller === event.target || event.currentTarget === event.target ) {\n\n\t\tif ( !caller.id ) {\n\t\t\tcaller.id = wb.getId();\n\t\t}\n\t\tcallerId = caller.id;\n\n\t\tif ( selector ) {\n\n\t\t\t// If a Dataset Name exist let it managed by wb-jsonpatch plugin\n\t\t\thashPart = selector.split( "/" );\n\t\t\tdatasetName = hashPart[ 0 ];\n\n\t\t\t// A dataset name must start with "[" character, if it is a letter, then follow JSON Schema (to be implemented)\n\t\t\tif ( datasetName.charCodeAt( 0 ) === 91 ) {\n\n\t\t\t\t// Let the wb-jsonpatch plugin to manage it\n\t\t\t\t$( "#" + callerId ).trigger( {\n\t\t\t\t\ttype: "postpone.wb-jsonmanager",\n\t\t\t\t\tpostpone: {\n\t\t\t\t\t\tcallerId: callerId,\n\t\t\t\t\t\trefId: refId,\n\t\t\t\t\t\tdsname: datasetName,\n\t\t\t\t\t\tselector: selector.substring( datasetName.length )\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfetchOpts.url = url;\n\t\t}\n\n\t\tif ( fetchNoCache ) {\n\t\t\tif ( fetchNoCache === "nocache" ) {\n\t\t\t\tfetchNoCacheValue = wb.guid();\n\t\t\t} else {\n\t\t\t\tfetchNoCacheValue = wb.sessionGUID();\n\t\t\t}\n\t\t\tfetchCacheURL = fetchNoCacheKey + "=" + fetchNoCacheValue;\n\n\t\t\tif ( url.indexOf( "?" ) !== -1 ) {\n\t\t\t\turl = url + "&" + fetchCacheURL;\n\t\t\t} else {\n\t\t\t\turl = url + "?" + fetchCacheURL;\n\t\t\t}\n\t\t\tfetchOpts.url = url;\n\t\t}\n\n\t\tModernizr.load( {\n\t\t\tload: "site!deps/jsonpointer" + wb.getMode() + ".js",\n\t\t\tcomplete: function() {\n\n\t\t\t\tif ( !fetchOpts.nocache ) {\n\t\t\t\t\tcachedResponse = jsonCache[ url ];\n\n\t\t\t\t\tif ( cachedResponse ) {\n\t\t\t\t\t\tcompleteJsonFetch( callerId, refId, cachedResponse, "success", undefined, selector );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( !jsonCacheBacklog[ url ] ) {\n\t\t\t\t\t\t\tjsonCacheBacklog[ url ] = [ ];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjsonCacheBacklog[ url ].push( {\n\t\t\t\t\t\t\t\t"callerId": callerId,\n\t\t\t\t\t\t\t\t"refId": refId,\n\t\t\t\t\t\t\t\t"selector": selector\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$.ajax( fetchOpts )\n\t\t\t\t\t.done( function( response, status, xhr ) {\n\t\t\t\t\t\tvar i, i_len, i_cache, backlog;\n\n\t\t\t\t\t\tif ( !fetchOpts.nocache ) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tjsonCache[ url ] = response;\n\t\t\t\t\t\t\t} catch ( error ) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcompleteJsonFetch( callerId, refId, response, status, xhr, selector );\n\n\t\t\t\t\t\tif ( jsonCacheBacklog[ url ] ) {\n\t\t\t\t\t\t\tbacklog = jsonCacheBacklog[ url ];\n\n\t\t\t\t\t\t\ti_len = backlog.length;\n\n\t\t\t\t\t\t\tfor ( i = 0; i !== i_len; i += 1 ) {\n\t\t\t\t\t\t\t\ti_cache = backlog[ i ];\n\t\t\t\t\t\t\t\tcompleteJsonFetch( i_cache.callerId, i_cache.refId, response, status, xhr, i_cache.selector );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} )\n\t\t\t\t\t.fail( function( xhr, status, error ) {\n\t\t\t\t\t\t$( "#" + callerId ).trigger( {\n\t\t\t\t\t\t\ttype: "json-failed.wb",\n\t\t\t\t\t\t\tfetch: {\n\t\t\t\t\t\t\t\txhr: xhr,\n\t\t\t\t\t\t\t\tstatus: status,\n\t\t\t\t\t\t\t\terror: error,\n\t\t\t\t\t\t\t\trefId: refId\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, this );\n\t\t\t\t\t}, this );\n\t\t\t}\n\t\t} );\n\t}\n} );\n\n} )( jQuery, wb );\n\n/**\n * @title WET-BOEW JSON Manager\n * @overview Manage JSON dataset, execute JSON patch operation.\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @duboisp\n */\n/*global jsonpointer, jsonpatch */\n( function( $, window, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-jsonmanager",\n\tselector = "[data-" + componentName + "]",\n\tinitEvent = "wb-init." + componentName,\n\tpostponeEvent = "postpone." + componentName,\n\tpatchesEvent = "patches." + componentName,\n\tjsonFailedClass = "jsonfail",\n\tdsNameRegistered = [],\n\tdatasetCache = {},\n\tdatasetCacheSettings = {},\n\tdsDelayed = {},\n\t$document = wb.doc,\n\tdefaults = {\n\t\tops: [\n\t\t\t{\n\t\t\t\tname: "wb-count",\n\t\t\t\tfn: function( obj, key, tree ) {\n\t\t\t\t\tvar countme = obj[ key ],\n\t\t\t\t\t\tlen = 0, i_len, i,\n\t\t\t\t\t\tfilter = this.filter || [ ],\n\t\t\t\t\t\tfilternot = this.filternot || [ ];\n\n\t\t\t\t\tif ( !$.isArray( filter ) ) {\n\t\t\t\t\t\tfilter = [ filter ];\n\t\t\t\t\t}\n\t\t\t\t\tif ( !$.isArray( filternot ) ) {\n\t\t\t\t\t\tfilternot = [ filternot ];\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( filter.length || filternot.length ) && $.isArray( countme ) ) {\n\n\t\t\t\t\t\t// Iterate in obj[key] / item and check if is true for the given path is any.\n\t\t\t\t\t\ti_len = countme.length;\n\n\t\t\t\t\t\tfor ( i = 0; i !== i_len; i = i + 1 ) {\n\t\t\t\t\t\t\tif ( filterPassJSON( countme[ i ], filter, filternot ) ) {\n\t\t\t\t\t\t\t\tlen = len + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if ( $.isArray( countme ) ) {\n\t\t\t\t\t\tlen = countme.length;\n\t\t\t\t\t}\n\t\t\t\t\tjsonpatch.apply( tree, [\n\t\t\t\t\t\t{ op: "add", path: this.set, value: len }\n\t\t\t\t\t] );\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: "wb-first",\n\t\t\t\tfn: function( obj, key, tree ) {\n\t\t\t\t\tvar currObj = obj[ key ];\n\t\t\t\t\tif ( !$.isArray( currObj ) || currObj.length === 0 ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tjsonpatch.apply( tree, [\n\t\t\t\t\t\t{ op: "add", path: this.set, value: currObj[ 0 ] }\n\t\t\t\t\t] );\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: "wb-last",\n\t\t\t\tfn: function( obj, key, tree ) {\n\t\t\t\t\tvar currObj = obj[ key ];\n\t\t\t\t\tif ( !$.isArray( currObj ) || currObj.length === 0 ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tjsonpatch.apply( tree, [\n\t\t\t\t\t\t{ op: "add", path: this.set, value: currObj[ currObj.length - 1 ] }\n\t\t\t\t\t] );\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: "wb-nbtolocal",\n\t\t\t\tfn: function( obj, key, tree ) {\n\t\t\t\t\tvar val = obj[ key ],\n\t\t\t\t\t\tloc = this.locale || window.wb.lang,\n\t\t\t\t\t\tsuffix = this.suffix || "",\n\t\t\t\t\t\tprefix = this.prefix || "";\n\n\t\t\t\t\tif ( typeof val === "string" ) {\n\t\t\t\t\t\tval = parseFloat( val );\n\t\t\t\t\t\tif ( isNaN( val ) ) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tjsonpatch.apply( tree, [\n\t\t\t\t\t\t{ op: "replace", path: this.path, value: prefix + val.toLocaleString( loc ) + suffix  }\n\t\t\t\t\t] );\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: "wb-toDateISO",\n\t\t\t\tfn: function( obj, key, tree ) {\n\t\t\t\t\tif ( !this.set ) {\n\t\t\t\t\t\tjsonpatch.apply( tree, [\n\t\t\t\t\t\t\t{ op: "replace", path: this.path, value: wb.date.toDateISO( obj[ key ] ) }\n\t\t\t\t\t\t] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjsonpatch.apply( tree, [\n\t\t\t\t\t\t\t{ op: "add", path: this.set, value: wb.date.toDateISO( obj[ key ] ) }\n\t\t\t\t\t\t] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: "wb-toDateTimeISO",\n\t\t\t\tfn: function( obj, key, tree ) {\n\t\t\t\t\tif ( !this.set ) {\n\t\t\t\t\t\tjsonpatch.apply( tree, [\n\t\t\t\t\t\t\t{ op: "replace", path: this.path, value: wb.date.toDateISO( obj[ key ], true ) }\n\t\t\t\t\t\t] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjsonpatch.apply( tree, [\n\t\t\t\t\t\t\t{ op: "add", path: this.set, value: wb.date.toDateISO( obj[ key ], true ) }\n\t\t\t\t\t\t] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\topsArray: [\n\t\t\t{\n\t\t\t\tname: "wb-toDateISO",\n\t\t\t\tfn: function( arr )  {\n\t\t\t\t\tvar setval = this.set,\n\t\t\t\t\t\tpathval = this.path,\n\t\t\t\t\t\ti, i_len = arr.length;\n\t\t\t\t\tfor ( i = 0; i !== i_len; i += 1 ) {\n\t\t\t\t\t\tif ( setval ) {\n\t\t\t\t\t\t\tjsonpatch.apply( arr, [\n\t\t\t\t\t\t\t\t{ op: "wb-toDateISO", set: "/" + i + setval, path: "/" + i + pathval }\n\t\t\t\t\t\t\t] );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjsonpatch.apply( arr, [\n\t\t\t\t\t\t\t\t{ op: "wb-toDateISO", path: "/" + i + pathval }\n\t\t\t\t\t\t\t] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: "wb-toDateTimeISO",\n\t\t\t\tfn: function( arr ) {\n\t\t\t\t\tvar setval = this.set,\n\t\t\t\t\t\tpathval = this.path,\n\t\t\t\t\t\ti, i_len = arr.length;\n\t\t\t\t\tfor ( i = 0; i !== i_len; i += 1 ) {\n\t\t\t\t\t\tif ( setval ) {\n\t\t\t\t\t\t\tjsonpatch.apply( arr, [\n\t\t\t\t\t\t\t\t{ op: "wb-toDateTimeISO", set: "/" + i + setval, path: "/" + i + pathval }\n\t\t\t\t\t\t\t] );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjsonpatch.apply( arr, [\n\t\t\t\t\t\t\t\t{ op: "wb-toDateTimeISO", path: "/" + i + pathval }\n\t\t\t\t\t\t\t] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\topsRoot: [],\n\t\tsettings: { }\n\t},\n\n\t// Add debug information after the JSON manager element\n\tdebugPrintOut = function( $elm, name, json, patches ) {\n\t\t$elm.after( "<p lang=\\"en\\"><strong>JSON Manager Debug</strong> (" +  name + ")</p><ul lang=\\"en\\"><li>JSON: <pre><code>" + JSON.stringify( json ) + "</code></pre></li><li>Patches: <pre><code>" + JSON.stringify( patches ) + "</code></pre>" );\n\t},\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\t$elm,\n\t\t\tjsSettings = window[ componentName ] || { },\n\t\t\tops, opsArray, opsRoot,\n\t\t\ti, i_len, i_cache,\n\t\t\turl, dsName;\n\n\t\tif ( elm ) {\n\t\t\t$elm = $( elm );\n\n\t\t\t// Load handlebars\n\t\t\tModernizr.load( {\n\n\t\t\t\t// For loading multiple dependencies\n\t\t\t\tload: "site!deps/json-patch" + wb.getMode() + ".js",\n\t\t\t\ttestReady: function() {\n\t\t\t\t\treturn window.jsonpatch;\n\t\t\t\t},\n\t\t\t\tcomplete: function() {\n\t\t\t\t\tvar elmData = wb.getData( $elm, componentName );\n\n\t\t\t\t\tif ( !defaults.registered ) {\n\t\t\t\t\t\tops = defaults.ops.concat( jsSettings.ops || [ ] );\n\t\t\t\t\t\topsArray = defaults.opsArray.concat( jsSettings.opsArray || [ ] );\n\t\t\t\t\t\topsRoot = defaults.opsRoot.concat( jsSettings.opsRoot || [ ] );\n\n\t\t\t\t\t\tif ( ops.length ) {\n\t\t\t\t\t\t\tfor ( i = 0, i_len = ops.length; i !== i_len; i++ ) {\n\t\t\t\t\t\t\t\ti_cache = ops[ i ];\n\t\t\t\t\t\t\t\tjsonpatch.registerOps( i_cache.name, i_cache.fn );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( opsArray.length ) {\n\t\t\t\t\t\t\tfor ( i = 0, i_len = opsArray.length; i !== i_len; i++ ) {\n\t\t\t\t\t\t\t\ti_cache = opsArray[ i ];\n\t\t\t\t\t\t\t\tjsonpatch.registerOpsArray( i_cache.name, i_cache.fn );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( opsRoot.length ) {\n\t\t\t\t\t\t\tfor ( i = 0, i_len = opsRoot.length; i !== i_len; i++ ) {\n\t\t\t\t\t\t\t\ti_cache = opsRoot[ i ];\n\t\t\t\t\t\t\t\tjsonpatch.registerOpsRoot( i_cache.name, i_cache.fn );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefaults.settings = $.extend( {}, defaults.settings, jsSettings.settings || {} );\n\t\t\t\t\t\tdefaults.registered = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tdsName = elmData.name;\n\n\t\t\t\t\tif ( !dsName || dsName in dsNameRegistered ) {\n\t\t\t\t\t\tthrow "Dataset name must be unique";\n\t\t\t\t\t}\n\t\t\t\t\tdsNameRegistered.push( dsName );\n\n\t\t\t\t\turl = elmData.url;\n\n\t\t\t\t\tif ( url ) {\n\n\t\t\t\t\t\t// Fetch the JSON\n\t\t\t\t\t\t$elm.trigger( {\n\t\t\t\t\t\t\ttype: "json-fetch.wb",\n\t\t\t\t\t\t\tfetch: {\n\t\t\t\t\t\t\t\turl: url,\n\t\t\t\t\t\t\t\tnocache: elmData.nocache,\n\t\t\t\t\t\t\t\tnocachekey: elmData.nocachekey\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t// If the URL is a dataset, make it ready\n\t\t\t\t\t\tif ( url.charCodeAt( 0 ) === 35 && url.charCodeAt( 1 ) === 91 ) {\n\t\t\t\t\t\t\twb.ready( $elm, componentName );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\twb.ready( $elm, componentName );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t},\n\n\n\t// Filtering a JSON\n\t// Return true if trueness && falseness\n\t// Return false if !( trueness && falseness )\n\t// trueness and falseness is an array of { "path": "", "value": "" } object\n\tfilterPassJSON = function( obj, trueness, falseness ) {\n\t\tvar i, i_cache,\n\t\t\ttrueness_len = trueness.length,\n\t\t\tfalseness_len = falseness.length,\n\t\t\tcompareResult = false,\n\t\t\tisEqual;\n\n\t\tif ( trueness_len || falseness_len ) {\n\n\t\t\tfor ( i = 0; i < trueness_len; i += 1 ) {\n\t\t\t\ti_cache = trueness[ i ];\n\t\t\t\tisEqual = _equalsJSON( jsonpointer.get( obj, i_cache.path ), i_cache.value );\n\n\t\t\t\tif ( i_cache.optional ) {\n\t\t\t\t\tcompareResult = compareResult || isEqual;\n\t\t\t\t} else if ( !isEqual ) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tcompareResult = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( trueness_len && !compareResult ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < falseness_len; i += 1 ) {\n\t\t\t\ti_cache = falseness[ i ];\n\t\t\t\tisEqual = _equalsJSON( jsonpointer.get( obj, i_cache.path ), i_cache.value );\n\n\t\t\t\tif ( isEqual && !i_cache.optional || isEqual && i_cache.optional ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn true;\n\t},\n\n\t// Utility function to compare two JSON value\n\t_equalsJSON = function( a, b ) {\n\t\tswitch ( typeof a ) {\n\t\tcase "undefined":\n\t\t\treturn false;\n\t\tcase "boolean":\n\t\tcase "string":\n\t\tcase "number":\n\t\t\treturn a === b;\n\t\tcase "object":\n\t\t\tif ( a === null ) {\n\t\t\t\treturn b === null;\n\t\t\t}\n\t\t\tif ( $.isArray( a ) ) {\n\t\t\t\tif (  $.isArray( b ) || a.length !== b.length ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tfor ( var i = 0, l = a.length; i < l; i++ ) {\n\t\t\t\t\tif ( !_equalsJSON( a[ i ], b[ i ] ) ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvar bKeys = _objectKeys( b ),\n\t\t\t\tbLength = bKeys.length;\n\t\t\tif ( _objectKeys( a ).length !== bLength ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor ( var i = 0; i < bLength; i++ ) {\n\t\t\t\tif ( !_equalsJSON( a[ i ], b[ i ] ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t},\n\t_objectKeys = function( obj ) {\n\t\tif ( $.isArray( obj ) ) {\n\t\t\tvar keys = new Array( obj.length );\n\t\t\tfor ( var k = 0; k < keys.length; k++ ) {\n\t\t\t\tkeys[ k ] = "" + k;\n\t\t\t}\n\t\t\treturn keys;\n\t\t}\n\t\tif ( Object.keys ) {\n\t\t\treturn Object.keys( obj );\n\t\t}\n\t\tvar keys = [];\n\t\tfor ( var i in obj ) {\n\t\t\tif ( obj.hasOwnProperty( i ) ) {\n\t\t\t\tkeys.push( i );\n\t\t\t}\n\t\t}\n\t\treturn keys;\n\t},\n\n\t// Create series of patches for filtering\n\tgetPatchesToFilter = function( JSONsource, filterPath, filterTrueness, filterFaslseness ) {\n\t\tvar filterObj,\n\t\t\ti, i_len;\n\n\t\tif ( !$.isArray( filterTrueness ) ) {\n\t\t\tfilterTrueness = [ filterTrueness ];\n\t\t}\n\t\tif ( !$.isArray( filterFaslseness ) ) {\n\t\t\tfilterFaslseness = [ filterFaslseness ];\n\t\t}\n\n\t\tfilterObj = jsonpointer.get( JSONsource, filterPath );\n\t\tif ( $.isArray( filterObj ) ) {\n\t\t\ti_len = filterObj.length - 1;\n\t\t\tfor ( i = i_len; i !== -1; i -= 1 ) {\n\t\t\t\tif ( !filterPassJSON( filterObj[ i ], filterTrueness, filterFaslseness ) ) {\n\t\t\t\t\tjsonpatch.apply( JSONsource, [ { op: "remove", path: filterPath + "/" + i } ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn JSONsource;\n\t};\n\n// IE dedicated patch to support ECMA-402 but limited to English and French number formatting\nif ( wb.ie ) {\n\tNumber.prototype.toLocaleString = function( locale ) {\n\n\t\tvar splitVal = this.toString().split( "." ),\n\t\t\tinteger = splitVal[ 0 ],\n\t\t\tdecimal = splitVal[ 1 ],\n\t\t\tintLength = integer.length,\n\t\t\tnbSection = intLength % 3 || 3,\n\t\t\tstrValue = integer.substr( 0, nbSection ),\n\t\t\tisFrenchLoc = ( locale === "fr" ),\n\t\t\tthousandSep = ( isFrenchLoc ? " " : "," ),\n\t\t\ti;\n\n\t\tfor ( i = nbSection; i < intLength; i = i + 3 ) {\n\t\t\tstrValue = strValue + thousandSep + integer.substr( i, 3 );\n\t\t}\n\t\tif ( decimal.length ) {\n\t\t\tif ( isFrenchLoc ) {\n\t\t\t\tstrValue = strValue + "," + decimal;\n\t\t\t} else {\n\t\t\t\tstrValue = strValue + "." + decimal;\n\t\t\t}\n\t\t}\n\t\treturn strValue;\n\t};\n}\n\n$document.on( "json-failed.wb", selector, function( event ) {\n\tvar elm = event.target,\n\t\t$elm;\n\n\tif ( elm === event.currentTarget ) {\n\t\t$elm = $( elm );\n\t\t$elm.addClass( jsonFailedClass );\n\n\t\t// Identify that initialization has completed\n\t\twb.ready( $elm, componentName );\n\t}\n} );\n\n$document.on( "json-fetched.wb", selector, function( event ) {\n\tvar elm = event.target,\n\t\t$elm = $( elm ),\n\t\tsettings,\n\t\tdsName,\n\t\tJSONresponse = event.fetch.response,\n\t\tisArrayResponse = $.isArray( JSONresponse ),\n\t\tresultSet,\n\t\ti, i_len, i_cache, backlog, selector,\n\t\tpatches, filterTrueness, filterFaslseness, filterPath;\n\n\n\tif ( elm === event.currentTarget ) {\n\n\t\tsettings = wb.getData( $elm, componentName );\n\t\tdsName = "[" + settings.name + "]";\n\t\tpatches = settings.patches || [];\n\t\tfilterPath = settings.fpath;\n\t\tfilterTrueness = settings.filter || [];\n\t\tfilterFaslseness = settings.filternot || [];\n\n\t\tif ( !$.isArray( patches ) ) {\n\t\t\tpatches = [ patches ];\n\t\t}\n\n\t\tif ( isArrayResponse ) {\n\t\t\tJSONresponse = $.extend( [], JSONresponse );\n\t\t} else {\n\t\t\tJSONresponse = $.extend( {}, JSONresponse );\n\t\t}\n\n\t\t// Apply a filtering\n\t\tif ( filterPath ) {\n\t\t\tJSONresponse = getPatchesToFilter( JSONresponse, filterPath, filterTrueness, filterFaslseness );\n\t\t}\n\n\t\t// Apply the patches\n\t\tif ( patches.length ) {\n\t\t\tif ( isArrayResponse && settings.wraproot ) {\n\t\t\t\ti_cache = { };\n\t\t\t\ti_cache[ settings.wraproot ] = JSONresponse;\n\t\t\t\tJSONresponse = i_cache;\n\t\t\t}\n\t\t\tjsonpatch.apply( JSONresponse, patches );\n\t\t}\n\n\t\tif ( settings.debug ) {\n\t\t\tdebugPrintOut( $elm, "initEvent", JSONresponse, patches );\n\t\t}\n\n\t\ttry {\n\t\t\tdatasetCache[ dsName ] = JSONresponse;\n\t\t} catch ( error ) {\n\t\t\treturn;\n\t\t}\n\t\tdatasetCacheSettings[ dsName ] = settings;\n\n\t\tif ( !settings.wait && dsDelayed[ dsName ] ) {\n\t\t\tbacklog = dsDelayed[ dsName ];\n\t\t\ti_len = backlog.length;\n\t\t\tfor ( i = 0; i !== i_len; i += 1 ) {\n\t\t\t\ti_cache = backlog[ i ];\n\t\t\t\tselector = i_cache.selector;\n\t\t\t\tif ( selector.length ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresultSet = jsonpointer.get( JSONresponse, selector );\n\t\t\t\t\t} catch  ( e ) {\n\t\t\t\t\t\tthrow dsName + " - JSON selector not found: " + selector;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresultSet = JSONresponse;\n\t\t\t\t}\n\t\t\t\t$( "#" + i_cache.callerId ).trigger( {\n\t\t\t\t\ttype: "json-fetched.wb",\n\t\t\t\t\tfetch: {\n\t\t\t\t\t\tresponse: resultSet,\n\t\t\t\t\t\tstatus: "200",\n\t\t\t\t\t\trefId: i_cache.refId,\n\t\t\t\t\t\txhr: null\n\t\t\t\t\t}\n\t\t\t\t}, this );\n\t\t\t}\n\t\t}\n\n\t\t// Identify that initialization has completed\n\t\twb.ready( $elm, componentName );\n\t}\n} );\n\n// Apply patches to a preloaded JSON data\n$document.on( patchesEvent, selector, function( event ) {\n\tvar elm = event.target,\n\t\t$elm = $( elm ),\n\t\tpatches = event.patches,\n\t\tfilterPath = event.fpath,\n\t\tfilterTrueness = event.filter || [],\n\t\tfilterFaslseness = event.filternot || [],\n\t\tisCumulative = !!event.cumulative,\n\t\tsettings,\n\t\tdsName,\n\t\tdsJSON, resultSet,\n\t\tdelayedLst,\n\t\ti, i_len, i_cache, pntrSelector;\n\n\tif ( elm === event.currentTarget && $.isArray( patches ) ) {\n\t\tsettings = wb.getData( $elm, componentName );\n\n\t\tif ( !settings ) {\n\t\t\treturn true;\n\t\t}\n\t\tdsName = "[" + settings.name + "]";\n\n\t\tif ( !dsDelayed[ dsName ] ) {\n\t\t\tthrow "Applying patched on undefined dataset name: " + dsName;\n\t\t}\n\n\t\tdsJSON = datasetCache[ dsName ];\n\t\tif ( !isCumulative ) {\n\t\t\tdsJSON = $.extend( true, ( $.isArray( dsJSON ) ? [] : {} ), dsJSON );\n\t\t}\n\n\t\t// Apply a filtering\n\t\tif ( filterPath ) {\n\t\t\tdsJSON = getPatchesToFilter( dsJSON, filterPath, filterTrueness, filterFaslseness );\n\t\t}\n\n\t\tjsonpatch.apply( dsJSON, patches );\n\n\t\tif ( settings.debug ) {\n\t\t\tdebugPrintOut( $elm, "patchesEvent", dsJSON, patches );\n\t\t}\n\n\t\tdelayedLst = dsDelayed[ dsName ];\n\t\ti_len = delayedLst.length;\n\t\tfor ( i = 0; i !== i_len; i += 1 ) {\n\t\t\ti_cache = delayedLst[ i ];\n\t\t\tpntrSelector = i_cache.selector;\n\t\t\tif ( pntrSelector.length ) {\n\t\t\t\ttry {\n\t\t\t\t\tresultSet = jsonpointer.get( dsJSON, pntrSelector );\n\t\t\t\t} catch  ( e ) {\n\t\t\t\t\tthrow dsName + " - JSON selector not found: " + pntrSelector;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresultSet = dsJSON;\n\t\t\t}\n\t\t\t$( "#" + i_cache.callerId ).trigger( {\n\t\t\t\ttype: "json-fetched.wb",\n\t\t\t\tfetch: {\n\t\t\t\t\tresponse: resultSet,\n\t\t\t\t\tstatus: "200",\n\t\t\t\t\trefId: i_cache.refId,\n\t\t\t\t\txhr: null\n\t\t\t\t}\n\t\t\t}, this );\n\t\t}\n\t}\n} );\n\n\n// Used by the JSON-fetch plugin for when trying fetching a resource that is mapped a dataset name\n$document.on( postponeEvent, function( event ) {\n\tvar jsonPostpone = event.postpone,\n\t\tdsName = jsonPostpone.dsname,\n\t\tcallerId = jsonPostpone.callerId,\n\t\trefId = jsonPostpone.refId,\n\t\tselector = jsonPostpone.selector,\n\t\tresultSet;\n\n\tif ( !dsDelayed[ dsName ] ) {\n\t\tdsDelayed[ dsName ] = [ ];\n\t}\n\n\t// Add to the delayed updates list\n\tdsDelayed[ dsName ].push( {\n\t\t"callerId": callerId,\n\t\t"refId": refId,\n\t\t"selector": selector\n\t} );\n\n\t// Send the data if the dataset is ready?\n\tif ( datasetCache[ dsName ] && !datasetCacheSettings[ dsName ].wait ) {\n\t\tresultSet = datasetCache[ dsName ];\n\t\tif ( selector.length ) {\n\t\t\ttry {\n\t\t\t\tresultSet = jsonpointer.get( resultSet, selector );\n\t\t\t} catch  ( e ) {\n\t\t\t\tthrow dsName + " - JSON selector not found: " + selector;\n\t\t\t}\n\t\t}\n\t\t$( "#" + callerId ).trigger( {\n\t\t\ttype: "json-fetched.wb",\n\t\t\tfetch: {\n\t\t\t\tresponse: resultSet,\n\t\t\t\tstatus: "200",\n\t\t\t\trefId: refId,\n\t\t\t\txhr: null\n\t\t\t}\n\t\t}, this );\n\t}\n\n} );\n\n/*\n * Integration with wb-fieldflow\n *\n */\nfunction pushData( $elm, prop, data, reset ) {\n\tvar dtCache = $elm.data( prop );\n\tif ( !dtCache || reset ) {\n\t\tdtCache = [];\n\t}\n\tdtCache.push( data );\n\treturn $elm.data( prop, dtCache );\n}\n\n// Fieldflow "op" action\n$document.on( "op.action.wb-fieldflow", ".wb-fieldflow", function( event, data ) {\n\n\tif ( !data.op ) {\n\t\treturn;\n\t}\n\n\t// Postpone the event for form submission\n\tdata.preventSubmit = true;\n\tpushData( $( data.provEvt ), "wb-fieldflow-submit", data );\n} );\n\n// Fieldflow "op" submit\n$document.on( "op.submit.wb-fieldflow", ".wb-fieldflow", function( event, data ) {\n\n\t// Get the hbs Plugin\n\tvar op = data.op,\n\t\tsource = data.source,\n\t\tops;\n\n\tif ( !op ) {\n\t\treturn true;\n\t}\n\n\tif ( !$.isArray( op ) ) {\n\t\tops = [];\n\t\tops.push( op );\n\t} else {\n\t\tops = op;\n\t}\n\n\t$( source ).trigger( {\n\t\ttype: "patches.wb-jsonmanager",\n\t\tpatches: ops\n\t} );\n} );\n\n// Bind the init event of the plugin\n$document.on( "timerpoke.wb " + initEvent, selector, init );\n\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, wb );\n\n/**\n * @title Menu for GCWeb v5\n * @overview Menu keyboard and mouse interaction with supporting responsiveness\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @duboisp\n */\n( function( $, wb ) {\n"use strict";\n\nvar componentName = "gcweb-menu",\n\tselector = ".gcweb-menu",\n\tinitEvent = "wb-init" + selector,\n\t$document = wb.doc,\n\tselectorAjaxed =  selector + " [data-ajax-replace]," + selector + " [data-ajax-append]," + selector + " [data-ajax-prepend]," + selector + " [data-wb-ajax]",\n\tglobalTimeoutOn,\n\tglobalTimeoutOff,\n\thoverDelay = 350,\n\tjustOpened,\n\tisMobileMode, // Mobile vs Desktop\n\tisMediumView,\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\tajaxFetch;\n\t\tif ( elm ) {\n\n\t\t\t// If the menu item are ajaxed in, initialize after the ajax is completed\n\t\t\tajaxFetch = elm.querySelector( selectorAjaxed );\n\n\t\t\tif ( !ajaxFetch ) {\n\t\t\t\tonAjaxLoaded( elm.firstChild );\n\t\t\t}\n\n\n\t\t}\n\t},\n\tonAjaxLoaded = function( subElm ) {\n\t\tvar $elm = $( subElm ).parentsUntil( selector ).parents(),\n\t\t\thtmlClassName = document.querySelector( "html" ).className;\n\t\tisMobileMode = htmlClassName.indexOf( "smallview" ) !== -1;\n\t\tisMediumView = htmlClassName.indexOf( "mediumview" ) !== -1;\n\n\t\tif ( isMobileMode || isMediumView ) {\n\t\t\tsetMnu3LevelOrientationExpandState( false, isMediumView );\n\t\t}\n\n\t\t// Identify that initialization has completed\n\t\twb.ready( $elm, componentName );\n\t};\n\nfunction OpenMenu( elm ) {\n\n\t// If already open, do nothing\n\tif ( elm.getAttribute( "aria-expanded" ) === "true" ) {\n\t\treturn;\n\t}\n\n\t// Close the one that is currently open for this level and deeper\n\tvar parentMenu = elm.parentElement.parentElement;\n\n\tvar menuOpen = parentMenu.querySelector( "[aria-haspopup][aria-expanded=true]:not([data-keep-expanded=md-min])" );\n\n\t// Only close other menu in tablet and desktop mode\n\tif ( menuOpen && !isMobileMode ) {\n\t\tCloseMenu( menuOpen, true );\n\t}\n\n\t// Open the menu\n\telm.setAttribute( "aria-expanded", "true" );\n\n\tjustOpened = elm;\n\tsetTimeout( function() {\n\t\tjustOpened = false;\n\t}, hoverDelay );\n\n}\nfunction CloseMenu( elm, force ) {\n\n\t// Ensure elm is targeted on the haspopup element\n\tif ( !elm.hasAttribute( "aria-haspopup" ) ) {\n\t\telm = elm.previousElementSibling;\n\t}\n\n\tif ( !force ) {\n\n\t\t// Can the menu be closed?\n\t\t// Get the menu item that has the focus.\n\t\tvar currentFocusIsOn = elm.nextElementSibling.querySelector( "[role=menuitem]:focus" );\n\t\tvar siblingHasFocus = elm.parentElement.parentElement.querySelector( "[role=menuitem]:focus" );\n\n\t\t// Check if we keep the menu opon\n\t\tif ( currentFocusIsOn || siblingHasFocus === elm ) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\telm.setAttribute( "aria-expanded", "false" );\n}\n\n// On hover, wait for the delay before to open the menu\nfunction OpenMenuWithDelay( elm ) {\n\n\tif ( elm.dataset.keepExpanded === "md-min" ) {\n\t\treturn;\n\t}\n\n\t// Prevent any pending to be open to trigger\n\tclearTimeout( globalTimeoutOn );\n\n\tglobalTimeoutOn = setTimeout( function() {\n\t\tOpenMenu( elm );\n\t}, hoverDelay );\n}\nfunction CloseMenuWithDelay( elm ) {\n\n\tif ( elm.dataset.keepExpanded === "md-min" ) {\n\t\treturn;\n\t}\n\n\tclearTimeout( globalTimeoutOff );\n\n\tglobalTimeoutOff = setTimeout( function() {\n\t\tCloseMenu( elm );\n\t}, hoverDelay );\n}\n\n// Open menu on mouse hovering\n$document.on( "mouseenter", selector + " ul [aria-haspopup]", function( event ) {\n\n\t// There is no "mouseenter" in mobile\n\tif ( !isMobileMode ) {\n\t\tclearTimeout( globalTimeoutOff );\n\t\tOpenMenuWithDelay( event.currentTarget );\n\t}\n} );\n\n\n$document.on( "focusin", selector + " ul [aria-haspopup]", function( event ) {\n\n\t// Don\'t open the submenu\n\tif ( isMobileMode ) {\n\t\treturn;\n\t}\n\n\t// Open the menu, no delay\n\tOpenMenu( event.currentTarget );\n\n} );\n\n// The user get inside the submenu, we should cancel the "close" with delay event\n$document.on( "mouseenter focusin", selector + " [aria-haspopup] + [role=menu]", function( event ) {\n\n\t// Prevent the menu to collapse\n\t// Note: elm.id is already defined because of the mouseenter event of the parent menu element\n\n\tvar elm = event.currentTarget.previousElementSibling;\n\n\tif ( elm.dataset.keepExpanded === "md-min" ) {\n\t\treturn;\n\t}\n\n\t// There is no "mouseenter" in mobile and ensure it don\'t get trigger when activating the button menu\n\tif ( isMobileMode || justOpened === event.currentTarget ) {\n\t\treturn;\n\t}\n\n\tclearTimeout( globalTimeoutOff );\n} );\n\n\n$document.on( "mouseleave", selector + " [aria-haspopup]", function( event ) {\n\n\t// There is no "mouseenter" in mobile\n\tif ( !isMobileMode ) {\n\t\tclearTimeout( globalTimeoutOn );\n\t\tCloseMenuWithDelay( event.currentTarget );\n\t}\n} );\n\n$document.on( "focusout", selector + " [aria-haspopup]", function( event ) {\n\n\t// Don\'t close the submenu\n\tif ( isMobileMode ) {\n\t\treturn;\n\t}\n\n\t// Don\'t close it if the user go in the submenu\n\tCloseMenuWithDelay( event.currentTarget );\n} );\n\n$document.on( "mouseleave focusout", selector + " [aria-haspopup] + [role=menu]", function( event ) {\n\n\t// Collapse the menu\n\t// Note: elm.id is already defined because of the mouseenter event\n\n\tvar elm = event.currentTarget.previousElementSibling;\n\n\tif ( elm.dataset.keepExpanded === "md-min" ) {\n\t\treturn;\n\t}\n\n\t// There is no "mouseleave" in mobile\n\tif ( isMobileMode ) {\n\t\treturn;\n\t}\n\n\tCloseMenuWithDelay( event.currentTarget );\n} );\n\n\n/* **** Do we need to handle the click??? that will be handled by the "focusin" and "focusout" if something */\n/*\n   Menu current state is...       | Action\n  --------------------------------+------------------\n    Open                          |  Close the menu\n  --------------------------------+------------------\n    Delay to be open              |  Open the menu right now\n  --------------------------------+------------------\n    Short delay after it was open |  Keep the menu open\n  --------------------------------+------------------\n    Close                         |  Open the menu\n  --------------------------------+------------------\n*/\n\n// Open right away the popup\n$document.on( "click", selector + " [aria-haspopup]", function( event ) {\n\n\tvar elm = event.currentTarget,\n\t\telmToGiveFocus;\n\n\t// Only for mobile view or the menu button\n\tif ( isMobileMode || elm.nodeName === "BUTTON" ) {\n\n\t\t// Toggle\n\t\tif ( elm.getAttribute( "aria-expanded" ) === "true" ) {\n\t\t\tif ( justOpened !== elm ) {\n\t\t\t\tCloseMenu( elm, true );\n\t\t\t}\n\t\t} else {\n\t\t\tOpenMenu( elm );\n\n\t\t\t// Focus on the first menu item\n\t\t\telmToGiveFocus = elm.nextElementSibling.querySelector( "[role=menuitem]" );\n\t\t\telmToGiveFocus.focus();\n\t\t\telmToGiveFocus.setAttribute( "tabindex", "0" );\n\n\t\t}\n\t}\n\n\t// Stop default behaviour\n\tevent.stopImmediatePropagation();\n\tevent.preventDefault();\n} );\n\n// This is for the "most requested" menu item\nfunction setMnu3LevelOrientationExpandState( isVertical, isExpanded ) {\n\tvar mnu3Level = document.querySelectorAll( "[role=menu] [role=menu] [role=menuitem][aria-haspopup=true]" ),\n\t\ti, i_len = mnu3Level.length,\n\t\texpandState = ( isExpanded ? "true" : "false" ),\n\t\torientation = ( isVertical ? "vertical" : "horizontal" ),\n\t\texpandStateItem = expandState;\n\n\tfor ( i = 0; i < i_len; i++ ) {\n\n\t\t// Keep it expanded if focus are inside submenu\n\t\texpandStateItem = ( mnu3Level[ i ].nextElementSibling.querySelector( "[role=menuitem]:focus" ) ? "true" : expandState );\n\n\t\tmnu3Level[ i ].setAttribute( "aria-expanded", expandStateItem );\n\t\tmnu3Level[ i ].parentElement.previousElementSibling.setAttribute( "aria-orientation", orientation );\n\t}\n}\n\n// Change the main menu mode\n$document.on( wb.resizeEvents, function( event ) {\n\n\tswitch ( event.type ) {\n\tcase "xxsmallview":\n\tcase "xsmallview":\n\tcase "smallview":\n\t\tisMobileMode = true;\n\t\tsetMnu3LevelOrientationExpandState( false, false );\n\t\tbreak;\n\tcase "mediumview":\n\t\tisMobileMode = false;\n\t\tsetMnu3LevelOrientationExpandState( false, true );\n\t\tbreak;\n\tcase "largeview":\n\tcase "xlargeview":\n\tdefault:\n\t\tisMobileMode = false;\n\t\tsetMnu3LevelOrientationExpandState( true, true );\n\t}\n} );\n\n/**\n* keycode - determines what action to take when a key is pressed\n* @private\n* @param {object} event - the event that contains information about the key\n* @param {string} orientation - whether the menu is horizontal or vertical (navigated with left/right or up/down)\n* @returns name of action to take or false if invalid key\n* @type string / bool\n*/\nfunction keycode( code ) {\n\n\tif ( code === 9 ) {\n\t\treturn "tab";\n\t}\n\n\tif ( code === 13 || code === 32 ) {\n\t\treturn "enter";\n\t}\n\tif ( code === 27 ) {\n\t\treturn "esc";\n\t}\n\tif ( code === 39 ) { //right arrow\n\t\treturn "right";\n\t}\n\tif ( code === 37 ) { //left arrow\n\t\treturn "left";\n\t}\n\tif ( code === 40 ) { //down arrow\n\t\treturn "down";\n\t}\n\tif ( code === 38 ) { //up arrow\n\t\treturn "up";\n\t}\n\n\n\treturn false;\n};\n\n// Global hook, close the menu on "ESC" when its state are open.\n$document.on( "keydown", function( event ) {\n\tif ( event.keyCode === 27 ) {\n\t\tCloseMenu( document.querySelector( selector + " button" ) );\n\t}\n} );\n\n// Keyboard navigation for each menu item\n$document.on( "keydown", selector + " button, " + selector + " [role=menuitem]", function( event ) {\n\n\tvar elm = event.currentTarget,\n\t\tkey = keycode( event.charCode || event.keyCode );\n\n\n\t// Get the menu item that has the focus.\n\tvar currentFocusIsOn = document.querySelector( "[role=menuitem]:focus" ) || elm,\n\t\tparent = currentFocusIsOn.parentElement,\n\t\tgrandParent = parent.parentElement,\n\t\tisCurrentButtonMenu = ( currentFocusIsOn.nodeName === "BUTTON" );\n\n\t// FIRST CHILD POPOP\n\tvar firstChildPopup;\n\tif ( currentFocusIsOn.nextElementSibling ) {\n\t\tfirstChildPopup = currentFocusIsOn.nextElementSibling.querySelector( "[role=\'menuitem\']" );\n\t}\n\n\t// NEXT MENU ITEM\n\tvar nextSiblingMenuItem;\n\tif ( parent.nextElementSibling ) {\n\t\tnextSiblingMenuItem = parent.nextElementSibling.querySelector( "[role=menuitem]" );\n\n\t\t// Check if we have hit a separator, go to the next one. The separator can\'t be the last item and are not followed by another separator.\n\t\tif ( !nextSiblingMenuItem ) {\n\t\t\tnextSiblingMenuItem = parent.nextElementSibling.nextElementSibling.querySelector( "[role=menuitem]" );\n\t\t}\n\t} else {\n\n\t\t// Get first item and take in consideration if the sub-menu is persistant open\n\t\tif ( !isMobileMode && currentFocusIsOn.dataset.keepExpanded && firstChildPopup ) {\n\n\t\t\t// The current focus is on a persistant open menu item, the next menu item is the first child\n\t\t\tnextSiblingMenuItem = firstChildPopup;\n\t\t} else if ( !isMobileMode && grandParent.previousElementSibling.dataset.keepExpanded ) {\n\n\t\t\t// The current focus is on the last item of the persistant menu\n\t\t\t// Should go the next item of the parent menu item (not supported),\n\t\t\t// but in our use case this is the first item of the parent men\n\t\t\tnextSiblingMenuItem = grandParent.parentElement.parentElement.querySelector( "[role=menuitem]" );\n\t\t} else {\n\t\t\tnextSiblingMenuItem = grandParent.querySelector( "[role=menuitem]" );\n\t\t}\n\t}\n\n\t// PARENT\n\tvar parentPopupBtn = grandParent.previousElementSibling;\n\n\t// PREVIOUS MENU ITEM\n\tvar previousSiblingMenuItem;\n\tif ( parent.previousElementSibling ) {\n\t\tpreviousSiblingMenuItem = parent.previousElementSibling.querySelector( "[role=menuitem]" );\n\n\t\t// Check if we have hit a separator. A separator is not the first items\n\t\tif ( !previousSiblingMenuItem ) {\n\t\t\tpreviousSiblingMenuItem = parent.previousElementSibling.previousElementSibling.querySelector( "[role=menuitem]" );\n\t\t}\n\t} else {\n\n\t\t// Get the last item, take in consideration one level of persistant open menu\n\t\tif ( !isMobileMode && grandParent.lastElementChild.querySelector( "[role=menuitem]" ).dataset.keepExpanded ) {\n\n\t\t\t// The last item is persistant open, get it\'s last children\n\t\t\tpreviousSiblingMenuItem = grandParent.lastElementChild.querySelector( "[role=menuitem]" ).nextElementSibling.lastElementChild.querySelector( "[role=menuitem]" );\n\t\t} else if ( !isMobileMode && grandParent.previousElementSibling.dataset.keepExpanded && parentPopupBtn ) {\n\n\t\t\t// Get the parent, this is the first items of a persistant open menu\n\t\t\tpreviousSiblingMenuItem = parentPopupBtn;\n\t\t} else if ( isCurrentButtonMenu ) {\n\n\t\t\t// Get the last menu item\n\t\t\tpreviousSiblingMenuItem = currentFocusIsOn.nextElementSibling.lastElementChild.querySelector( "[role=menuitem]" );\n\t\t} else {\n\n\t\t\t// Get the last item of the current menu\n\t\t\tpreviousSiblingMenuItem = grandParent.lastElementChild.querySelector( "[role=menuitem]" );\n\t\t}\n\n\t}\n\n\t// NEXT Menu item after the Separator\n\t// Next Separator Orientation\n\tvar isNextSeparatorOrientationVertical,\n\t\tnextSeparatorMenuItem,\n\t\titeratedItem = parent;\n\twhile ( iteratedItem.nextElementSibling ) {\n\t\titeratedItem = iteratedItem.nextElementSibling;\n\t\tif ( iteratedItem.getAttribute( "role" ) === "separator" ) {\n\t\t\tif ( iteratedItem.hasAttribute( "aria-orientation" ) && iteratedItem.getAttribute( "aria-orientation" ) === "vertical" ) {\n\t\t\t\tisNextSeparatorOrientationVertical = true;\n\t\t\t} else {\n\t\t\t\tisNextSeparatorOrientationVertical = false;\n\t\t\t}\n\t\t\tnextSeparatorMenuItem = iteratedItem.nextElementSibling.querySelector( "[role=menuitem]" );\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Previous Menu item after the Separator\n\t// Previous Separator Orientation\n\tvar isPreviousSeparatorOrientationVertical,\n\t\tpreviousSeparatorMenuItem;\n\titeratedItem = parent;\n\twhile ( iteratedItem.previousElementSibling ) {\n\t\titeratedItem = iteratedItem.previousElementSibling;\n\t\tif ( iteratedItem.getAttribute( "role" ) === "separator" ) {\n\t\t\tif ( previousSeparatorMenuItem ) {\n\t\t\t\tbreak; // Run until we reach the first item or the next separator.\n\t\t\t}\n\t\t\tif ( iteratedItem.hasAttribute( "aria-orientation" ) && iteratedItem.getAttribute( "aria-orientation" ) === "vertical" ) {\n\t\t\t\tisPreviousSeparatorOrientationVertical = true;\n\t\t\t} else {\n\t\t\t\tisPreviousSeparatorOrientationVertical = false;\n\t\t\t}\n\t\t\tpreviousSeparatorMenuItem = iteratedItem.previousElementSibling;\n\t\t}\n\t\tif ( previousSeparatorMenuItem ) {\n\t\t\tpreviousSeparatorMenuItem = iteratedItem; // Run until we reach the first item or the next separator.\n\t\t}\n\t}\n\n\t// Ensure we are pointing to the first menu item\n\tif ( previousSeparatorMenuItem ) {\n\t\tpreviousSeparatorMenuItem = previousSeparatorMenuItem.querySelector( "[role=menuitem]" );\n\t}\n\n\t/*\n\t * Developer note:\n\n\tFor the "Most requested" menu.\n\t- Don\'t skip that navigation item when it receive the focus\n\t- when looking for the last, if that menuitem is expanded, then grab it\'s last items.\n\t*/\n\n\tif ( !isCurrentButtonMenu ) {\n\t\tcurrentFocusIsOn.setAttribute( "tabindex", "-1" );\n\t}\n\n\tvar elmToGiveFocus;\n\tif ( key === "down" && nextSiblingMenuItem  ) {\n\t\telmToGiveFocus = nextSiblingMenuItem;\n\t} else if ( key === "up" && previousSiblingMenuItem ) {\n\t\telmToGiveFocus = previousSiblingMenuItem;\n\t} else if ( ( !isCurrentButtonMenu && key === "right" && firstChildPopup ) || key === "enter" && firstChildPopup ) {\n\t\telmToGiveFocus = firstChildPopup;\n\t} else if ( isNextSeparatorOrientationVertical && key === "right" ) {\n\t\telmToGiveFocus = nextSeparatorMenuItem;\n\t} else if ( isPreviousSeparatorOrientationVertical && key === "left" ) {\n\t\telmToGiveFocus = previousSeparatorMenuItem;\n\t} else if ( ( !isCurrentButtonMenu && key === "left" ) || ( !isCurrentButtonMenu && key === "esc" ) ) {\n\t\telmToGiveFocus = parentPopupBtn;\n\t} else if ( key  === "tab"  ) {\n\t\treturn;\n\t}\n\n\tif ( !isCurrentButtonMenu && ( key === "left" ||  key === "esc" ) ) {\n\n\t\t// Close the menu\n\t\tif ( isMobileMode &&\n\t\t\t\telmToGiveFocus.getAttribute( "aria-expanded" ) === "true" ) {\n\t\t\telmToGiveFocus.setAttribute( "aria-expanded", "false" );\n\t\t}\n\t}\n\n\t// Focus on the element\n\tif ( elmToGiveFocus ) {\n\n\t\t// Open the sub-menu automatically for mobile and menu button\n\t\tif ( isMobileMode || isCurrentButtonMenu ) {\n\t\t\tvar popup = elmToGiveFocus.parentElement.parentElement.previousElementSibling;\n\t\t\tif ( popup.getAttribute( "aria-expanded" ) !== "true" ) {\n\n\t\t\t\t// Open the menu, no delay\n\t\t\t\tOpenMenu( popup );\n\t\t\t}\n\t\t}\n\n\t\telmToGiveFocus.setAttribute( "tabindex", "0" );\n\t\telmToGiveFocus.focus();\n\n\t\t// Stop default behaviour\n\t\tevent.stopImmediatePropagation();\n\t\tevent.preventDefault();\n\t}\n\n} );\n\n// When the menu item are ajaxed in\n$document.on( "ajax-fetched.wb ajax-failed.wb", selectorAjaxed, function( event ) {\n\n\tvar elm = event.target;\n\n\t// Filter out any events triggered by descendants\n\tif ( event.currentTarget === elm ) {\n\t\tonAjaxLoaded( elm );\n\t}\n} );\n\n\n// Bind the init event of the plugin\n$document.on( "timerpoke.wb " + initEvent, selector, init );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, wb );\n\n/**\n * @title WET-BOEW URL mapping\n * @overview Execute pre-configured action based on url query string\n * @license wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n * @author @duboisp\n */\n( function( $, window, wb ) {\n"use strict";\n\n/*\n * Variable and function definitions.\n * These are global to the plugin - meaning that they will be initialized once per page,\n * not once per instance of plugin on the page. So, this is a good place to define\n * variables that are common to all instances of the plugin on a page.\n */\nvar componentName = "wb-urlmapping",\n\tselector = "[data-" + componentName + "]",\n\tinitEvent = "wb-init." + componentName,\n\tdoMappingEvent = "domapping." + componentName,\n\t$document = wb.doc,\n\tauthTrigger,\n\tpatchDefault = {\n\t\top: "move",\n\t\tpath: "{base}",\n\t\tfrom: "{base}/{qval}"\n\t},\n\n\t/**\n\t * @method init\n\t * @param {jQuery Event} event Event that triggered the function call\n\t */\n\tinit = function( event ) {\n\n\t\t// Start initialization\n\t\t// returns DOM object = proceed with init\n\t\t// returns undefined = do not proceed with init (e.g., already initialized)\n\t\tvar elm = wb.init( event, componentName, selector ),\n\t\t\t$elm;\n\n\t\tif ( elm ) {\n\t\t\t$elm = $( elm );\n\n\t\t\t// Only allow the first wb-urlmapping instance to trigger WET\n\t\t\tif ( !authTrigger ) {\n\t\t\t\tauthTrigger = elm;\n\t\t\t}\n\n\t\t\t// Identify that initialization has completed\n\t\t\twb.ready( $elm, componentName );\n\n\t\t\tif ( !wb.isReady ) {\n\n\t\t\t\t// Execution of any action after WET is ready\n\t\t\t\t$document.one( "wb-ready.wb", function( ) {\n\t\t\t\t\t$elm.trigger( doMappingEvent );\n\t\t\t\t} );\n\t\t\t} else {\n\t\t\t\t$elm.trigger( doMappingEvent );\n\t\t\t}\n\t\t}\n\t},\n\texecuteAction = function( $elm, cValue, actions ) {\n\n\t\tvar i, i_len, i_cache, cache_action,\n\t\t\tregMatchValue,\n\t\t\tpattern, cValueParsed,\n\t\t\tdefaultValue;\n\n\t\tif ( !$.isArray( actions ) ) {\n\t\t\tactions = [ actions ];\n\t\t} else {\n\t\t\tactions = $.extend( [], actions );\n\t\t}\n\n\t\t// Fix any action that was defined as query dependent\n\t\ti_len = actions.length;\n\t\tfor ( i = 0; i !== i_len; i += 1 ) {\n\t\t\ti_cache = actions[ i ];\n\n\t\t\tcache_action = i_cache.action;\n\t\t\tif ( !cache_action ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tregMatchValue = i_cache.match;\n\t\t\tdefaultValue = i_cache.default;\n\t\t\tcValueParsed = false;\n\n\t\t\t// Abort if we try to match and there is no default set\n\t\t\tif ( regMatchValue && !defaultValue ) {\n\t\t\t\tthrow "\'match\' and \'default\' property need to be set";\n\t\t\t}\n\n\t\t\t// Validate the value if it match the regular expression / string pattern.\n\t\t\tif ( !!defaultValue && cValue.length && typeof regMatchValue === "string" ) {\n\t\t\t\ttry {\n\t\t\t\t\tpattern = new RegExp( regMatchValue );\n\t\t\t\t\tcValueParsed = pattern.exec( cValue );\n\n\t\t\t\t\t// Fall back on default if no match found\n\t\t\t\t\tcValueParsed = !!cValueParsed ? cValueParsed : defaultValue;\n\t\t\t\t} catch ( e ) { }\n\t\t\t}\n\n\t\t\tif ( !i_cache.qval && cValueParsed ) {\n\t\t\t\ti_cache.qval = cValueParsed;\n\t\t\t}\n\n\n\t\t\tswitch ( cache_action ) {\n\n\t\t\tcase "patch":\n\t\t\t\tvar ops = i_cache.patches,\n\t\t\t\t\tbasePntr = i_cache.base || "/";\n\t\t\t\tif ( !ops ) {\n\t\t\t\t\tops = [ patchDefault ];\n\t\t\t\t\ti_cache.cumulative = true;\n\t\t\t\t}\n\t\t\t\tif ( !$.isArray( ops ) ) {\n\t\t\t\t\tops = [ ops ];\n\t\t\t\t}\n\t\t\t\tops = patchFixArray( ops, i_cache.qval, basePntr );\n\t\t\t\ti_cache.patches = ops;\n\t\t\t\tbreak;\n\t\t\tcase "ajax":\n\t\t\t\tif ( i_cache.trigger && $elm[ 0 ] !== authTrigger ) {\n\t\t\t\t\ti_cache.trigger = false;\n\t\t\t\t}\n\t\t\t\ti_cache.url = replaceMappingKeys( i_cache.url, i_cache.qval );\n\t\t\t\tbreak;\n\t\t\tcase "tblfilter":\n\t\t\t\ti_cache.value = replaceMappingKeys( i_cache.value, i_cache.qval );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\n\t\t\t\t// Just do the action as defined.\n\t\t\t\tbreak;\n\n\t\t\t}\n\t\t}\n\n\n\t\t// Send the list of actions to be dispatched by the actionmng\n\t\t$elm.trigger( {\n\t\t\ttype: "do.wb-actionmng",\n\t\t\tactions: actions\n\t\t} );\n\t},\n\tpatchFixArray = function( patchArray, val, basePointer ) {\n\n\t\tvar i, i_len = patchArray.length, i_cache,\n\t\t\tpatchesFixed = [], patch_cache;\n\n\t\tif ( !basePointer ) {\n\t\t\tbasePointer = "/";\n\t\t}\n\n\t\tfor ( i = 0; i !== i_len; i += 1 ) {\n\t\t\ti_cache = patchArray[ i ];\n\t\t\tpatch_cache = $.extend( { }, i_cache );\n\t\t\tif ( i_cache.path ) {\n\t\t\t\tpatch_cache.path = replaceMappingKeys( i_cache.path, val, basePointer );\n\t\t\t}\n\t\t\tif ( i_cache.from ) {\n\t\t\t\tpatch_cache.from = replaceMappingKeys( i_cache.from, val, basePointer );\n\t\t\t}\n\t\t\tif ( i_cache.value ) {\n\t\t\t\tpatch_cache.value = replaceMappingKeys( i_cache.value, val, basePointer );\n\t\t\t}\n\t\t\tpatchesFixed.push( patch_cache );\n\t\t}\n\t\treturn patchesFixed;\n\t},\n\treplaceMappingKeys = function( search, val, basePointer ) {\n\t\tif ( !val ) {\n\t\t\treturn search;\n\t\t}\n\t\tif ( !basePointer ) {\n\t\t\treturn search.replace( /\\{qval\\}/, val );\n\t\t} else {\n\t\t\treturn search.replace( /\\{qval\\}/, val ).replace( /\\{base\\}/, basePointer );\n\t\t}\n\t},\n\tgetUrlParams = function() {\n\n\t\t// https://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript#answer-2880929\n\t\tvar urlParams = {},\n\t\t\tpl = /\\+/g, // Regex for replacing addition symbol with a space\n\t\t\tsearch = /([^&=]+)=?([^&]*)/g,\n\t\t\tdecode = function( s ) {\n\t\t\t\treturn decodeURIComponent( s.replace( pl, " " ) );\n\t\t\t},\n\t\t\tquery = window.location.search.substring( 1 ),\n\t\t\tmatch = search.exec( query );\n\n\t\twhile ( match ) {\n\t\t\turlParams[ decode( match[ 1 ] ) ] = decode( match[ 2 ] );\n\t\t\tmatch = search.exec( query );\n\t\t}\n\n\t\treturn urlParams;\n\t};\n\n$document.on( doMappingEvent, selector, function( event ) {\n\n\tvar $elm = $( event.target ),\n\t\turlParams = getUrlParams(),\n\t\tcKey, cValue, settingQuery,\n\t\tsettings = $.extend( {}, window[ componentName ] || { }, wb.getData( $elm, componentName ) );\n\n\tfor ( cKey in urlParams ) {\n\t\tcValue = urlParams[ cKey ];\n\t\tsettingQuery = settings[ cKey + "=" + cValue ] || settings[ cKey ];\n\n\t\tif ( typeof settingQuery === "object" ) {\n\t\t\texecuteAction( $elm, cValue, settingQuery );\n\t\t\tif ( !settings.multiplequery ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Bind the init event of the plugin\n$document.on( "timerpoke.wb " + initEvent, selector, init );\n\n// Add the timer poke to initialize the plugin\nwb.add( selector );\n\n} )( jQuery, window, wb );\n\n/*\n * Web Experience Toolkit (WET) / Boîte à outils de l\'expérience Web (BOEW)\n * wet-boew.github.io/wet-boew/License-en.html / wet-boew.github.io/wet-boew/Licence-fr.html\n */\n( function( $, document, wb ) {\n"use strict";\n\nvar $document = wb.doc,\n\tsearchSelector = "#wb-srch-q",\n\t$search = $( searchSelector ),\n\t$searchDataList = $( "#" + $search.attr( "list" ) ),\n\n//Search Autocomplete\n\tqueryAutoComplete = function( query ) {\n\t\tif ( query.length > 0 ) {\n\t\t\t$( this ).trigger( {\n\t\t\t\ttype: "ajax-fetch.wb",\n\t\t\t\tfetch: {\n\t\t\t\t\turl: wb.pageUrlParts.protocol + "//clients1.google.com/complete/search?client=partner&sugexp=gsnos%2Cn%3D13&gs_rn=25&gs_ri=partner&partnerid=" + window.encodeURIComponent( "008724028898028201144:knjjdikrhq0+lang:" + wb.lang ) + "&types=t&ds=cse&cp=3&gs_id=b&hl=" + wb.lang + "&q=" + encodeURI( query ),\n\t\t\t\t\tdataType: "jsonp",\n\t\t\t\t\tjsonp: "callback"\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t};\n\n//Queries  the autocomplete API\n$document.on( "change keyup", searchSelector, function( event ) {\n\tvar target = event.target,\n\t\tquery = event.target.value,\n\t\twhich = event.which;\n\n\tswitch ( event.type ) {\n\tcase "change":\n\t\tqueryAutoComplete.call( target, query );\n\t\tbreak;\n\tcase "keyup":\n\t\tif ( !( event.ctrlKey || event.altKey || event.metaKey ) ) {\n\n\t\t\t// Spacebar, a - z keys, 0 - 9 keys punctuation, and symbols\n\t\t\tif ( which === 32 || ( which > 47 && which < 91 ) ||\n\t\t\t\t( which > 95 && which < 112 ) || ( which > 159 && which < 177 ) ||\n\t\t\t\t( which > 187 && which < 223 ) ) {\n\t\t\t\tqueryAutoComplete.call( target, query );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n//Processes the autocomplete API results\n$document.on( "ajax-fetched.wb", searchSelector, function( event ) {\n\tvar suggestions = event.fetch.response[ 1 ],\n\t\tlenSuggestions = suggestions.length,\n\t\toptions = "",\n\t\tindIssue, issue;\n\n\t$searchDataList.empty();\n\n\tfor ( indIssue = 0; indIssue < lenSuggestions; indIssue += 1 ) {\n\t\tissue = suggestions[ indIssue ];\n\n\t\toptions += "<option label=\\"" + issue[ 0 ] + "\\" value=\\"" + issue[ 0 ] + "\\"></option>";\n\t}\n\n\tif ( wb.ielt10 ) {\n\t\toptions = "<select>" + options + "</select>";\n\t}\n\n\t$searchDataList.append( options );\n\n\t$search.trigger( "wb-update.wb-datalist" );\n} );\n\nwindow[ "wb-data-ajax" ] = {\n\tcorsFallback: function( fetchObj ) {\n\t\tfetchObj.url = fetchObj.url.replace( ".html", ".htmlp" );\n\t\treturn fetchObj;\n\t}\n};\n\n//Report a problem form - reveal textbox when checkbox is selected\n$( "[data-reveal]" ).change( function() {\n\tvar $elm = $( this ),\n\t\tselector = $elm.attr( "data-reveal" );\n\treturn ( $elm.is( ":checked" ) ) ? $( selector ).removeClass( "hide" ) : $( selector ).addClass( "hide" );\n} );\n\n\n} )( jQuery, document, wb );\n'}]);